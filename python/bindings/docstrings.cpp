// -*- coding: utf-8 -*-
// Copyright (C) 2006-2011 Rosen Diankov (rosen.diankov@gmail.com)
//
// This file is part of OpenRAVE.
// OpenRAVE is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
/// Auto-generated using build_openravepy_internal.py from ../python/bindings/*.cpp file
#include "docstrings.h"
namespace openravepy {
void InitializeComments(std::map<std::string,std::string>& m)
{m["en function RaveCreateSensorSystem"] = "\n\nOPENRAVE_API   SensorSystemBasePtr  **RaveCreateSensorSystem**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function KinBody::KinBodyStateSaver  GetBody"] = "\n\nKinBodyPtr  **GetBody**\\()\n    \n            ";
m["en function KinBody::KinBodyStateSaver  Restore"] = "\n\nvoid  **Restore**\\(boost::shared_ptr<  KinBody  > body = boost::shared_ptr<  KinBody  >() )\n    \n    restore the state\n    \n    *Parameters*\n     ``body`` - \n      if set, will attempt to restore the stored state to the passed in body, otherwise will restore it for the original body. \\ *Exceptions*\n     ``openrave_exception`` - \n      if the passed in body is not compatible with the saved state, will throw\n    \n            ";
m["en function KinBody::KinBodyStateSaver  Release"] = "\n\nvoid  **Release**\\()\n    \n    release the body state. _pbody will not get restored on destruction\n    \n    After this call, it will still be possible to use Restore.         ";
m["en function KinBody InitFromBoxes \"const std::vector< AABB; bool\""] = "\n\nbool  **InitFromBoxes**\\(const std::vector<  AABB  > & boxes, bool visible)\n    \n    Create a kinbody with one link composed of an array of aligned bounding boxes.\n    \n    *Parameters*\n     ``boxes`` - \n      the array of aligned bounding boxes that will comprise of the body \n     ``visible`` - \n      if true, the boxes will be rendered in the scene \n            ";
m["en function KinBody GetChain"] = "\n\nbool  **GetChain**\\(int linkindex1, int linkindex2, std::vector<  JointPtr  > & vjoints)\n    \n    Computes the minimal chain of joints that are between two links in the order of linkindex1 to linkindex2.\n    \n    *Parameters*\n     ``linkindex1`` - \n      the link index to start the search \n     ``linkindex2`` - \n      the link index where the search ends \n     ``vjoints`` - \n      the joints to fill that describe the chain Passive joints are also used in the computation of the chain and can be returned. Note that a passive joint has a joint index and dof index of -1.\n    \n    *Return*\n        true if the two links are connected (vjoints will be filled), false if the links are separate \n        ";
m["en function KinBody  ComputeInverseDynamics"] = "\n\nvoid  **ComputeInverseDynamics**\\(std::vector<  dReal  > & doftorques, const std::vector<  dReal  > & dofaccelerations, const  ForceTorqueMap  & externalforcetorque = ForceTorqueMap () )\n    \n    Computes the inverse dynamics (torques) from the current robot position, velocity, and acceleration.\n    \n    *Parameters*\n     ``doftorques`` - \n      The output torques. \n     ``dofaccelerations`` - \n      The dof accelerations of the current robot state. If the size is 0, assumes all accelerations are 0 (this should be faster) \n     ``externalforcetorque`` - \n      [optional] Specifies all the external forces/torques acting on the links at their center of mass. The dof values are ready from GetDOFValues() and GetDOFVelocities(). Because openrave does not have a state for robot acceleration, it has to be inserted as a parameter to this function. Acceleration due to gravitation is extracted from GetEnv()->GetPhysicsEngine()->GetGravity(). The method uses Recursive Newton Euler algorithm from Walker Orin and Corke. \n            ";
m["en function KinBody InitFromSpheres"] = "\n\nbool  **InitFromSpheres**\\(const std::vector<  Vector  > & spheres, bool visible)\n    \n    Create a kinbody with one link composed of an array of spheres.\n    \n    *Parameters*\n     ``spheres`` - \n      the XYZ position of the spheres with the W coordinate representing the individual radius \n     ``visible`` - \n      if true, the boxes will be rendered in the scene \n            ";
m["en function KinBody InitFromTrimesh"] = "\n\nbool  **InitFromTrimesh**\\(const  Link::TRIMESH  & trimesh, bool visible)\n    \n    Create a kinbody with one link composed of a triangle mesh surface.\n    \n    *Parameters*\n     ``trimesh`` - \n      the triangle mesh \n     ``visible`` - \n      if true, will be rendered in the scene \n            ";
m["en function KinBody InitFromGeometries"] = "\n\nbool  **InitFromGeometries**\\(const std::list<  KinBody::Link::GeometryInfo  > & geometries)\n    \n    Create a kinbody with one link composed of a list of geometries.\n    \n    *Parameters*\n     ``geometries`` - \n      a list of geometry infos to be initialized into new geometry objects, note that the geometry info data is copied \n     ``visible`` - \n      if true, will be rendered in the scene \n            ";
m["en function KinBody SetName"] = "\n\nvoid  **SetName**\\(const std::string & name)\n    \n    Set the name of the robot, notifies the environment and checks for uniqueness.\n    \n            ";
m["en function KinBody GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n    Unique name of the robot.\n    \n            ";
m["en function KinBody GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    Number controllable degrees of freedom of the body.\n    \n    Only uses _vecjoints and last joint for computation, so can work before _ComputeInternalInformation is called.         ";
m["en function KinBody GetDOFValues"] = "\n\nvoid  **GetDOFValues**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint values as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFValues"] = "\n\nvoid  **GetDOFValues**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint values as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFVelocities"] = "\n\nvoid  **GetDOFVelocities**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint velocities as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFVelocities"] = "\n\nvoid  **GetDOFVelocities**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint velocities as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFLimits"] = "\n\nvoid  **GetDOFLimits**\\(std::vector<  dReal  > & lowerlimit, std::vector<  dReal  > & upperlimit, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint limits as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFLimits"] = "\n\nvoid  **GetDOFLimits**\\(std::vector<  dReal  > & lowerlimit, std::vector<  dReal  > & upperlimit, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint limits as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFVelocityLimits"] = "\n\nvoid  **GetDOFVelocityLimits**\\(std::vector<  dReal  > & lowerlimit, std::vector<  dReal  > & upperlimit, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint velocity limits as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFVelocityLimits"] = "\n\nvoid  **GetDOFVelocityLimits**\\(std::vector<  dReal  > & lowerlimit, std::vector<  dReal  > & upperlimit, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint velocity limits as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFAccelerationLimits"] = "\n\nvoid  **GetDOFAccelerationLimits**\\(std::vector<  dReal  > & maxaccelerations, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns the max acceleration for each DOF.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFAccelerationLimits"] = "\n\nvoid  **GetDOFAccelerationLimits**\\(std::vector<  dReal  > & maxaccelerations, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns the max acceleration for each DOF.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFTorqueLimits"] = "\n\nvoid  **GetDOFTorqueLimits**\\(std::vector<  dReal  > & maxaccelerations)\n    \n    Returns the max torque for each DOF.\n    \n            ";
m["en function KinBody GetDOFTorqueLimits"] = "\n\nvoid  **GetDOFTorqueLimits**\\(std::vector<  dReal  > & maxaccelerations)\n    \n    Returns the max torque for each DOF.\n    \n            ";
m["en function KinBody GetDOFMaxVel"] = "\n\nvoid  **GetDOFMaxVel**\\(std::vector<  dReal  > & v)\n    \n            ";
m["en function KinBody GetDOFMaxTorque"] = "\n\nvoid  **GetDOFMaxTorque**\\(std::vector<  dReal  > & v)\n    \n            ";
m["en function KinBody GetDOFMaxAccel"] = "\n\nvoid  **GetDOFMaxAccel**\\(std::vector<  dReal  > & v)\n    \n            ";
m["en function KinBody GetDOFWeights"] = "\n\nvoid  **GetDOFWeights**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    get dof weights\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFWeights"] = "\n\nvoid  **GetDOFWeights**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    get dof weights\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody SetDOFWeights"] = "\n\nvoid  **SetDOFWeights**\\(const std::vector<  dReal  > & weights, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    sets dof weights\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to set the values for. If empty, will use all the dofs \n            ";
m["en function KinBody SetDOFLimits"] = "\n\nvoid  **SetDOFLimits**\\(const std::vector<  dReal  > & lower, const std::vector<  dReal  > & upper)\n    \n    *See*\n        GetDOFLimits \n        ";
m["en function KinBody SetDOFVelocityLimits"] = "\n\nvoid  **SetDOFVelocityLimits**\\(const std::vector<  dReal  > & maxlimits)\n    \n    *See*\n        GetDOFVelocityLimits \n        ";
m["en function KinBody SetDOFAccelerationLimits"] = "\n\nvoid  **SetDOFAccelerationLimits**\\(const std::vector<  dReal  > & maxlimits)\n    \n    *See*\n        GetDOFAccelerationLimits \n        ";
m["en function KinBody SetDOFTorqueLimits"] = "\n\nvoid  **SetDOFTorqueLimits**\\(const std::vector<  dReal  > & maxlimits)\n    \n    *See*\n        GetDOFTorqueLimits \n        ";
m["en function KinBody GetDOFResolutions"] = "\n\nvoid  **GetDOFResolutions**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    get the dof resolutions\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetDOFResolutions"] = "\n\nvoid  **GetDOFResolutions**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    get the dof resolutions\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody GetLinks"] = "\n\nconst std::vector<  LinkPtr  > &  **GetLinks**\\()\n    \n    Returns all the rigid links of the body.\n    \n            ";
m["en function KinBody GetLinks"] = "\n\nconst std::vector<  LinkPtr  > &  **GetLinks**\\()\n    \n    Returns all the rigid links of the body.\n    \n            ";
m["en function KinBody GetLink"] = "\n\nLinkPtr  **GetLink**\\(const std::string & name)\n    \n    return a pointer to the link with the given name\n    \n            ";
m["en function KinBody GetJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetJoints**\\()\n    \n    Returns the joints making up the controllable degrees of freedom of the body.\n    \n            ";
m["en function KinBody GetJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetJoints**\\()\n    \n    Returns the joints making up the controllable degrees of freedom of the body.\n    \n            ";
m["en function KinBody GetPassiveJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetPassiveJoints**\\()\n    \n    Returns the passive joints, order does not matter.\n    \n    A passive joint is not directly controlled by the body's degrees of freedom so it has no joint index and no dof index. Passive joints allows mimic joints to be hidden from the users. However, there are cases when passive joints are not mimic; for example, suspension mechanism on vehicles.         ";
m["en function KinBody GetDependencyOrderedJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetDependencyOrderedJoints**\\()\n    \n    Returns the joints in hierarchical order starting at the base link.\n    \n    In the case of closed loops, the joints are returned in the order closest to the root. All the joints affecting a particular joint's transformation will always come before the joint in the list.         ";
m["en function KinBody GetClosedLoops"] = "\n\nconst std::vector< std::vector< std::pair<  LinkPtr ,  JointPtr  > > > &  **GetClosedLoops**\\()\n    \n    Return the set of unique closed loops of the kinematics hierarchy.\n    \n    Each loop is a set of link indices and joint indices. For example, a loop of link indices: [l_0,l_1,l_2] will consist of three joints connecting l_0 to l_1, l_1 to l_2, and l_2 to l_0. The first element in the pair is the link l_X, the second element in the joint connecting l_X to l_(X+1).         ";
m["en function KinBody GetRigidlyAttachedLinks"] = "\n\nvoid  **GetRigidlyAttachedLinks**\\(std::vector< boost::shared_ptr<  Link  > > & vattachedlinks)\n    \n    Gets all the rigidly attached links to linkindex, also adds the link to the list.\n    \n    *Parameters*\n     ``vattachedlinks`` - \n      the array to insert all links attached to linkindex with the link itself. \n            ";
m["en function KinBody IsDOFInChain"] = "\n\nbool  **IsDOFInChain**\\(int linkindex1, int linkindex2, int dofindex)\n    \n    Returns true if the dof index affects the relative transformation between the two links.\n    \n    *Parameters*\n     ``linkindex1`` - \n      the link index to start the search \n     ``linkindex2`` - \n      the link index where the search ends The internal implementation uses KinBody::DoesAffect, therefore mimic indices are correctly handled. \n            ";
m["en function KinBody GetJointIndex"] = "\n\nint  **GetJointIndex**\\(const std::string & name)\n    \n    Return the index of the joint with the given name, else -1.\n    \n            ";
m["en function KinBody GetJoint"] = "\n\nJointPtr  **GetJoint**\\(const std::string & name)\n    \n    Return a pointer to the joint with the given name. Search in the regular and passive joints.\n    \n            ";
m["en function KinBody GetJointFromDOFIndex"] = "\n\nJointPtr  **GetJointFromDOFIndex**\\(int dofindex)\n    \n    Returns the joint that covers the degree of freedom index.\n    \n    Note that the mapping of joint structures is not the same as the values in GetJointValues since each joint can have more than one degree of freedom.         ";
m["en function KinBody GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    queries the transfromation of the first link of the body\n    \n            ";
m["en function KinBody GetLinkTransformations"] = "\n\nvoid  **GetLinkTransformations**\\(std::vector<  Transform  > & transforms)\n    \n    get the transformations of all the links at once\n    \n            ";
m["en function KinBody GetLinkTransformations"] = "\n\nvoid  **GetLinkTransformations**\\(std::vector<  Transform  > & transforms)\n    \n    get the transformations of all the links at once\n    \n            ";
m["en function KinBody SetLinkTransformations"] = "\n\nvoid  **SetLinkTransformations**\\(const std::vector<  Transform  > & transforms)\n    \n    sets the transformations of all the links at once\n    \n            ";
m["en function KinBody SetLinkTransformations"] = "\n\nvoid  **SetLinkTransformations**\\(const std::vector<  Transform  > & transforms)\n    \n    sets the transformations of all the links at once\n    \n            ";
m["en function KinBody SetLinkVelocities"] = "\n\nvoid  **SetLinkVelocities**\\(const std::vector< std::pair<  Vector ,  Vector  > > & velocities)\n    \n    sets the link velocities\n    \n            ";
m["en function KinBody SetVelocity \"const Vector; const Vector\""] = "\n\nbool  **SetVelocity**\\(const  Vector  & linearvel, const  Vector  & angularvel)\n    \n    Set the velocity of the base link, rest of links are set to a consistent velocity so entire robot moves correctly.\n    \n    *Parameters*\n     ``linearvel`` - \n      linear velocity \n     ``angularvel`` - \n      is the rotation axis * angular speed \n            ";
m["en function KinBody SetDOFVelocities \"const std::vector; uint32_t\""] = "\n\nvoid  **SetDOFVelocities**\\(const std::vector<  dReal  > & dofvelocities, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the velocity of the joints.\n    \n    *Parameters*\n     ``dofvelocities`` - \n      - velocities of each of the degrees of freeom \n     ``checklimits`` - \n      if >0, will excplicitly check the joint velocity limits before setting the values and clamp them. If == 1, then will warn if the limits are overboard, if == 2, then will not warn (used for code that knows it's giving bad values) Copies the current velocity of the base link and calls SetDOFVelocities(linearvel,angularvel,vDOFVelocities) \n            ";
m["en function KinBody SetDOFVelocities \"const std::vector; const Vector; const Vector; uint32_t\""] = "\n\nvoid  **SetDOFVelocities**\\(const std::vector<  dReal  > & dofvelocities, const  Vector  & linearvel, const  Vector  & angularvel, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the velocity of the base link and each of the joints.\n    \n    *Parameters*\n     ``linearvel`` - \n      linear velocity of base link \n     ``angularvel`` - \n      angular velocity rotation_axis*theta_dot \n     ``dofvelocities`` - \n      - velocities of each of the degrees of freeom \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint velocity limits before setting the values and clamp them. Computes internally what the correponding velocities of each of the links should be in order to achieve consistent results with the joint velocities. Sends the velocities to the physics engine. Velocities correspond to the link's coordinate system origin. \n            ";
m["en function KinBody SetDOFVelocities \"const std::vector; uint32_t\""] = "\n\nvoid  **SetDOFVelocities**\\(const std::vector<  dReal  > & dofvelocities, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the velocity of the joints.\n    \n    *Parameters*\n     ``dofvelocities`` - \n      - velocities of each of the degrees of freeom \n     ``checklimits`` - \n      if >0, will excplicitly check the joint velocity limits before setting the values and clamp them. If == 1, then will warn if the limits are overboard, if == 2, then will not warn (used for code that knows it's giving bad values) Copies the current velocity of the base link and calls SetDOFVelocities(linearvel,angularvel,vDOFVelocities) \n            ";
m["en function KinBody SetDOFVelocities \"const std::vector; const Vector; const Vector; uint32_t\""] = "\n\nvoid  **SetDOFVelocities**\\(const std::vector<  dReal  > & dofvelocities, const  Vector  & linearvel, const  Vector  & angularvel, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the velocity of the base link and each of the joints.\n    \n    *Parameters*\n     ``linearvel`` - \n      linear velocity of base link \n     ``angularvel`` - \n      angular velocity rotation_axis*theta_dot \n     ``dofvelocities`` - \n      - velocities of each of the degrees of freeom \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint velocity limits before setting the values and clamp them. Computes internally what the correponding velocities of each of the links should be in order to achieve consistent results with the joint velocities. Sends the velocities to the physics engine. Velocities correspond to the link's coordinate system origin. \n            ";
m["en function KinBody GetLinkVelocities"] = "\n\nvoid  **GetLinkVelocities**\\(std::vector< std::pair<  Vector ,  Vector  > > & velocities)\n    \n    Returns the linear and angular velocities for each link.\n    \n    *Parameters*\n     ``velocities`` - \n      The velocities of the link frames with respect to the world coordinate system are returned. \n            ";
m["en function KinBody GetLinkAccelerations"] = "\n\nvoid  **GetLinkAccelerations**\\(const std::vector<  dReal  > & dofaccelerations, std::vector< std::pair<  Vector ,  Vector  > > & linkaccelerations)\n    \n    Returns the linear and angular accelerations for each link given the dof accelerations.\n    \n    *Parameters*\n     ``dofaccelerations`` - \n      the accelerations of each of the DOF \n     ``linkaccelerations`` - \n      the linear and angular accelerations of link (in that order) Computes accelerations of the link frames with respect to the world coordinate system are returned. The base angular velocity is used when computing accelerations. The gravity vector from the physics engine is used as the accelerations for the base link and static links. The derivate is taken with respect to the world origin fixed in space (also known as spatial acceleration). The current angles and velocities set on the robot are used. Note that this function calls the internal _ComputeLinkAccelerations function, so for users that are interested in overriding it, override _ComputeLinkAccelerations \n            ";
m["en function KinBody ComputeAABB"] = "\n\nAABB  **ComputeAABB**\\()\n    \n    Return an axis-aligned bounding box of the entire object in the world coordinate system.\n    \n            ";
m["en function KinBody Enable"] = "\n\nvoid  **Enable**\\(bool enable)\n    \n    Enables or disables all the links.\n    \n            ";
m["en function KinBody IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    *Return*\n        true if any link of the KinBody is enabled \n        ";
m["en function KinBody SetVisible"] = "\n\nbool  **SetVisible**\\(bool visible)\n    \n    Sets all the links as visible or not visible.\n    \n    *Return*\n        true if changed \n        ";
m["en function KinBody IsVisible"] = "\n\nbool  **IsVisible**\\()\n    \n    *Return*\n        true if any link of the KinBody is visible. \n        ";
m["en function KinBody SetTransform"] = "\n\nvoid  **SetTransform**\\(const  Transform  & transform)\n    \n    set the transform of the first link (the rest of the links are computed based on the joint values).\n    \n    *Parameters*\n     ``transform`` - \n      affine transformation \n            ";
m["en function KinBody SetDOFValues \"const std::vector; uint32_t; const std::vector\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = CLA_CheckLimits , const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody SetDOFValues \"const std::vector; uint32_t; const std::vector\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = CLA_CheckLimits , const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody SetDOFValues \"const std::vector; uint32_t; const std::vector\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = CLA_CheckLimits , const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody SetDOFValues \"const std::vector; uint32_t; const std::vector\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = CLA_CheckLimits , const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody SetDOFValues \"const std::vector; uint32_t; const std::vector\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = CLA_CheckLimits , const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["en function KinBody SubtractDOFValues"] = "\n\nvoid  **SubtractDOFValues**\\(std::vector<  dReal  > & values1, const std::vector<  dReal  > & values2, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Computes the configuration difference values1-values2 and stores it in values1.\n    \n    *Parameters*\n     ``inout]`` - \n      values1 the result is stored back in this \n     ``values2`` -\n      \n     ``dofindices`` - \n      the dof indices to compute the subtraction for. If empty, will compute for all the dofs Takes into account joint limits and wrapping of circular joints. \n            ";
m["en function KinBody SetDOFTorques"] = "\n\nvoid  **SetDOFTorques**\\(const std::vector<  dReal  > & torques, bool add)\n    \n    Adds a torque to every joint.\n    \n    *Parameters*\n     ``bAdd`` - \n      if true, adds to previous torques, otherwise resets the torques on all bodies and starts from 0 \n            ";
m["en function KinBody SetDOFTorques"] = "\n\nvoid  **SetDOFTorques**\\(const std::vector<  dReal  > & torques, bool add)\n    \n    Adds a torque to every joint.\n    \n    *Parameters*\n     ``bAdd`` - \n      if true, adds to previous torques, otherwise resets the torques on all bodies and starts from 0 \n            ";
m["en function KinBody SetDOFValues \"const std::vector; const Transform; uint32_t\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, const  Transform  & transform, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the joint values and transformation of the body.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``transform`` - \n      represents the transformation of the first body. \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n            ";
m["en function KinBody SetDOFValues \"const std::vector; const Transform; uint32_t\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, const  Transform  & transform, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the joint values and transformation of the body.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``transform`` - \n      represents the transformation of the first body. \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n            ";
m["en function KinBody ComputeJacobianTranslation"] = "\n\nvoid  **ComputeJacobianTranslation**\\(int linkindex, const  Vector  & position, std::vector<  dReal  > & jacobian, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Computes the translation jacobian with respect to a world position.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that defines the frame the position is attached to \n     ``position`` - \n      position in world space where to compute derivatives from. \n     ``jacobian`` - \n      3xDOF matrix \n     ``dofindices`` - \n      the dof indices to compute the jacobian for. If empty, will compute for all the dofs Gets the jacobian with respect to a link by computing the partial differentials for all joints that in the path from the root node to GetLinks()[index] (doesn't touch the rest of the values) \n            ";
m["en function KinBody ComputeJacobianAxisAngle"] = "\n\nvoid  **ComputeJacobianAxisAngle**\\(int linkindex, std::vector<  dReal  > & jacobian, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Computes the angular velocity jacobian of a specified link about the axes of world coordinates.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that the rotation is attached to \n     ``vjacobian`` - \n      3xDOF matrix \n            ";
m["en function KinBody CalculateJacobian \"int; const Vector; std::vector\""] = "\n\nvoid  **CalculateJacobian**\\(int linkindex, const  Vector  & position, std::vector<  dReal  > & jacobian)\n    \n    calls std::vector version of ComputeJacobian internally\n    \n            ";
m["en function KinBody CalculateRotationJacobian \"int; const Vector; std::vector\""] = "\n\nvoid  **CalculateRotationJacobian**\\(int linkindex, const  Vector  & quat, std::vector<  dReal  > & jacobian)\n    \n    Computes the rotational jacobian as a quaternion with respect to an initial rotation.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that the rotation is attached to \n     ``qInitialRot`` - \n      the rotation in world space whose derivative to take from. \n     ``jacobian`` - \n      4xDOF matrix \n            ";
m["en function KinBody CalculateAngularVelocityJacobian \"int; std::vector\""] = "\n\nvoid  **CalculateAngularVelocityJacobian**\\(int linkindex, std::vector<  dReal  > & jacobian)\n    \n    Computes the angular velocity jacobian of a specified link about the axes of world coordinates.\n    \n            ";
m["en function KinBody ComputeHessianTranslation"] = "\n\nvoid  **ComputeHessianTranslation**\\(int linkindex, const  Vector  & position, std::vector<  dReal  > & hessian, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Computes the DOFx3xDOF hessian of the linear translation.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that defines the frame the position is attached to / \n     ``position`` - \n      position in world space where to compute derivatives from. / \n     ``hessian`` - \n      DOFx3xDOF matrix such that numpy.dot(dq,numpy.dot(hessian,dq)) is the expected second-order delta translation / \n     ``dofindices`` - \n      the dof indices to compute the hessian for. If empty, will compute for all the dofs / \n            ";
m["en function KinBody ComputeHessianAxisAngle"] = "\n\nvoid  **ComputeHessianAxisAngle**\\(int linkindex, std::vector<  dReal  > & hessian, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Computes the DOFx3xDOF hessian of the rotation represented as angle-axis.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that defines the frame the position is attached to / \n     ``hessian`` - \n      DOFx3xDOF matrix such that numpy.dot(dq,numpy.dot(hessian,dq)) is the expected second-order delta angle-axis / \n     ``dofindices`` - \n      the dof indices to compute the hessian for. If empty, will compute for all the dofs / \n            ";
m["en function KinBody CheckSelfCollision"] = "\n\nbool  **CheckSelfCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    Check if body is self colliding. Links that are joined together are ignored.\n    \n            ";
m["en function KinBody CheckSelfCollision"] = "\n\nbool  **CheckSelfCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    Check if body is self colliding. Links that are joined together are ignored.\n    \n            ";
m["en function KinBody IsAttached"] = "\n\nbool  **IsAttached**\\(KinBodyConstPtr body)\n    \n    *Return*\n        true if two bodies should be considered as one during collision (ie one is grabbing the other) \n        ";
m["en function KinBody GetAttached"] = "\n\nvoid  **GetAttached**\\(std::set<  KinBodyPtr  > & setAttached)\n    \n    Recursively get all attached bodies of this body, including this body.\n    \n    *Parameters*\n     ``setAttached`` - \n      fills with the attached bodies. If any bodies are already in setAttached, then ignores recursing on their attached bodies. \n            ";
m["en function KinBody SetZeroConfiguration"] = "\n\nvoid  **SetZeroConfiguration**\\()\n    \n    Sets the joint offsets so that the current configuration becomes the new zero state of the robot.\n    \n    When this function returns, the returned DOF values should be all zero for controllable joints. Mimic equations will use the new offsetted values when computing their joints. This is primarily used for calibrating a robot's zero position         ";
m["en function KinBody SetNonCollidingConfiguration"] = "\n\nvoid  **SetNonCollidingConfiguration**\\()\n    \n    Treats the current pose as a pose not in collision, which sets the adjacent pairs of links.\n    \n            ";
m["en function KinBody GetConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n    return the configuration specification of the joint values and transform\n    \n    Note that the return type is by-value, so should not be used in iteration         ";
m["en function KinBody GetConfigurationSpecificationIndices"] = "\n\nConfigurationSpecification  **GetConfigurationSpecificationIndices**\\(const std::vector< int > & indices, const std::string & interpolation = \"\" )\n    \n    return the configuration specification of the specified joint indices.\n    \n    Note that the return type is by-value, so should not be used in iteration         ";
m["en function KinBody SetConfigurationValues"] = "\n\nvoid  **SetConfigurationValues**\\(std::vector<  dReal  >::const_iterator itvalues, uint32_t checklimits = CLA_CheckLimits )\n    \n    sets joint values and transform of the body using configuration values as specified by GetConfigurationSpecification()\n    \n    *Parameters*\n     ``itvalues`` - \n      the iterator to the vector containing the dof values. Must have GetConfigurationSpecification().GetDOF() values! \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n            ";
m["en function KinBody GetConfigurationValues"] = "\n\nvoid  **GetConfigurationValues**\\(std::vector<  dReal  > & v)\n    \n    returns the configuration values as specified by GetConfigurationSpecification()\n    \n            ";
m["en function KinBody IsRobot"] = "\n\nbool  **IsRobot**\\()\n    \n    Return true if this body is derived from RobotBase.\n    \n            ";
m["en function KinBody GetEnvironmentId"] = "\n\nint  **GetEnvironmentId**\\()\n    \n    return a unique id of the body used in the environment.\n    \n    If object is not added to the environment, this will return 0. So checking if GetEnvironmentId() is 0 is a good way to check if object is present in the environment. This id will not be copied when cloning in order to respect another environment's ids.         ";
m["en function KinBody DoesAffect"] = "\n\nint8_t  **DoesAffect**\\(int jointindex, int linkindex)\n    \n    Returns a nonzero value if the joint effects the link transformation.\n    \n    *Parameters*\n     ``jointindex`` - \n      index of the joint \n     ``linkindex`` - \n      index of the link In closed loops, all joints on all paths to the root link are counted as affecting the link. If a mimic joint affects the link, then all the joints used in the mimic joint's computation affect the link. If negative, the partial derivative of the Jacobian should be negated. \n            ";
m["en function KinBody GetViewerData"] = "\n\nUserDataPtr  **GetViewerData**\\()\n    \n    *See*\n        SetViewerData \n        ";
m["en function KinBody GetViewerData"] = "\n\nUserDataPtr  **GetViewerData**\\()\n    \n    *See*\n        SetViewerData \n        ";
m["en function InterfaceBase GetURI"] = "\n\nconst std::string &  **GetURI**\\()\n    \n    the URI used to load the interface (sometimes this is not possible if the definition lies inside an environment file).\n    \n            ";
m["en function InterfaceBase GetURI"] = "\n\nconst std::string &  **GetURI**\\()\n    \n    the URI used to load the interface (sometimes this is not possible if the definition lies inside an environment file).\n    \n            ";
m["en function KinBody GetNonAdjacentLinks"] = "\n\nconst std::set< int > &  **GetNonAdjacentLinks**\\(int adjacentoptions = 0 )\n    \n    return all possible link pairs that could get in collision.\n    \n    *Parameters*\n     ``adjacentoptions`` - \n      a bitmask of AdjacentOptions values \n            ";
m["en function KinBody GetNonAdjacentLinks"] = "\n\nconst std::set< int > &  **GetNonAdjacentLinks**\\(int adjacentoptions = 0 )\n    \n    return all possible link pairs that could get in collision.\n    \n    *Parameters*\n     ``adjacentoptions`` - \n      a bitmask of AdjacentOptions values \n            ";
m["en function KinBody GetAdjacentLinks"] = "\n\nconst std::set< int > &  **GetAdjacentLinks**\\()\n    \n    return all possible link pairs whose collisions are ignored.\n    \n            ";
m["en function KinBody GetPhysicsData"] = "\n\nUserDataPtr  **GetPhysicsData**\\()\n    \n    *See*\n        SetPhysicsData \n        ";
m["en function KinBody GetCollisionData"] = "\n\nUserDataPtr  **GetCollisionData**\\()\n    \n    SetCollisionData.\n    \n            ";
m["en function KinBody GetManageData"] = "\n\nManageDataPtr  **GetManageData**\\()\n    \n            ";
m["en function KinBody GetUpdateStamp"] = "\n\nint  **GetUpdateStamp**\\()\n    \n    Return a unique id for every transformation state change of any link. Used to check if robot state has changed.\n    \n    The stamp is used by the collision checkers, physics engines, or any other item that needs to keep track of any changes of the KinBody as it moves. Currently stamps monotonically increment for every transformation/joint angle change.         ";
m["en function KinBody serialize"] = "\n\nvoid  **serialize**\\(std::ostream & o, int options)\n    \n    only used for hashes...\n    \n            ";
m["en function KinBody GetKinematicsGeometryHash"] = "\n\nconst std::string &  **GetKinematicsGeometryHash**\\()\n    \n    A md5 hash unique to the particular kinematic and geometric structure of a KinBody.\n    \n    This 32 byte string can be used to check if two bodies have the same kinematic structure and can be used to index into tables when looking for body-specific models. OpenRAVE stores all such models in the OPENRAVE_HOME directory (usually ~/.openrave), indexed by the particular robot/body hashes.\n    \n    *Return*\n        md5 hash string of kinematics/geometry \n        ";
m["en function KinBody::Link GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["en function KinBody::Link GetIndex"] = "\n\nint  **GetIndex**\\()\n    \n    unique index into parent KinBody::GetLinks vector\n    \n            ";
m["en function KinBody::Link Enable"] = "\n\nvoid  **Enable**\\(bool enable)\n    \n    Enables a Link. An enabled link takes part in collision detection and physics simulations.\n    \n            ";
m["en function KinBody::Link IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    returns true if the link is enabled.\n    \n    *See*\n        Enable \n        ";
m["en function KinBody::Link IsStatic"] = "\n\nbool  **IsStatic**\\()\n    \n    Indicates a static body that does not move with respect to the root link.\n    \n    Static should be used when an object has infinite mass and shouldn't be affected by physics (including gravity). Collision still works.         ";
m["en function KinBody::Link SetVisible"] = "\n\nbool  **SetVisible**\\(bool visible)\n    \n    Sets all the geometries of the link as visible or non visible.\n    \n    *Return*\n        true if changed \n        ";
m["en function KinBody::Link IsVisible"] = "\n\nbool  **IsVisible**\\()\n    \n    *Return*\n        true if any geometry of the link is visible. \n        ";
m["en function KinBody::Link GetParent"] = "\n\nKinBodyPtr  **GetParent**\\()\n    \n    parent body that link belong to.\n    \n            ";
m["en function KinBody::Link GetParentLinks"] = "\n\nvoid  **GetParentLinks**\\(std::vector< boost::shared_ptr<  Link  > > & vParentLinks)\n    \n    Return all the direct parent links in the kinematics hierarchy of this link.\n    \n    *Parameters*\n     ``filled`` - \n      with the parent links A parent link is is immediately connected to this link by a joint and has a path to the root joint so that it is possible to compute this link's transformation from its parent. \n            ";
m["en function KinBody::Link IsParentLink"] = "\n\nbool  **IsParentLink**\\(boost::shared_ptr<  Link  const  > plink)\n    \n    Tests if a link is a direct parent.\n    \n    *Parameters*\n     ``link`` - \n      The link to test if it is one of the parents of this link.\n    \n    *See*\n        GetParentLinks \n        ";
m["en function KinBody::Link GetCollisionData"] = "\n\nconst  TRIMESH  &  **GetCollisionData**\\()\n    \n            ";
m["en function KinBody::Link ComputeAABB"] = "\n\nAABB  **ComputeAABB**\\()\n    \n    Compute the aabb of all the geometries of the link in the world coordinate system.\n    \n            ";
m["en function KinBody::Link GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    Return the current transformation of the link in the world coordinate system.\n    \n            ";
m["en function KinBody::Link GetCOMOffset"] = "\n\nVector  **GetCOMOffset**\\()\n    \n            ";
m["en function KinBody::Link GetLocalCOM"] = "\n\nVector  **GetLocalCOM**\\()\n    \n    return center of mass offset in the link's local coordinate frame\n    \n            ";
m["en function KinBody::Link GetGlobalCOM"] = "\n\nVector  **GetGlobalCOM**\\()\n    \n    return center of mass of the link in the global coordinate system\n    \n            ";
m["en function KinBody::Link GetLocalInertia"] = "\n\nTransformMatrix  **GetLocalInertia**\\()\n    \n    return inertia in link's local coordinate frame. The translation component is the the COM in the link's frame.\n    \n            ";
m["en function KinBody::Link GetPrincipalMomentsOfInertia"] = "\n\nconst  Vector  &  **GetPrincipalMomentsOfInertia**\\()\n    \n    return the principal moments of inertia inside the mass frame\n    \n            ";
m["en function KinBody::Link GetLocalMassFrame"] = "\n\nconst  Transform  &  **GetLocalMassFrame**\\()\n    \n    return the mass frame in the link's local coordinate system that holds the center of mass and principal axes for inertia.\n    \n            ";
m["en function KinBody::Link GetGlobalMassFrame"] = "\n\nTransform  **GetGlobalMassFrame**\\()\n    \n    return the mass frame in the global coordinate system that holds the center of mass and principal axes for inertia.\n    \n            ";
m["en function KinBody::Link GetMass"] = "\n\ndReal  **GetMass**\\()\n    \n            ";
m["en function KinBody::Link SetLocalMassFrame"] = "\n\nvoid  **SetLocalMassFrame**\\(const  Transform  & massframe)\n    \n    sets a new mass frame with respect to the link coordinate system\n    \n            ";
m["en function KinBody::Link SetPrincipalMomentsOfInertia"] = "\n\nvoid  **SetPrincipalMomentsOfInertia**\\(const  Vector  & inertiamoments)\n    \n    sets new principal moments of inertia (with respect to the mass frame)\n    \n            ";
m["en function KinBody::Link SetMass"] = "\n\nvoid  **SetMass**\\(dReal mass)\n    \n    set a new mass\n    \n            ";
m["en function KinBody::Link SetStatic"] = "\n\nvoid  **SetStatic**\\(bool bStatic)\n    \n    sets a link to be static.\n    \n    Because this can affect the kinematics, it requires the body's internal structures to be recomputed         ";
m["en function KinBody::Link SetTransform"] = "\n\nvoid  **SetTransform**\\(const  Transform  & transform)\n    \n    Sets the transform of the link regardless of kinematics.\n    \n    *Parameters*\n     ``t`` - \n      the new transformation \n            ";
m["en function KinBody::Link SetForce"] = "\n\nvoid  **SetForce**\\(const  Vector  & force, const  Vector  & pos, bool add)\n    \n    *Parameters*\n     ``force`` - \n      the direction and magnitude of the force \n     ``pos`` - \n      in the world where the force is getting applied \n     ``add`` - \n      if true, force is added to previous forces, otherwise it is set adds an external force at pos (absolute coords) \n            ";
m["en function KinBody::Link SetTorque"] = "\n\nvoid  **SetTorque**\\(const  Vector  & torque, bool add)\n    \n    *Parameters*\n     ``add`` - \n      if true, torque is added to previous torques, otherwise it is set adds torque to a body (absolute coords) \n            ";
m["en function KinBody::Link GetGeometries"] = "\n\nconst std::vector<  GeometryPtr  > &  **GetGeometries**\\()\n    \n    returns a list of all the geometry objects.\n    \n            ";
m["en function KinBody::Link GetRigidlyAttachedLinks"] = "\n\nvoid  **GetRigidlyAttachedLinks**\\(std::vector< boost::shared_ptr<  Link  > > & vattachedlinks)\n    \n    Gets all the rigidly attached links to linkindex, also adds the link to the list.\n    \n    *Parameters*\n     ``vattachedlinks`` - \n      the array to insert all links attached to linkindex with the link itself. \n            ";
m["en function KinBody::Link IsRigidlyAttached"] = "\n\nbool  **IsRigidlyAttached**\\(boost::shared_ptr<  Link  const  > plink)\n    \n    returns true if plink is rigidily attahced to this link.\n    \n            ";
m["en function KinBody::Link GetVelocity"] = "\n\nvoid  **GetVelocity**\\(Vector  & linearvel, Vector  & angularvel)\n    \n    get the velocity of the link\n    \n    *Parameters*\n     ``linearvel`` - \n      the translational velocity \n     ``angularvel`` - \n      is the rotation axis * angular speed \n            ";
m["en function KinBody::Link SetVelocity"] = "\n\nvoid  **SetVelocity**\\(const  Vector  & linearvel, const  Vector  & angularvel)\n    \n    *Parameters*\n     ``linearvel`` - \n      the translational velocity \n     ``angularvel`` - \n      is the rotation axis * angular speed forces the velocity of the link \n            ";
m["en function KinBody::Link::Geometry SetCollisionMesh"] = "\n\nvoid  **SetCollisionMesh**\\(const  TRIMESH  & mesh)\n    \n    sets a new collision mesh and notifies every registered callback about it\n    \n            ";
m["en function KinBody::Link::Geometry GetCollisionMesh"] = "\n\nconst  TRIMESH  &  **GetCollisionMesh**\\()\n    \n    returns the local collision mesh\n    \n            ";
m["en function KinBody::Link::Geometry ComputeAABB"] = "\n\nAABB  **ComputeAABB**\\(const  Transform  & trans)\n    \n    returns an axis aligned bounding box given that the geometry is transformed by trans\n    \n            ";
m["en function KinBody::Link::Geometry SetDraw"] = "\n\nvoid  **SetDraw**\\(bool bDraw)\n    \n            ";
m["en function KinBody::Link::Geometry SetTransparency"] = "\n\nvoid  **SetTransparency**\\(float f)\n    \n    set transparency level (0 is opaque)\n    \n            ";
m["en function KinBody::Link::Geometry SetDiffuseColor"] = "\n\nvoid  **SetDiffuseColor**\\(const RaveVector< float > & color)\n    \n    override diffuse color of geometry material\n    \n            ";
m["en function KinBody::Link::Geometry SetAmbientColor"] = "\n\nvoid  **SetAmbientColor**\\(const RaveVector< float > & color)\n    \n    override ambient color of geometry material\n    \n            ";
m["en function KinBody::Link::Geometry SetRenderFilename"] = "\n\nvoid  **SetRenderFilename**\\(const std::string & renderfilename)\n    \n    sets a new render filename for the geometry. This does not change the collision\n    \n            ";
m["en function KinBody::Link::Geometry IsDraw"] = "\n\nbool  **IsDraw**\\()\n    \n            ";
m["en function KinBody::Link::Geometry IsVisible"] = "\n\nbool  **IsVisible**\\()\n    \n            ";
m["en function KinBody::Link::Geometry IsModifiable"] = "\n\nbool  **IsModifiable**\\()\n    \n            ";
m["en function KinBody::Link::Geometry GetType"] = "\n\nGeomType  **GetType**\\()\n    \n            ";
m["en function KinBody::Link::Geometry GetTransform"] = "\n\nconst  Transform  &  **GetTransform**\\()\n    \n    get local geometry transform\n    \n            ";
m["en function KinBody::Link::Geometry GetSphereRadius"] = "\n\ndReal  **GetSphereRadius**\\()\n    \n            ";
m["en function KinBody::Link::Geometry GetCylinderRadius"] = "\n\ndReal  **GetCylinderRadius**\\()\n    \n            ";
m["en function KinBody::Link::Geometry GetCylinderHeight"] = "\n\ndReal  **GetCylinderHeight**\\()\n    \n            ";
m["en function KinBody::Link::Geometry GetBoxExtents"] = "\n\nconst  Vector  &  **GetBoxExtents**\\()\n    \n            ";
m["en function KinBody::Link::Geometry GetRenderScale"] = "\n\nconst  Vector  &  **GetRenderScale**\\()\n    \n            ";
m["en function KinBody::Link::Geometry GetRenderFilename"] = "\n\nconst std::string &  **GetRenderFilename**\\()\n    \n            ";
m["en function KinBody::Link::Geometry GetTransparency"] = "\n\nfloat  **GetTransparency**\\()\n    \n            ";
m["en function KinBody::Link::Geometry GetDiffuseColor"] = "\n\nconst RaveVector< float > &  **GetDiffuseColor**\\()\n    \n            ";
m["en function KinBody::Link::Geometry GetAmbientColor"] = "\n\nconst RaveVector< float > &  **GetAmbientColor**\\()\n    \n            ";
m["en function KinBody::Joint GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n    The unique name of the joint.\n    \n            ";
m["en function KinBody::Joint IsMimic"] = "\n\nbool  **IsMimic**\\(int axis = -1 )\n    \n    Returns true if a particular axis of the joint is mimiced.\n    \n    *Parameters*\n     ``axis`` - \n      the axis to query. When -1 returns true if any of the axes have mimic joints \n            ";
m["en function KinBody::Joint GetMimicEquation"] = "\n\nstd::string  **GetMimicEquation**\\(int axis = 0 , int type = 0 , const std::string & format = \"\" )\n    \n    If the joint is mimic, returns the equation to compute its value.\n    \n    *Parameters*\n     ``axis`` - \n      the axis index \n     ``type`` - \n      0 for position, 1 for velocity, 2 for acceleration. \n     ``format`` - \n      the format the equations are returned in. If empty or \"fparser\", equation in fparser format. Also supports: \"mathml\".\n    MathML:Set 'format' to \"mathml\". The joint variables are specified with <csymbol>. If a targetted joint has more than one degree of freedom, then axis is suffixed with _%d. If 'type' is 1 or 2, the partial derivatives are outputted as consecutive <math></math> tags in the same order as MIMIC::_vdofformat         ";
m["en function KinBody::Joint GetMimicDOFIndices"] = "\n\nvoid  **GetMimicDOFIndices**\\(std::vector< int > & vmimicdofs, int axis = 0 )\n    \n    Returns the set of DOF indices that the computation of a joint axis depends on. Order is arbitrary.\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      Throws an exception if the axis is not mimic. If the mimic joint uses the values of other mimic joints, then the dependent DOFs of that joint are also copied over. Therefore, the dof indices returned can be more than the actual variables used in the equation. \n            ";
m["en function KinBody::Joint SetMimicEquations"] = "\n\nvoid  **SetMimicEquations**\\(int axis, const std::string & poseq, const std::string & veleq, const std::string & acceleq = \"\" )\n    \n    Sets the mimic properties of the joint.\n    \n    The equations can use the joint names directly in the equation, which represent the position of the joint. Any non-mimic joint part of KinBody::GetJoints() can be used in the computation of the values. If a joint has more than one degree of freedom, then suffix it '_' and the axis index. For example universaljoint_0 * 10 + sin(universaljoint_1).See  for a full description of the equation formats.The velocity and acceleration equations are specified in terms of partial derivatives, which means one expression needs to be specified per degree of freedom of used. In order to separate the expressions use \"|name ...\". The name should immediately follow '|'. For example:|universaljoint_0 10 |universaljoint_1 10*cos(universaljoint_1)If there is only one variable used in the position equation, then the equation can be specified directly without using \"{}\".\\ *Parameters*\n     ``axis`` - \n      the axis to set the properties for. \n     ``poseq`` - \n      Equation for joint's position. If it is empty, the mimic properties are turned off for this joint. \n     ``veleq`` - \n      First-order partial derivatives of poseq with respect to all used DOFs. Only the variables used in poseq are allowed to be used. If poseq is not empty, this is required. \n     ``acceleq`` - \n      Second-order partial derivatives of poseq with respect to all used DOFs. Only the variables used in poseq are allowed to be used. Optional. \\ *Exceptions*\n     ``openrave_exception`` - \n      Throws an exception if the mimic equation is invalid in any way.\n    \n            ";
m["en function KinBody::Joint GetMaxVel"] = "\n\ndReal  **GetMaxVel**\\(int iaxis = 0 )\n    \n            ";
m["en function KinBody::Joint GetMaxAccel"] = "\n\ndReal  **GetMaxAccel**\\(int iaxis = 0 )\n    \n            ";
m["en function KinBody::Joint GetMaxTorque"] = "\n\ndReal  **GetMaxTorque**\\(int iaxis = 0 )\n    \n            ";
m["en function KinBody::Joint GetDOFIndex"] = "\n\nint  **GetDOFIndex**\\()\n    \n    Get the degree of freedom index in the body's DOF array.\n    \n    This does not index in KinBody::GetJoints() directly! In other words, KinBody::GetDOFValues()[GetDOFIndex()] == GetValues()[0]         ";
m["en function KinBody::Joint GetJointIndex"] = "\n\nint  **GetJointIndex**\\()\n    \n    Get the joint index into KinBody::GetJoints.\n    \n            ";
m["en function KinBody::Joint GetParent"] = "\n\nKinBodyPtr  **GetParent**\\()\n    \n            ";
m["en function KinBody::Joint GetFirstAttached"] = "\n\nLinkPtr  **GetFirstAttached**\\()\n    \n            ";
m["en function KinBody::Joint GetSecondAttached"] = "\n\nLinkPtr  **GetSecondAttached**\\()\n    \n            ";
m["en function KinBody::Joint IsStatic"] = "\n\nbool  **IsStatic**\\()\n    \n    Return true if joint can be treated as a static binding (ie all limits are 0)\n    \n            ";
m["en function KinBody::Joint IsCircular"] = "\n\nbool  **IsCircular**\\(int iaxis)\n    \n    Return true if joint axis has an identification at some of its lower and upper limits.\n    \n    An identification of the lower and upper limits means that once the joint reaches its upper limits, it is also at its lower limit. The most common identification on revolute joints at -pi and pi. 'circularity' means the joint does not stop at limits. Although currently not developed, it could be possible to support identification for joints that are not revolute.         ";
m["en function KinBody::Joint IsRevolute"] = "\n\nbool  **IsRevolute**\\(int iaxis)\n    \n    returns true if the axis describes a rotation around an axis.\n    \n    *Parameters*\n     ``iaxis`` - \n      the axis of the joint to return the results for \n            ";
m["en function KinBody::Joint IsPrismatic"] = "\n\nbool  **IsPrismatic**\\(int iaxis)\n    \n    returns true if the axis describes a translation around an axis.\n    \n    *Parameters*\n     ``iaxis`` - \n      the axis of the joint to return the results for \n            ";
m["en function KinBody::Joint GetType"] = "\n\nJointType  **GetType**\\()\n    \n            ";
m["en function KinBody::Joint GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    The degrees of freedom of the joint. Each joint supports a max of 3 degrees of freedom.\n    \n            ";
m["en function KinBody::Joint GetValues"] = "\n\nvoid  **GetValues**\\(std::vector<  dReal  > & values, bool bAppend = false )\n    \n    Return all the joint values with the correct offsets applied.\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it\n    \n    *Return*\n        degrees of freedom of the joint (even if pValues is NULL) \n        ";
m["en function KinBody::Joint GetVelocities"] = "\n\nvoid  **GetVelocities**\\(std::vector<  dReal  > & values, bool bAppend = false )\n    \n    Gets the joint velocities.\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it\n    \n    *Return*\n        the degrees of freedom of the joint (even if pValues is NULL) \n        ";
m["en function KinBody::Joint GetAnchor"] = "\n\nVector  **GetAnchor**\\()\n    \n    The anchor of the joint in global coordinates.\n    \n            ";
m["en function KinBody::Joint GetAxis"] = "\n\nVector  **GetAxis**\\(int axis = 0 )\n    \n    The axis of the joint in global coordinates.\n    \n    *Parameters*\n     ``axis`` - \n      the axis to get \n            ";
m["en function KinBody::Joint GetHierarchyParentLink"] = "\n\nLinkPtr  **GetHierarchyParentLink**\\()\n    \n    Return the parent link which the joint measures its angle off from (either GetFirstAttached() or GetSecondAttached())\n    \n            ";
m["en function KinBody::Joint GetHierarchyChildLink"] = "\n\nLinkPtr  **GetHierarchyChildLink**\\()\n    \n    Return the child link whose transformation is computed by this joint's values (either GetFirstAttached() or GetSecondAttached())\n    \n            ";
m["en function KinBody::Joint GetInternalHierarchyAxis"] = "\n\nVector  **GetInternalHierarchyAxis**\\(int axis = 0 )\n    \n    The axis of the joint in local coordinates.\n    \n            ";
m["en function KinBody::Joint GetInternalHierarchyLeftTransform"] = "\n\nTransform  **GetInternalHierarchyLeftTransform**\\()\n    \n    Left multiply transform given the base body.\n    \n            ";
m["en function KinBody::Joint GetInternalHierarchyRightTransform"] = "\n\nTransform  **GetInternalHierarchyRightTransform**\\()\n    \n    Right multiply transform given the base body.\n    \n            ";
m["en function KinBody::Joint GetLimits"] = "\n\nvoid  **GetLimits**\\(std::vector<  dReal  > & vLowerLimit, std::vector<  dReal  > & vUpperLimit, bool bAppend = false )\n    \n    Get the limits of the joint.\n    \n    *Parameters*\n     ``vLowerLimit`` - \n      the lower limits \n     ``vUpperLimit`` - \n      the upper limits \n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["en function KinBody::Joint GetVelocityLimits"] = "\n\nvoid  **GetVelocityLimits**\\(std::vector<  dReal  > & vmax, bool bAppend = false )\n    \n    Returns the max velocities of the joint.\n    \n    *Parameters*\n     ``the`` - \n      max velocity \n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["en function KinBody::Joint GetAccelerationLimits"] = "\n\nvoid  **GetAccelerationLimits**\\(std::vector<  dReal  > & vmax, bool bAppend = false )\n    \n    Returns the max accelerations of the joint.\n    \n    *Parameters*\n     ``the`` - \n      max acceleration \n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["en function KinBody::Joint GetTorqueLimits"] = "\n\nvoid  **GetTorqueLimits**\\(std::vector<  dReal  > & vmax, bool bAppend = false )\n    \n    Returns the max torques of the joint.\n    \n    *Parameters*\n     ``the`` - \n      max torque \n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["en function KinBody::Joint SetWrapOffset"] = "\n\nvoid  **SetWrapOffset**\\(dReal offset, int iaxis = 0 )\n    \n    *See*\n        GetWrapOffset \n        ";
m["en function KinBody::Joint GetWrapOffset"] = "\n\ndReal  **GetWrapOffset**\\(int iaxis = 0 )\n    \n    Return internal offset parameter that determines the branch the angle centers on.\n    \n    *Parameters*\n     ``iaxis`` - \n      the axis to get the offset from Wrap offsets are needed for rotation joints since the range is limited to 2*pi. This allows the wrap offset to be set so the joint can function in [-pi+offset,pi+offset].. \n            ";
m["en function KinBody::Joint SetLimits"] = "\n\nvoid  **SetLimits**\\(const std::vector<  dReal  > & lower, const std::vector<  dReal  > & upper)\n    \n    *See*\n        GetLimits \n        ";
m["en function KinBody::Joint SetVelocityLimits"] = "\n\nvoid  **SetVelocityLimits**\\(const std::vector<  dReal  > & vmax)\n    \n    *See*\n        GetVelocityLimits \n        ";
m["en function KinBody::Joint SetAccelerationLimits"] = "\n\nvoid  **SetAccelerationLimits**\\(const std::vector<  dReal  > & vmax)\n    \n    *See*\n        GetAccelerationLimits \n        ";
m["en function KinBody::Joint SetTorqueLimits"] = "\n\nvoid  **SetTorqueLimits**\\(const std::vector<  dReal  > & vmax)\n    \n    *See*\n        GetTorqueLimits \n        ";
m["en function KinBody::Joint GetResolution"] = "\n\ndReal  **GetResolution**\\(int iaxis = 0 )\n    \n    The discretization of the joint used when line-collision checking.\n    \n    The resolutions are set as large as possible such that the joint will not go through obstacles of determined size.         ";
m["en function KinBody::Joint GetResolutions"] = "\n\nvoid  **GetResolutions**\\(std::vector<  dReal  > & resolutions, bool bAppend = false )\n    \n    gets all resolutions for the joint axes\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["en function KinBody::Joint SetResolution"] = "\n\nvoid  **SetResolution**\\(dReal resolution, int iaxis = 0 )\n    \n            ";
m["en function KinBody::Joint GetWeight"] = "\n\ndReal  **GetWeight**\\(int axis = 0 )\n    \n    The weight associated with a joint's axis for computing a distance in the robot configuration space.\n    \n            ";
m["en function KinBody::Joint GetWeights"] = "\n\nvoid  **GetWeights**\\(std::vector<  dReal  > & weights, bool bAppend = false )\n    \n    gets all weights for the joint axes\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["en function KinBody::Joint SetWeights"] = "\n\nvoid  **SetWeights**\\(const std::vector<  dReal  > & weights)\n    \n    *See*\n        GetWeight \n        ";
m["en function KinBody::Joint SubtractValues"] = "\n\nvoid  **SubtractValues**\\(std::vector<  dReal  > & values1, const std::vector<  dReal  > & values2)\n    \n    Computes the configuration difference values1-values2 and stores it in values1.\n    \n    Takes into account joint limits and wrapping of circular joints.         ";
m["en function KinBody::Joint SubtractValue"] = "\n\ndReal  **SubtractValue**\\(dReal value1, dReal value2, int iaxis)\n    \n    Returns the configuration difference value1-value2 for axis i.\n    \n    Takes into account joint limits and wrapping of circular joints.         ";
m["en function KinBody::Joint AddTorque"] = "\n\nvoid  **AddTorque**\\(const std::vector<  dReal  > & torques)\n    \n    Add effort (force or torque) to the joint.\n    \n            ";
m["en function KinBody::KinBodyStateSaver  GetBody"] = "\n\nKinBodyPtr  **GetBody**\\()\n    \n            ";
m["en function KinBody::KinBodyStateSaver  Restore"] = "\n\nvoid  **Restore**\\(boost::shared_ptr<  KinBody  > body = boost::shared_ptr<  KinBody  >() )\n    \n    restore the state\n    \n    *Parameters*\n     ``body`` - \n      if set, will attempt to restore the stored state to the passed in body, otherwise will restore it for the original body. \\ *Exceptions*\n     ``openrave_exception`` - \n      if the passed in body is not compatible with the saved state, will throw\n    \n            ";
m["en function KinBody::KinBodyStateSaver  Release"] = "\n\nvoid  **Release**\\()\n    \n    release the body state. _pbody will not get restored on destruction\n    \n    After this call, it will still be possible to use Restore.         ";
m["en function KinBody::ManageData GetSystem"] = "\n\nSensorSystemBasePtr  **GetSystem**\\()\n    \n            ";
m["en function KinBody::ManageData GetData"] = "\n\nXMLReadableConstPtr  **GetData**\\()\n    \n    returns a pointer to the data used to initialize the BODY with AddKinBody. if psize is not NULL, will be filled with the size of the data in bytes This function will be used to restore bodies that were removed         ";
m["en function KinBody::ManageData GetOffsetLink"] = "\n\nKinBody::LinkPtr  **GetOffsetLink**\\()\n    \n    particular link that sensor system is tracking. All transformations describe this link.         ";
m["en function KinBody::ManageData IsPresent"] = "\n\nbool  **IsPresent**\\()\n    \n    true if the object is being updated by the system due to its presence in the real environment\n    \n            ";
m["en function KinBody::ManageData IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    true if should update openrave body\n    \n            ";
m["en function KinBody::ManageData IsLocked"] = "\n\nbool  **IsLocked**\\()\n    \n    if true, the vision system should not destroy this object once it stops being present\n    \n            ";
m["en function KinBody::ManageData Lock"] = "\n\nbool  **Lock**\\(bool bDoLock)\n    \n    set a lock on a particular body\n    \n            ";
m["en function RobotBase GetManipulators"] = "\n\nstd::vector<  ManipulatorPtr  > &  **GetManipulators**\\()\n    \n    Returns the manipulators of the robot.\n    \n            ";
m["en function RobotBase GetManipulators"] = "\n\nstd::vector<  ManipulatorPtr  > &  **GetManipulators**\\()\n    \n    Returns the manipulators of the robot.\n    \n            ";
m["en function RobotBase SetActiveManipulator \"int\""] = "\n\nvoid  **SetActiveManipulator**\\(int index)\n    \n            ";
m["en function RobotBase SetActiveManipulator \"const std::string\""] = "\n\nvoid  **SetActiveManipulator**\\(const std::string & manipname)\n    \n    sets the active manipulator of the robot\n    \n    *Parameters*\n     ``manipname`` - \n      manipulator name \\ *Exceptions*\n     ``openrave_exception`` - \n      if manipulator not present, will throw an exception\n    \n            ";
m["en function RobotBase GetActiveManipulator"] = "\n\nManipulatorPtr  **GetActiveManipulator**\\()\n    \n            ";
m["en function RobotBase AddManipulator"] = "\n\nManipulatorPtr  **AddManipulator**\\(const  ManipulatorInfo  & manipinfo)\n    \n    adds a manipulator the list\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      If there exists a manipulator with the same name, will throw an exception Will copy the information of this manipulator object into a new manipulator and initialize it with the robot. Will change the robot structure hash..\n    \n    *Return*\n        the new manipulator attached to the robot \n        ";
m["en function RobotBase RemoveManipulator"] = "\n\nvoid  **RemoveManipulator**\\(ManipulatorPtr manip)\n    \n    removes a manipulator from the robot list.\n    \n    Will change the robot structure hash.. if the active manipulator is set to this manipulator, it will be set to None afterwards         ";
m["en function RobotBase GetActiveManipulatorIndex"] = "\n\nint  **GetActiveManipulatorIndex**\\()\n    \n            ";
m["en function RobotBase GetAttachedSensors"] = "\n\nstd::vector<  AttachedSensorPtr  > &  **GetAttachedSensors**\\()\n    \n            ";
m["en function RobotBase GetController"] = "\n\nControllerBasePtr  **GetController**\\()\n    \n    gets the robot controller\n    \n            ";
m["en function RobotBase SetController"] = "\n\nbool  **SetController**\\(ControllerBasePtr controller, const std::vector< int > & dofindices, int nControlTransformation)\n    \n    set a controller for a robot\n    \n    *Parameters*\n     ``pController`` - \n      - if NULL, sets the controller of this robot to NULL. otherwise attemps to set the controller to this robot. \n     ``args`` - \n      - the argument list to pass when initializing the controller \n            ";
m["en function RobotBase SetController"] = "\n\nbool  **SetController**\\(ControllerBasePtr controller, const std::vector< int > & dofindices, int nControlTransformation)\n    \n    set a controller for a robot\n    \n    *Parameters*\n     ``pController`` - \n      - if NULL, sets the controller of this robot to NULL. otherwise attemps to set the controller to this robot. \n     ``args`` - \n      - the argument list to pass when initializing the controller \n            ";
m["en function RobotBase SetController"] = "\n\nbool  **SetController**\\(ControllerBasePtr controller, const std::vector< int > & dofindices, int nControlTransformation)\n    \n    set a controller for a robot\n    \n    *Parameters*\n     ``pController`` - \n      - if NULL, sets the controller of this robot to NULL. otherwise attemps to set the controller to this robot. \n     ``args`` - \n      - the argument list to pass when initializing the controller \n            ";
m["en function RobotBase SetActiveDOFs \"const std::vector; int\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine = OpenRAVE::DOF_NoTransform )\n    \n    Set the joint indices and affine transformation dofs that the planner should use. If DOF_RotationAxis is specified, the previously set axis is used.\n    \n    *Parameters*\n     ``dofindices`` - \n      the indices of the original degrees of freedom to use. \n     ``affine`` - \n      A bitmask of DOFAffine values \n            ";
m["en function RobotBase SetActiveDOFs \"const std::vector; int\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine = OpenRAVE::DOF_NoTransform )\n    \n    Set the joint indices and affine transformation dofs that the planner should use. If DOF_RotationAxis is specified, the previously set axis is used.\n    \n    *Parameters*\n     ``dofindices`` - \n      the indices of the original degrees of freedom to use. \n     ``affine`` - \n      A bitmask of DOFAffine values \n            ";
m["en function RobotBase SetActiveDOFs \"const std::vector; int; const Vector\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine, const  Vector  & rotationaxis)\n    \n    Set the joint indices and affine transformation dofs that the planner should use. If DOF_RotationAxis is specified, then rotationaxis is set as the new axis.\n    \n    *Parameters*\n     ``dofindices`` - \n      the indices of the original degrees of freedom to use. \n     ``affine`` - \n      A bitmask of DOFAffine values \n     ``rotationaxis`` - \n      if DOF_RotationAxis is specified, pRotationAxis is used as the new axis \n            ";
m["en function RobotBase GetActiveDOF"] = "\n\nint  **GetActiveDOF**\\()\n    \n            ";
m["en function RobotBase GetAffineDOF"] = "\n\nint  **GetAffineDOF**\\()\n    \n            ";
m["en function RobotBase GetAffineDOFIndex"] = "\n\nint  **GetAffineDOFIndex**\\(DOFAffine dof)\n    \n            ";
m["en function RobotBase GetAffineRotationAxis"] = "\n\nVector  **GetAffineRotationAxis**\\()\n    \n            ";
m["en function RobotBase SetAffineTranslationLimits"] = "\n\nvoid  **SetAffineTranslationLimits**\\(const  Vector  & lower, const  Vector  & upper)\n    \n            ";
m["en function RobotBase SetAffineRotationAxisLimits"] = "\n\nvoid  **SetAffineRotationAxisLimits**\\(const  Vector  & lower, const  Vector  & upper)\n    \n            ";
m["en function RobotBase SetAffineRotation3DLimits"] = "\n\nvoid  **SetAffineRotation3DLimits**\\(const  Vector  & lower, const  Vector  & upper)\n    \n            ";
m["en function RobotBase SetAffineRotationQuatLimits"] = "\n\nvoid  **SetAffineRotationQuatLimits**\\(const  Vector  & quatangle)\n    \n    sets the quaternion limits using a starting rotation and the max angle deviation from it.\n    \n    *Parameters*\n     ``quatangle`` - \n      quaternion_start * max_angle. acos(q dot quaternion_start) <= max_angle. If max_angle is 0, then will take the current transform of the robot \n            ";
m["en function RobotBase SetAffineTranslationMaxVels"] = "\n\nvoid  **SetAffineTranslationMaxVels**\\(const  Vector  & vels)\n    \n            ";
m["en function RobotBase SetAffineRotationAxisMaxVels"] = "\n\nvoid  **SetAffineRotationAxisMaxVels**\\(const  Vector  & vels)\n    \n            ";
m["en function RobotBase SetAffineRotation3DMaxVels"] = "\n\nvoid  **SetAffineRotation3DMaxVels**\\(const  Vector  & vels)\n    \n            ";
m["en function RobotBase SetAffineRotationQuatMaxVels"] = "\n\nvoid  **SetAffineRotationQuatMaxVels**\\(dReal vels)\n    \n            ";
m["en function RobotBase SetAffineTranslationResolution"] = "\n\nvoid  **SetAffineTranslationResolution**\\(const  Vector  & resolution)\n    \n            ";
m["en function RobotBase SetAffineRotationAxisResolution"] = "\n\nvoid  **SetAffineRotationAxisResolution**\\(const  Vector  & resolution)\n    \n            ";
m["en function RobotBase SetAffineRotation3DResolution"] = "\n\nvoid  **SetAffineRotation3DResolution**\\(const  Vector  & resolution)\n    \n            ";
m["en function RobotBase SetAffineRotationQuatResolution"] = "\n\nvoid  **SetAffineRotationQuatResolution**\\(dReal resolution)\n    \n            ";
m["en function RobotBase SetAffineTranslationWeights"] = "\n\nvoid  **SetAffineTranslationWeights**\\(const  Vector  & weights)\n    \n            ";
m["en function RobotBase SetAffineRotationAxisWeights"] = "\n\nvoid  **SetAffineRotationAxisWeights**\\(const  Vector  & weights)\n    \n            ";
m["en function RobotBase SetAffineRotation3DWeights"] = "\n\nvoid  **SetAffineRotation3DWeights**\\(const  Vector  & weights)\n    \n            ";
m["en function RobotBase SetAffineRotationQuatWeights"] = "\n\nvoid  **SetAffineRotationQuatWeights**\\(dReal weights)\n    \n            ";
m["en function RobotBase GetAffineTranslationLimits"] = "\n\nvoid  **GetAffineTranslationLimits**\\(Vector  & lower, Vector  & upper)\n    \n            ";
m["en function RobotBase GetAffineRotationAxisLimits"] = "\n\nvoid  **GetAffineRotationAxisLimits**\\(Vector  & lower, Vector  & upper)\n    \n            ";
m["en function RobotBase GetAffineRotation3DLimits"] = "\n\nvoid  **GetAffineRotation3DLimits**\\(Vector  & lower, Vector  & upper)\n    \n            ";
m["en function RobotBase GetAffineRotationQuatLimits"] = "\n\nVector  **GetAffineRotationQuatLimits**\\()\n    \n    gets the quaternion limits\n    \n    *Parameters*\n     ``quatangle`` - \n      quaternion_start * max_angle. acos(q dot quaternion_start) <= max_angle \n            ";
m["en function RobotBase GetAffineTranslationMaxVels"] = "\n\nVector  **GetAffineTranslationMaxVels**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationAxisMaxVels"] = "\n\nVector  **GetAffineRotationAxisMaxVels**\\()\n    \n            ";
m["en function RobotBase GetAffineRotation3DMaxVels"] = "\n\nVector  **GetAffineRotation3DMaxVels**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationQuatMaxVels"] = "\n\ndReal  **GetAffineRotationQuatMaxVels**\\()\n    \n            ";
m["en function RobotBase GetAffineTranslationResolution"] = "\n\nVector  **GetAffineTranslationResolution**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationAxisResolution"] = "\n\nVector  **GetAffineRotationAxisResolution**\\()\n    \n            ";
m["en function RobotBase GetAffineRotation3DResolution"] = "\n\nVector  **GetAffineRotation3DResolution**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationQuatResolution"] = "\n\ndReal  **GetAffineRotationQuatResolution**\\()\n    \n            ";
m["en function RobotBase GetAffineTranslationWeights"] = "\n\nVector  **GetAffineTranslationWeights**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationAxisWeights"] = "\n\nVector  **GetAffineRotationAxisWeights**\\()\n    \n            ";
m["en function RobotBase GetAffineRotation3DWeights"] = "\n\nVector  **GetAffineRotation3DWeights**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationQuatWeights"] = "\n\ndReal  **GetAffineRotationQuatWeights**\\()\n    \n            ";
m["en function RobotBase SetActiveDOFValues"] = "\n\nvoid  **SetActiveDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = 1 )\n    \n            ";
m["en function RobotBase GetActiveDOFValues"] = "\n\nvoid  **GetActiveDOFValues**\\(std::vector<  dReal  > & v)\n    \n            ";
m["en function RobotBase GetActiveDOFWeights"] = "\n\nvoid  **GetActiveDOFWeights**\\(std::vector<  dReal  > & v)\n    \n            ";
m["en function RobotBase SetActiveDOFVelocities"] = "\n\nvoid  **SetActiveDOFVelocities**\\(const std::vector<  dReal  > & velocities, uint32_t checklimits = 1 )\n    \n            ";
m["en function RobotBase GetActiveDOFVelocities"] = "\n\nvoid  **GetActiveDOFVelocities**\\(std::vector<  dReal  > & velocities)\n    \n            ";
m["en function RobotBase GetActiveDOFLimits"] = "\n\nvoid  **GetActiveDOFLimits**\\(std::vector<  dReal  > & lower, std::vector<  dReal  > & upper)\n    \n            ";
m["en function RobotBase GetActiveDOFMaxVel"] = "\n\nvoid  **GetActiveDOFMaxVel**\\(std::vector<  dReal  > & v)\n    \n            ";
m["en function RobotBase GetActiveDOFMaxAccel"] = "\n\nvoid  **GetActiveDOFMaxAccel**\\(std::vector<  dReal  > & v)\n    \n            ";
m["en function RobotBase GetActiveDOFResolutions"] = "\n\nvoid  **GetActiveDOFResolutions**\\(std::vector<  dReal  > & v)\n    \n            ";
m["en function RobotBase GetActiveConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetActiveConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n    return a copy of the configuration specification of the active dofs\n    \n    Note that the return type is by-value, so should not be used in iteration         ";
m["en function RobotBase GetActiveDOFIndices"] = "\n\nconst std::vector< int > &  **GetActiveDOFIndices**\\()\n    \n    Return the set of active dof indices of the joints.\n    \n            ";
m["en function RobotBase SubtractActiveDOFValues"] = "\n\nvoid  **SubtractActiveDOFValues**\\(std::vector<  dReal  > & q1, const std::vector<  dReal  > & q2)\n    \n    computes the configuration difference q1-q2 and stores it in q1. Takes into account joint limits and circular joints\n    \n            ";
m["en function RobotBase CalculateActiveJacobian \"int; const Vector; std::vector\""] = "\n\nvoid  **CalculateActiveJacobian**\\(int index, const  Vector  & offset, std::vector<  dReal  > & jacobian)\n    \n    Calculates the translation jacobian with respect to a link.\n    \n    *Parameters*\n     ``mjacobian`` - \n      a 3 x ActiveDOF matrix Calculates the partial differentials for the active degrees of freedom that in the path from the root node to _veclinks[index] (doesn't touch the rest of the values). \n            ";
m["en function RobotBase CalculateActiveRotationJacobian \"int; const Vector; std::vector\""] = "\n\nvoid  **CalculateActiveRotationJacobian**\\(int index, const  Vector  & qInitialRot, std::vector<  dReal  > & jacobian)\n    \n            ";
m["en function RobotBase CalculateActiveAngularVelocityJacobian \"int; std::vector\""] = "\n\nvoid  **CalculateActiveAngularVelocityJacobian**\\(int index, std::vector<  dReal  > & jacobian)\n    \n    Calculates the angular velocity jacobian of a specified link about the axes of world coordinates.\\ *Parameters*\n     ``index`` - \n      of the link that the rotation is attached to \n     ``mjacobian`` - \n      3x(num ACTIVE DOF) matrix \n            ";
m["en function RobotBase Grab \"KinBodyPtr\""] = "\n\nbool  **Grab**\\(KinBodyPtr body)\n    \n    Grabs the body with the active manipulator's end effector.\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["en function RobotBase Grab \"KinBodyPtr; const std::set\""] = "\n\nbool  **Grab**\\(KinBodyPtr body, const std::set< int > & setRobotLinksToIgnore)\n    \n    Grabs the body with the active manipulator's end effector.\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``setRobotLinksToIgnore`` - \n      Additional robot link indices that collision checker ignore when checking collisions between the grabbed body and the robot.\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["en function RobotBase Grab \"KinBodyPtr; LinkPtr\""] = "\n\nbool  **Grab**\\(KinBodyPtr body, LinkPtr pRobotLinkToGrabWith)\n    \n    Grab a body with the specified link.\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``pRobotLinkToGrabWith`` - \n      the link of this robot that will perform the grab\n    \n    *Return*\n        true if successful and body is grabbed/ \n        ";
m["en function RobotBase Grab \"KinBodyPtr; LinkPtr; const std::set\""] = "\n\nbool  **Grab**\\(KinBodyPtr body, LinkPtr pRobotLinkToGrabWith, const std::set< int > & setRobotLinksToIgnore)\n    \n    Grab the body with the specified link.\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``pRobotLinkToGrabWith`` - \n      the link of this robot that will perform the grab \n     ``setRobotLinksToIgnore`` - \n      Additional robot link indices that collision checker ignore when checking collisions between the grabbed body and the robot.\n    \n    *Return*\n        true if successful and body is grabbed. \n        ";
m["en function RobotBase Release"] = "\n\nvoid  **Release**\\(KinBodyPtr body)\n    \n    Release the body if grabbed.\n    \n    *Parameters*\n     ``body`` - \n      body to release \n            ";
m["en function RobotBase ReleaseAllGrabbed"] = "\n\nvoid  **ReleaseAllGrabbed**\\()\n    \n    Release all grabbed bodies.\n    \n    release all bodies         ";
m["en function RobotBase RegrabAll"] = "\n\nvoid  **RegrabAll**\\()\n    \n    Releases and grabs all bodies, has the effect of recalculating all the initial collision with the bodies.\n    \n    This has the effect of resetting the current collisions any grabbed body makes with the robot into an ignore list.         ";
m["en function RobotBase IsGrabbing"] = "\n\nLinkPtr  **IsGrabbing**\\(KinBodyConstPtr body)\n    \n    return the robot link that is currently grabbing the body. If the body is not grabbed, will return an empty pointer.\n    \n    *Parameters*\n     ``body`` - \n      the body to check \n            ";
m["en function RobotBase GetGrabbed"] = "\n\nvoid  **GetGrabbed**\\(std::vector<  KinBodyPtr  > & vbodies)\n    \n    gets all grabbed bodies of the robot\n    \n    *Parameters*\n     ``vbodies`` - \n      filled with the grabbed bodies \n            ";
m["en function RobotBase GetRobotStructureHash"] = "\n\nconst std::string &  **GetRobotStructureHash**\\()\n    \n    A md5 hash unique to the particular robot structure that involves manipulation and sensing components The serialization for the attached sensors will not involve any sensor specific properties (since they can change through calibration)         ";
m["en function RobotBase::Manipulator GetIkParameterization \"const IkParameterization; bool\""] = "\n\nIkParameterization  **GetIkParameterization**\\(const  IkParameterization  & ikparam, bool inworld = true )\n    \n    returns a full parameterization of a given IK type for the current manipulator position using an existing IkParameterization as the seed.\n    \n    *Parameters*\n     ``ikparam`` - \n      The parameterization to use as seed. \n     ``inworld`` - \n      if true will return the parameterization in the world coordinate system, otherwise in the base link (GetBase()) coordinate system Custom data is copied to the new parameterization. Furthermore, some IK types like Lookat3D and TranslationLocalGlobal6D set constraints in the global coordinate system of the manipulator. Because these values are not stored in manipulator itself, they have to be passed in through an existing IkParameterization. Ideally pluging the returned ik parameterization into FindIkSolution should return the a manipulator configuration such that a new call to GetIkParameterization returns the same values. \n            ";
m["en function RobotBase::Manipulator GetIkParameterization \"IkParameterizationType; bool\""] = "\n\nIkParameterization  **GetIkParameterization**\\(IkParameterizationType iktype, bool inworld = true )\n    \n    returns the parameterization of a given IK type for the current manipulator position.\n    \n    *Parameters*\n     ``iktype`` - \n      the type of parameterization to request \n     ``inworld`` - \n      if true will return the parameterization in the world coordinate system, otherwise in the base link (GetBase()) coordinate system Ideally pluging the returned ik parameterization into FindIkSolution should return the a manipulator configuration such that a new call to GetIkParameterization returns the same values. In other words:  \n            ";
m["en function RobotBase::Manipulator GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    Return the transformation of the manipulator frame.\n    \n    The manipulator frame is defined by the the end effector link position * GetLocalToolTransform() All inverse kinematics and jacobian queries are specifying this frame.         ";
m["en function RobotBase::Manipulator GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    Return the transformation of the manipulator frame.\n    \n    The manipulator frame is defined by the the end effector link position * GetLocalToolTransform() All inverse kinematics and jacobian queries are specifying this frame.         ";
m["en function RobotBase::Manipulator GetVelocity"] = "\n\nstd::pair<  Vector ,  Vector  >  **GetVelocity**\\()\n    \n    return the linear/angular velocity of the manipulator coordinate system\n    \n            ";
m["en function RobotBase::Manipulator GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["en function RobotBase::Manipulator SetName"] = "\n\nvoid  **SetName**\\(const std::string & name)\n    \n    new name for manipulator\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      if name is already used in another manipulator \n            ";
m["en function RobotBase::Manipulator GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\()\n    \n            ";
m["en function RobotBase::Manipulator SetIkSolver"] = "\n\nbool  **SetIkSolver**\\(IkSolverBasePtr iksolver)\n    \n    Sets the ik solver and initializes it with the current manipulator.\n    \n    Due to complications with translation,rotation,direction,and ray ik, the ik solver should take into account the grasp transform (_info._tLocalTool) internally. The actual ik primitives are transformed into the base frame only.         ";
m["en function RobotBase::Manipulator GetIkSolver"] = "\n\nIkSolverBasePtr  **GetIkSolver**\\()\n    \n    Returns the currently set ik solver.\n    \n            ";
m["en function RobotBase::Manipulator SetIkSolver"] = "\n\nbool  **SetIkSolver**\\(IkSolverBasePtr iksolver)\n    \n    Sets the ik solver and initializes it with the current manipulator.\n    \n    Due to complications with translation,rotation,direction,and ray ik, the ik solver should take into account the grasp transform (_info._tLocalTool) internally. The actual ik primitives are transformed into the base frame only.         ";
m["en function RobotBase::Manipulator GetNumFreeParameters"] = "\n\nint  **GetNumFreeParameters**\\()\n    \n    Number of free parameters defining the null solution space.\n    \n    Each parameter is always in the range of [0,1].         ";
m["en function RobotBase::Manipulator GetFreeParameters"] = "\n\nbool  **GetFreeParameters**\\(std::vector<  dReal  > & vFreeParameters)\n    \n    gets the free parameters from the current robot configuration\n    \n    *Parameters*\n     ``vFreeParameters`` - \n      is filled with GetNumFreeParameters() parameters in [0,1] range\n    \n    *Return*\n        true if succeeded \n        ";
m["en function RobotBase::Manipulator FindIKSolution \"const IkParameterization; std::vector; int\""] = "\n\nbool  **FindIKSolution**\\(const  IkParameterization  & param, std::vector<  dReal  > & solution, int filteroptions)\n    \n    Find a close solution to the current robot's joint values.\n    \n    *Parameters*\n     ``param`` - \n      The transformation of the end-effector in the global coord system \n     ``solution`` - \n      Will be of size GetArmIndices().size() and contain the best solution \n     ``filteroptions`` - \n      A bitmask of IkFilterOptions values controlling what is checked for each ik solution. The function is a wrapper around the IkSolver interface. Note that the solution returned is not guaranteed to be the closest solution. In order to compute that, will have to compute all the ik solutions using FindIKSolutions. \n            ";
m["en function RobotBase::Manipulator FindIKSolution \"const IkParameterization; const std::vector; std::vector; int\""] = "\n\nbool  **FindIKSolution**\\(const  IkParameterization  & param, const std::vector<  dReal  > & vFreeParameters, std::vector<  dReal  > & solution, int filteroptions)\n    \n            ";
m["en function RobotBase::Manipulator FindIKSolutions \"const IkParameterization; std::vector; int\""] = "\n\nbool  **FindIKSolutions**\\(const  IkParameterization  & param, std::vector< std::vector<  dReal  > > & solutions, int filteroptions)\n    \n    Find all the IK solutions for the given end effector transform.\n    \n    *Parameters*\n     ``param`` - \n      The transformation of the end-effector in the global coord system \n     ``solutions`` - \n      An array of all solutions, each element in solutions is of size GetArmIndices().size() \n     ``filteroptions`` - \n      A bitmask of IkFilterOptions values controlling what is checked for each ik solution. \n            ";
m["en function RobotBase::Manipulator FindIKSolutions \"const IkParameterization; const std::vector; std::vector; int\""] = "\n\nbool  **FindIKSolutions**\\(const  IkParameterization  & param, const std::vector<  dReal  > & vFreeParameters, std::vector< std::vector<  dReal  > > & solutions, int filteroptions)\n    \n            ";
m["en function RobotBase::Manipulator GetBase"] = "\n\nLinkPtr  **GetBase**\\()\n    \n    the base used for the iksolver\n    \n            ";
m["en function RobotBase::Manipulator GetEndEffector"] = "\n\nLinkPtr  **GetEndEffector**\\()\n    \n    the end effector link (used to define workspace distance)\n    \n            ";
m["en function RobotBase::Manipulator GetLocalToolTransform"] = "\n\nTransform  **GetLocalToolTransform**\\()\n    \n    Return transform with respect to end effector defining the grasp coordinate system.\n    \n            ";
m["en function RobotBase::Manipulator GetLocalToolTransform"] = "\n\nTransform  **GetLocalToolTransform**\\()\n    \n    Return transform with respect to end effector defining the grasp coordinate system.\n    \n            ";
m["en function RobotBase::Manipulator SetLocalToolTransform"] = "\n\nvoid  **SetLocalToolTransform**\\(const  Transform  & t)\n    \n    Sets the local tool transform with respect to the end effector.\n    \n    Because this call will change manipulator hash, it resets the loaded IK and sets the Prop_RobotManipulatorTool message.         ";
m["en function RobotBase::Manipulator GetGripperIndices"] = "\n\nconst std::vector< int > &  **GetGripperIndices**\\()\n    \n    Gripper indices of the joints that the manipulator controls.\n    \n            ";
m["en function RobotBase::Manipulator GetGripperIndices"] = "\n\nconst std::vector< int > &  **GetGripperIndices**\\()\n    \n    Gripper indices of the joints that the manipulator controls.\n    \n            ";
m["en function RobotBase::Manipulator GetArmIndices"] = "\n\nconst std::vector< int > &  **GetArmIndices**\\()\n    \n    Return the indices of the DOFs of the arm (used for IK, etc).\n    \n    Usually the DOF indices from pBase to pEndEffector         ";
m["en function RobotBase::Manipulator GetArmIndices"] = "\n\nconst std::vector< int > &  **GetArmIndices**\\()\n    \n    Return the indices of the DOFs of the arm (used for IK, etc).\n    \n    Usually the DOF indices from pBase to pEndEffector         ";
m["en function RobotBase::Manipulator GetClosingDirection"] = "\n\nconst std::vector<  dReal  > &  **GetClosingDirection**\\()\n    \n    return the normal direction to move joints to 'close' the hand\n    \n            ";
m["en function RobotBase::Manipulator GetLocalToolDirection"] = "\n\nVector  **GetLocalToolDirection**\\()\n    \n    direction of palm/head/manipulator used for approaching. defined inside the manipulator/grasp coordinate system\n    \n            ";
m["en function RobotBase::Manipulator GetLocalToolDirection"] = "\n\nVector  **GetLocalToolDirection**\\()\n    \n    direction of palm/head/manipulator used for approaching. defined inside the manipulator/grasp coordinate system\n    \n            ";
m["en function RobotBase::Manipulator GetLocalToolDirection"] = "\n\nVector  **GetLocalToolDirection**\\()\n    \n    direction of palm/head/manipulator used for approaching. defined inside the manipulator/grasp coordinate system\n    \n            ";
m["en function RobotBase::Manipulator IsGrabbing"] = "\n\nbool  **IsGrabbing**\\(KinBodyConstPtr body)\n    \n    Checks collision with a target body and all the independent links of the robot. Ignores disabled links.\n    \n    *Parameters*\n     ``the`` - \n      body to check the independent links with \n     ``report`` - \n      [optional] collision report\n    \n    *Return*\n        true if a collision occurredreturn true if the body is being grabbed by any link on this manipulator \n        ";
m["en function RobotBase::Manipulator GetChildJoints"] = "\n\nvoid  **GetChildJoints**\\(std::vector<  JointPtr  > & vjoints)\n    \n    Get all child joints of the manipulator starting at the pEndEffector link.\n    \n            ";
m["en function RobotBase::Manipulator GetChildDOFIndices"] = "\n\nvoid  **GetChildDOFIndices**\\(std::vector< int > & vdofndices)\n    \n    Get all child DOF indices of the manipulator starting at the pEndEffector link.\n    \n            ";
m["en function RobotBase::Manipulator GetChildLinks"] = "\n\nvoid  **GetChildLinks**\\(std::vector<  LinkPtr  > & vlinks)\n    \n    Get all child links of the manipulator starting at pEndEffector link.\n    \n    The child links do not include the arm links.         ";
m["en function RobotBase::Manipulator IsChildLink"] = "\n\nbool  **IsChildLink**\\(LinkConstPtr plink)\n    \n    returns true if a link is part of the child links of the manipulator.\n    \n    The child links do not include the arm links.         ";
m["en function RobotBase::Manipulator GetIndependentLinks"] = "\n\nvoid  **GetIndependentLinks**\\(std::vector<  LinkPtr  > & vlinks)\n    \n    Get all links that are independent of the arm and gripper joints.\n    \n    In other words, returns all links not on the path from the base to the end effector and not children of the end effector. The base and all links rigidly attached to it are also returned.         ";
m["en function RobotBase::Manipulator GetArmConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetArmConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n    return a copy of the configuration specification of the arm indices\n    \n    Note that the return type is by-value, so should not be used in iteration         ";
m["en function RobotBase::Manipulator CheckEndEffectorCollision"] = "\n\nbool  **CheckEndEffectorCollision**\\(const  Transform  & tEE, CollisionReportPtr report = CollisionReportPtr () )\n    \n    Checks collision with only the gripper given its end-effector transform. Ignores disabled links.\n    \n    *Parameters*\n     ``tEE`` - \n      the end effector transform \n     ``report`` - \n      [optional] collision report\n    \n    *Return*\n        true if a collision occurred \n        ";
m["en function RobotBase::Manipulator CheckEndEffectorCollision"] = "\n\nbool  **CheckEndEffectorCollision**\\(const  Transform  & tEE, CollisionReportPtr report = CollisionReportPtr () )\n    \n    Checks collision with only the gripper given its end-effector transform. Ignores disabled links.\n    \n    *Parameters*\n     ``tEE`` - \n      the end effector transform \n     ``report`` - \n      [optional] collision report\n    \n    *Return*\n        true if a collision occurred \n        ";
m["en function RobotBase::Manipulator CheckIndependentCollision"] = "\n\nbool  **CheckIndependentCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    Checks collision with the environment with all the independent links of the robot. Ignores disabled links.\n    \n    *Parameters*\n     ``report`` - \n      [optional] collision report\n    \n    *Return*\n        true if a collision occurred \n        ";
m["en function RobotBase::Manipulator CheckIndependentCollision"] = "\n\nbool  **CheckIndependentCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    Checks collision with the environment with all the independent links of the robot. Ignores disabled links.\n    \n    *Parameters*\n     ``report`` - \n      [optional] collision report\n    \n    *Return*\n        true if a collision occurred \n        ";
m["en function RobotBase::Manipulator CalculateJacobian"] = "\n\nvoid  **CalculateJacobian**\\(std::vector<  dReal  > & jacobian)\n    \n    computes the jacobian of the manipulator arm indices of the current manipulator frame world position.\n    \n    The manipulator frame is computed from Manipulator::GetTransform()         ";
m["en function RobotBase::Manipulator CalculateRotationJacobian"] = "\n\nvoid  **CalculateRotationJacobian**\\(std::vector<  dReal  > & jacobian)\n    \n    computes the quaternion jacobian of the manipulator arm indices from the current manipulator frame rotation.\n    \n            ";
m["en function RobotBase::Manipulator CalculateAngularVelocityJacobian"] = "\n\nvoid  **CalculateAngularVelocityJacobian**\\(std::vector<  dReal  > & jacobian)\n    \n    computes the angule axis jacobian of the manipulator arm indices.\n    \n            ";
m["en function RobotBase::Manipulator GetStructureHash"] = "\n\nconst std::string &  **GetStructureHash**\\()\n    \n    Return hash of just the manipulator definition.\n    \n            ";
m["en function RobotBase::Manipulator GetKinematicsStructureHash"] = "\n\nconst std::string &  **GetKinematicsStructureHash**\\()\n    \n    Return hash of all kinematics information that involves solving the inverse kinematics equations.\n    \n    This includes joint axes, joint positions, and final grasp transform. Hash is used to cache the solvers.         ";
m["en function RobotBase::AttachedSensor GetSensor"] = "\n\nSensorBasePtr  **GetSensor**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetAttachingLink"] = "\n\nLinkPtr  **GetAttachingLink**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetRelativeTransform"] = "\n\nTransform  **GetRelativeTransform**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetData"] = "\n\nSensorBase::SensorDataPtr  **GetData**\\()\n    \n    retrieves the current data from the sensor\n    \n            ";
m["en function RobotBase::AttachedSensor SetRelativeTransform"] = "\n\nvoid  **SetRelativeTransform**\\(const  Transform  & t)\n    \n            ";
m["en function RobotBase::AttachedSensor GetStructureHash"] = "\n\nconst std::string &  **GetStructureHash**\\()\n    \n    *Return*\n        hash of the sensor definition \n        ";
m["en function Robot::RobotStateSaver  GetBody"] = "\n\nKinBodyPtr  **GetBody**\\()\n    \n            ";
m["en function Robot::RobotStateSaver  Restore"] = "\n\nvoid  **Restore**\\(boost::shared_ptr<  KinBody  > body = boost::shared_ptr<  KinBody  >() )\n    \n    restore the state\n    \n    *Parameters*\n     ``body`` - \n      if set, will attempt to restore the stored state to the passed in body, otherwise will restore it for the original body. \\ *Exceptions*\n     ``openrave_exception`` - \n      if the passed in body is not compatible with the saved state, will throw\n    \n            ";
m["en function Robot::RobotStateSaver  Release"] = "\n\nvoid  **Release**\\()\n    \n    release the body state. _pbody will not get restored on destruction\n    \n    After this call, it will still be possible to use Restore.         ";
m["en function RaveCreateRobot"] = "\n\nOPENRAVE_API   RobotBasePtr  **RaveCreateRobot**\\(EnvironmentBasePtr penv, const std::string & name = \"\" )\n    \n            ";
m["en function RaveCreateKinBody"] = "\n\nOPENRAVE_API   KinBodyPtr  **RaveCreateKinBody**\\(EnvironmentBasePtr penv, const std::string & name = \"\" )\n    \n            ";
m["en function SensorBase Configure"] = "\n\nint  **Configure**\\(ConfigureCommand command, bool blocking = false )\n    \n    Configures properties of the sensor like power.\n    \n    *Parameters*\n     ``type`` - \n      ConfigureCommand \n     ``blocking`` - \n      If set to true, makes sure the configuration ends before this function returns.(might cause problems if environment is locked). \\ *Exceptions*\n     ``openrave_exception`` - \n      if command doesn't succeed\n    \n            ";
m["en function SensorBase GetSensorData"] = "\n\nbool  **GetSensorData**\\(SensorDataPtr psensordata)\n    \n    Copy the most recent published data of the sensor given the type.\n    \n    *Parameters*\n     ``psensordata`` - \n      A pointer to SensorData returned from CreateSensorData, the plugin will use psensordata->GetType() in order to return the correctly supported type. Once GetSensorData returns, the caller has full unrestricted access to the data. This method is thread safe. \n            ";
m["en function SensorBase GetSensorData"] = "\n\nbool  **GetSensorData**\\(SensorDataPtr psensordata)\n    \n    Copy the most recent published data of the sensor given the type.\n    \n    *Parameters*\n     ``psensordata`` - \n      A pointer to SensorData returned from CreateSensorData, the plugin will use psensordata->GetType() in order to return the correctly supported type. Once GetSensorData returns, the caller has full unrestricted access to the data. This method is thread safe. \n            ";
m["en function SensorBase GetSensorGeometry"] = "\n\nSensorGeometryPtr  **GetSensorGeometry**\\(SensorType type = ST_Invalid )\n    \n    Returns the sensor geometry. This method is thread safe.\n    \n    *Parameters*\n     ``type`` - \n      the requested sensor type to create. A sensor can support many types. If type is ST_Invalid, then returns a data structure\n    \n    *Return*\n        sensor geometry pointer, use delete to destroy it \n        ";
m["en function SensorBase SetTransform"] = "\n\nvoid  **SetTransform**\\(const  Transform  & trans)\n    \n    Set the transform of a sensor (global coordinate system).\n    \n    *Parameters*\n     ``trans`` - \n      - The transform defining the frame of the sensor. Sensors attached to the robot have their transforms automatically set every time the robot is moved \n            ";
m["en function SensorBase GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    the position of the sensor in the world coordinate system\n    \n            ";
m["en function SensorBase GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n    *Return*\n        the name of the sensor \n        ";
m["en function SensorBase Supports"] = "\n\nbool  **Supports**\\(SensorType type)\n    \n    returns true if sensor supports a particular sensor type\n    \n            ";
m["en function RaveCreateSensor"] = "\n\nOPENRAVE_API   SensorBasePtr  **RaveCreateSensor**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function CollisionCheckerBase SetCollisionOptions \"int\""] = "\n\nbool  **SetCollisionOptions**\\(int collisionoptions)\n    \n    Set basic collision options using the CollisionOptions enum.\n    \n            ";
m["en function CollisionCheckerBase GetCollisionOptions"] = "\n\nint  **GetCollisionOptions**\\()\n    \n    get the current collision options\n    \n            ";
m["en function RaveCreateCollisionChecker"] = "\n\nOPENRAVE_API   CollisionCheckerBasePtr  **RaveCreateCollisionChecker**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function IkParameterization GetType"] = "\n\nIkParameterizationType  **GetType**\\()\n    \n            ";
m["en function IkParameterization SetTransform6D"] = "\n\nvoid  **SetTransform6D**\\(const  Transform  & t)\n    \n            ";
m["en function IkParameterization SetRotation3D"] = "\n\nvoid  **SetRotation3D**\\(const  Vector  & quaternion)\n    \n            ";
m["en function IkParameterization SetTranslation3D"] = "\n\nvoid  **SetTranslation3D**\\(const  Vector  & trans)\n    \n            ";
m["en function IkParameterization SetDirection3D"] = "\n\nvoid  **SetDirection3D**\\(const  Vector  & dir)\n    \n            ";
m["en function IkParameterization SetRay4D"] = "\n\nvoid  **SetRay4D**\\(const  RAY  & ray)\n    \n            ";
m["en function IkParameterization SetLookat3D"] = "\n\nvoid  **SetLookat3D**\\(const  Vector  & trans)\n    \n            ";
m["en function IkParameterization SetTranslationDirection5D"] = "\n\nvoid  **SetTranslationDirection5D**\\(const  RAY  & ray)\n    \n            ";
m["en function IkParameterization SetTranslationXY2D"] = "\n\nvoid  **SetTranslationXY2D**\\(const  Vector  & trans)\n    \n            ";
m["en function IkParameterization SetTranslationXYOrientation3D"] = "\n\nvoid  **SetTranslationXYOrientation3D**\\(const  Vector  & trans)\n    \n            ";
m["en function IkParameterization SetTranslationLocalGlobal6D"] = "\n\nvoid  **SetTranslationLocalGlobal6D**\\(const  Vector  & localtrans, const  Vector  & trans)\n    \n            ";
m["en function IkParameterization SetTranslationXAxisAngle4D"] = "\n\nvoid  **SetTranslationXAxisAngle4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["en function IkParameterization SetTranslationYAxisAngle4D"] = "\n\nvoid  **SetTranslationYAxisAngle4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["en function IkParameterization SetTranslationZAxisAngle4D"] = "\n\nvoid  **SetTranslationZAxisAngle4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["en function IkParameterization SetTranslationXAxisAngleZNorm4D"] = "\n\nvoid  **SetTranslationXAxisAngleZNorm4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["en function IkParameterization SetTranslationYAxisAngleXNorm4D"] = "\n\nvoid  **SetTranslationYAxisAngleXNorm4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["en function IkParameterization SetTranslationZAxisAngleYNorm4D"] = "\n\nvoid  **SetTranslationZAxisAngleYNorm4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["en function IkParameterization GetTransform6D"] = "\n\nconst  Transform  &  **GetTransform6D**\\()\n    \n            ";
m["en function IkParameterization GetRotation3D"] = "\n\nconst  Vector  &  **GetRotation3D**\\()\n    \n            ";
m["en function IkParameterization GetTranslation3D"] = "\n\nconst  Vector  &  **GetTranslation3D**\\()\n    \n            ";
m["en function IkParameterization GetDirection3D"] = "\n\nconst  Vector  &  **GetDirection3D**\\()\n    \n            ";
m["en function IkParameterization GetRay4D"] = "\n\nconst  RAY  **GetRay4D**\\()\n    \n            ";
m["en function IkParameterization GetLookat3D"] = "\n\nconst  Vector  &  **GetLookat3D**\\()\n    \n            ";
m["en function IkParameterization GetTranslationDirection5D"] = "\n\nconst  RAY  **GetTranslationDirection5D**\\()\n    \n            ";
m["en function IkParameterization GetTranslationXY2D"] = "\n\nconst  Vector  &  **GetTranslationXY2D**\\()\n    \n            ";
m["en function IkParameterization GetTranslationXYOrientation3D"] = "\n\nconst  Vector  &  **GetTranslationXYOrientation3D**\\()\n    \n            ";
m["en function IkParameterization GetTranslationLocalGlobal6D"] = "\n\nstd::pair<  Vector ,  Vector  >  **GetTranslationLocalGlobal6D**\\()\n    \n            ";
m["en function IkParameterization GetTranslationXAxisAngle4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationXAxisAngle4D**\\()\n    \n            ";
m["en function IkParameterization GetTranslationYAxisAngle4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationYAxisAngle4D**\\()\n    \n            ";
m["en function IkParameterization GetTranslationZAxisAngle4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationZAxisAngle4D**\\()\n    \n            ";
m["en function IkParameterization GetTranslationXAxisAngleZNorm4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationXAxisAngleZNorm4D**\\()\n    \n            ";
m["en function IkParameterization GetTranslationYAxisAngleXNorm4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationYAxisAngleXNorm4D**\\()\n    \n            ";
m["en function IkParameterization GetTranslationZAxisAngleYNorm4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationZAxisAngleYNorm4D**\\()\n    \n            ";
m["en function IkParameterization GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    Returns the minimum degree of freedoms required for the IK type. Does  count custom data.\n    \n            ";
m["en function IkParameterization GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    Returns the minimum degree of freedoms required for the IK type. Does  count custom data.\n    \n            ";
m["en function IkParameterization GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    Returns the minimum degree of freedoms required for the IK type. Does  count custom data.\n    \n            ";
m["en function IkParameterization GetNumberOfValues"] = "\n\nint  **GetNumberOfValues**\\()\n    \n    Returns the number of values used to represent the parameterization ( >= dof ). Does  count custom data.\n    \n            ";
m["en function IkParameterization GetNumberOfValues"] = "\n\nint  **GetNumberOfValues**\\()\n    \n    Returns the number of values used to represent the parameterization ( >= dof ). Does  count custom data.\n    \n            ";
m["en function IkParameterization GetNumberOfValues"] = "\n\nint  **GetNumberOfValues**\\()\n    \n    Returns the number of values used to represent the parameterization ( >= dof ). Does  count custom data.\n    \n            ";
m["en function IkParameterization GetConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n            ";
m["en function IkParameterization GetConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n            ";
m["en function IkParameterization GetConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n            ";
m["en function IkParameterization ComputeDistanceSqr"] = "\n\ndReal  **ComputeDistanceSqr**\\(const  IkParameterization  & ikparam)\n    \n    Computes the distance squared between two IK parmaeterizations.\n    \n            ";
m["en function IkParameterization MultiplyTransform"] = "\n\nIkParameterization  &  **MultiplyTransform**\\(const  Transform  & t)\n    \n    in-place left-transform into a new coordinate system. Equivalent to t * ikparam\n    \n            ";
m["en function IkParameterization GetValues"] = "\n\nvoid  **GetValues**\\(std::vector<  dReal  >::iterator itvalues)\n    \n    fills the iterator with the serialized values of the ikparameterization.\n    \n    The container the iterator points to needs to have GetNumberOfValues() available. Does not support custom data Don't normalize quaternions since it could hold velocity data.         ";
m["en function IkParameterization SetValues"] = "\n\nvoid  **SetValues**\\(std::vector<  dReal  >::const_iterator itvalues, IkParameterizationType iktype)\n    \n    sets a serialized set of values for the IkParameterization\n    \n    Function does not handle custom data. Don't normalize quaternions since it could hold velocity data.         ";
m["en function IkParameterization GetCustomDataMap"] = "\n\nconst std::map< std::string, std::vector<  dReal  > > &  **GetCustomDataMap**\\()\n    \n    returns a const reference of the custom data key/value pairs\n    \n            ";
m["en function IkParameterization GetCustomValues"] = "\n\nbool  **GetCustomValues**\\(const std::string & name, std::vector<  dReal  > & values)\n    \n    gets custom data if it exists, returns false if it doesn't\n    \n            ";
m["en function IkParameterization SetCustomValues"] = "\n\nvoid  **SetCustomValues**\\(const std::string & name, const std::vector<  dReal  > & values)\n    \n    sets named custom data in the ik parameterization\n    \n    The custom data is serialized along with the rest of the parameters and can also be part of a configuration specification under the \"ikparam_values\" anotation. The custom data name can have meta-tags for the type of transformation the data undergos when MultiplyTransform is called. For example, if the user wants to have an extra 3 values that represent \"direction\", then the direction has to be rotated along with all the data or coordinate systems can get lost. The anotations are specified by putting: somewhere in the string. The s can be: , , ,  If , the first value is expected to be the unique id of the ik type (GetType()&IKP_UniqueIdMask). The other values can be computed from IkParameterization::GetValues\\ *Parameters*\n     ``name`` - \n      Describes the type of data, cannot contain spaces or new lines. \n     ``values`` - \n      the values representing the data \\ *Exceptions*\n     ``openrave_exception`` - \n      throws if the name is invalid\n    \n            ";
m["en function IkParameterization SetCustomValue"] = "\n\nvoid  **SetCustomValue**\\(const std::string & name, dReal value)\n    \n    sets named custom data in the ik parameterization (\n    \n    *See*\n        SetCustomValues) \n        ";
m["en function IkParameterization ClearCustomValues"] = "\n\nsize_t  **ClearCustomValues**\\(const std::string & name = std::string() )\n    \n    clears custom data\n    \n    *Parameters*\n     ``name`` - \n      if name is empty, will clear all the data, otherwise will clear only the custom data with that name\n    \n    *Return*\n        number of elements erased \n        ";
m["en function InterfaceBase SendCommand"] = "\n\nbool  **SendCommand**\\(std::ostream & os, std::istream & is)\n    \n    Used to send special commands to the interface and receive output.\n    \n    The command must be registered by RegisterCommand. A special command ' is always supported and provides a way for the user to query the current commands and the help string. The format of the returned help commands are in reStructuredText. The following commands are possible:\n    *Parameters*\n     ``is`` - \n      the input stream containing the command \n     ``os`` - \n      the output stream containing the output \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if the command is not supported.\n    \n    *Return*\n        true if the command is successfully processed, otherwise false. \n        ";
m["en function InterfaceBase GetInterfaceType"] = "\n\nInterfaceType  **GetInterfaceType**\\()\n    \n            ";
m["en function InterfaceBase GetXMLId"] = "\n\nconst std::string &  **GetXMLId**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the unique identifier that describes this class type, case is ignored should be the same id used to create the object \n        ";
m["en function InterfaceBase GetPluginName"] = "\n\nconst std::string &  **GetPluginName**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the pluginname this interface was loaded from \n        ";
m["en function InterfaceBase GetDescription"] = "\n\nconst std::string &  **GetDescription**\\()\n    \n    Documentation of the interface in reStructuredText format. See Documenting Interfaces.\n    \n            ";
m["en function InterfaceBase SetDescription"] = "\n\nvoid  **SetDescription**\\(const std::string & description)\n    \n            ";
m["en function InterfaceBase GetEnv"] = "\n\nEnvironmentBasePtr  **GetEnv**\\()\n    \n    *Return*\n        the environment that this interface is attached to \n        ";
m["en function InterfaceBase Clone"] = "\n\nvoid  **Clone**\\(InterfaceBaseConstPtr preference, int cloningoptions)\n    \n    Clone the contents of an interface to the current interface.\n    \n    *Parameters*\n     ``preference`` - \n      the interface whose information to clone \n     ``cloningoptions`` - \n      mask of CloningOptions \\ *Exceptions*\n     ``openrave_exception`` - \n      if command doesn't succeed\n    \n            ";
m["en function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["en function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["en function InterfaceBase GetUserData"] = "\n\nUserDataPtr  **GetUserData**\\()\n    \n    return the user custom data\n    \n            ";
m["en function InterfaceBase GetReadableInterfaces"] = "\n\nconst  READERSMAP  &  **GetReadableInterfaces**\\()\n    \n            ";
m["en function InterfaceBase SetReadableInterface"] = "\n\nXMLReadablePtr  **SetReadableInterface**\\(const std::string & xmltag, XMLReadablePtr readable)\n    \n    set a new readable interface and return the previously set interface if it exists\n    \n            ";
m["en function EnvironmentBase Reset"] = "\n\nvoid  **Reset**\\()\n    \n    Resets all objects of the scene (preserves all problems, planners).\n    \n    Do not call inside a SimulationStep call         ";
m["en function EnvironmentBase Destroy"] = "\n\nvoid  **Destroy**\\()\n    \n    Releases all environment resources, should be always called when environment stops being used.\n    \n    Removing all environment pointer might not be enough to destroy the environment resources.         ";
m["en function EnvironmentBase CloneSelf"] = "\n\nEnvironmentBasePtr  **CloneSelf**\\(int options)\n    \n    Create and return a clone of the current environment.\n    \n    *Parameters*\n     ``options`` - \n      A set of CloningOptions describing what is actually cloned. Clones do not share any memory or resource between each other. or their parent making them ideal for performing separte planning experiments while keeping the parent environment unchanged. By default a clone only copies the collision checkers and physics engine. When bodies are cloned, the unique ids are preserved across environments (each body can be referenced with its id in both environments). The attached and grabbed bodies of each body/robot are also copied to the new environment.\n    \n    *Return*\n        An environment of the same type as this environment containing the copied information. \n        ";
m["en function EnvironmentBase Clone"] = "\n\nvoid  **Clone**\\(EnvironmentBaseConstPtr preference, int cloningoptions)\n    \n    Clones the reference environment into the current environment.\n    \n    *Parameters*\n     ``cloningoptions`` - \n      The parts of the environment to clone. Parts not specified are left as is. Tries to preserve computation by re-using bodies/interfaces that are already similar between the current and reference environments. \n            ";
m["en function EnvironmentBase SetCollisionChecker"] = "\n\nbool  **SetCollisionChecker**\\(CollisionCheckerBasePtr pchecker)\n    \n    set the global environment collision checker\n    \n            ";
m["en function EnvironmentBase GetCollisionChecker"] = "\n\nCollisionCheckerBasePtr  **GetCollisionChecker**\\()\n    \n            ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, KinBodyConstPtr pbody2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, KinBodyConstPtr pbody2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink1, KinBody::LinkConstPtr plink2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink1, KinBody::LinkConstPtr plink2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr) \n        ";
m["en function EnvironmentBase LoadURI"] = "\n\nbool  **LoadURI**\\(const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from a URI and adds all objects in the environment.\n    \n    Currently only collada files are supported. Options are passed through to          ";
m["en function EnvironmentBase Load"] = "\n\nbool  **Load**\\(const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from a file and adds all objects in the environment.\n    \n    For collada readers, the options are passed through to          ";
m["en function EnvironmentBase Load"] = "\n\nbool  **Load**\\(const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from a file and adds all objects in the environment.\n    \n    For collada readers, the options are passed through to          ";
m["en function EnvironmentBase LoadData"] = "\n\nbool  **LoadData**\\(const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from in-memory data and adds all objects in the environment.\n    \n            ";
m["en function EnvironmentBase LoadData"] = "\n\nbool  **LoadData**\\(const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from in-memory data and adds all objects in the environment.\n    \n            ";
m["en function EnvironmentBase Save"] = "\n\nvoid  **Save**\\(const std::string & filename, SelectionOptions options = SO_Everything , const  AttributesList  & atts = AttributesList () )\n    \n    Saves a scene depending on the filename extension. Default is in COLLADA format.\n    \n    *Parameters*\n     ``filename`` - \n      the filename to save the results at \n     ``options`` - \n      controls what to save \n     ``atts`` - \n      attributes that refine further options. For collada parsing, the options are passed through  Several default options are:\n      \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to save anything\n    \n            ";
m["en function EnvironmentBase ReadRobotURI \"const std::string\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(const std::string & filename)\n    \n    Creates a new robot from a file with no extra load options specified.\n    \n            ";
m["en function EnvironmentBase ReadRobotURI \"const std::string\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(const std::string & filename)\n    \n    Creates a new robot from a file with no extra load options specified.\n    \n            ";
m["en function EnvironmentBase ReadRobotURI \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(RobotBasePtr robot, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a robot from a resource file. The robot is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. \n            ";
m["en function EnvironmentBase ReadRobotURI \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(RobotBasePtr robot, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a robot from a resource file. The robot is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. \n            ";
m["en function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadKinBodyURI \"const std::string\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(const std::string & filename)\n    \n    Creates a new kinbody from an XML file with no extra load options specified.\n    \n            ";
m["en function EnvironmentBase ReadKinBodyURI \"const std::string\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(const std::string & filename)\n    \n    Creates a new kinbody from an XML file with no extra load options specified.\n    \n            ";
m["en function EnvironmentBase ReadKinBodyURI \"KinBody; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(KinBodyPtr body, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from a resource file. The body is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. \n            ";
m["en function EnvironmentBase ReadKinBodyURI \"KinBody; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(KinBodyPtr body, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from a resource file. The body is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. \n            ";
m["en function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["en function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["en function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["en function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["en function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["en function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["en function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["en function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["en function EnvironmentBase Add"] = "\n\nvoid  **Add**\\(InterfaceBasePtr pinterface, bool bAnonymous = false , const std::string & cmdargs = \"\" )\n    \n    Add an interface to the environment.\n    \n    *Parameters*\n     ``pinterface`` - \n      the pointer to an initialized interface \n     ``bAnonymous`` - \n      if true and there exists a body/robot with the same name, will make body's name unique \n     ``cmdargs`` - \n      The command-line arguments for the module. \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if interface is invalid or already added Depending on the type of interface, the addition behaves differently. For bodies/robots, will add them to visual/geometric environment. For modules, will call their main() method and add them officially. For viewers, will attach a viewer to the environment and start sending it data. For interfaces that don't make sense to add, will throw an exception.\n    \n            ";
m["en function EnvironmentBase AddKinBody"] = "\n\nvoid  **AddKinBody**\\(KinBodyPtr body, bool bAnonymous = false )\n    \n            ";
m["en function EnvironmentBase AddKinBody"] = "\n\nvoid  **AddKinBody**\\(KinBodyPtr body, bool bAnonymous = false )\n    \n            ";
m["en function EnvironmentBase AddRobot"] = "\n\nvoid  **AddRobot**\\(RobotBasePtr robot, bool bAnonymous = false )\n    \n            ";
m["en function EnvironmentBase AddRobot"] = "\n\nvoid  **AddRobot**\\(RobotBasePtr robot, bool bAnonymous = false )\n    \n            ";
m["en function EnvironmentBase AddSensor"] = "\n\nvoid  **AddSensor**\\(SensorBasePtr sensor, bool bAnonymous = false )\n    \n            ";
m["en function EnvironmentBase AddSensor"] = "\n\nvoid  **AddSensor**\\(SensorBasePtr sensor, bool bAnonymous = false )\n    \n            ";
m["en function EnvironmentBase AddViewer"] = "\n\nvoid  **AddViewer**\\(ViewerBasePtr pviewer)\n    \n            ";
m["en function EnvironmentBase RemoveKinBody"] = "\n\nbool  **RemoveKinBody**\\(KinBodyPtr pbody)\n    \n    remove body from sensory system. If bDestroy is true, will also deallocate the memory\n    \n            ";
m["en function EnvironmentBase Remove"] = "\n\nbool  **Remove**\\(InterfaceBasePtr obj)\n    \n    Removes a currently loaded interface from the environment.\n    \n    *Parameters*\n     ``obj`` - \n      interface to remove The function removes currently loaded bodies, robots, sensors, problems from the actively used interfaces of the environment. This does not destroy the interface, but it does remove all references managed. Some interfaces like problems have destroy methods that are called to signal unloading. Note that the active interfaces are different from the owned interfaces.\n    \n    *Return*\n        true if the interface was successfully removed from the environment. \n        ";
m["en function EnvironmentBase GetKinBody"] = "\n\nKinBodyPtr  **GetKinBody**\\(const std::string & name)\n    \n    Query a body from its name.\n    \n    *Return*\n        first KinBody (including robots) that matches with name \n        ";
m["en function EnvironmentBase GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\(const std::string & name)\n    \n    Query a robot from its name.\n    \n    *Return*\n        first Robot that matches the name \n        ";
m["en function EnvironmentBase GetSensor"] = "\n\nSensorBasePtr  **GetSensor**\\(const std::string & name)\n    \n    Query a sensor from its name.\n    \n    *Return*\n        first sensor that matches with name, note that sensors attached to robots have the robot name as a prefix. \n        ";
m["en function EnvironmentBase GetBodyFromEnvironmentId"] = "\n\nKinBodyPtr  **GetBodyFromEnvironmentId**\\(int id)\n    \n    Get the corresponding body from its unique network id.\n    \n            ";
m["en function EnvironmentBase AddModule"] = "\n\nint  **AddModule**\\(ModuleBasePtr module, const std::string & cmdargs)\n    \n    Load a new module, need to Lock if calling outside simulation thread.\n    \n            ";
m["en function EnvironmentBase AddModule"] = "\n\nint  **AddModule**\\(ModuleBasePtr module, const std::string & cmdargs)\n    \n    Load a new module, need to Lock if calling outside simulation thread.\n    \n            ";
m["en function EnvironmentBase GetModules"] = "\n\nvoid  **GetModules**\\(std::list<  ModuleBasePtr  > & listModules, uint64_t timeout = 0 )\n    \n    Fills a list with the loaded modules in the environment.\n    \n    *Parameters*\n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code A separate  is locked for reading the modules. If the environment is locked, the modules are guaranteed to stay loaded in the environment.\n    \n            ";
m["en function EnvironmentBase GetModules"] = "\n\nvoid  **GetModules**\\(std::list<  ModuleBasePtr  > & listModules, uint64_t timeout = 0 )\n    \n    Fills a list with the loaded modules in the environment.\n    \n    *Parameters*\n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code A separate  is locked for reading the modules. If the environment is locked, the modules are guaranteed to stay loaded in the environment.\n    \n            ";
m["en function EnvironmentBase SetPhysicsEngine"] = "\n\nbool  **SetPhysicsEngine**\\(PhysicsEngineBasePtr physics)\n    \n    *Parameters*\n     ``physics`` - \n      the engine to set, if NULL, environment sets an dummy physics engine set the physics engine, disabled by default \n            ";
m["en function EnvironmentBase GetPhysicsEngine"] = "\n\nPhysicsEngineBasePtr  **GetPhysicsEngine**\\()\n    \n            ";
m["en function EnvironmentBase RegisterCollisionCallback"] = "\n\nUserDataPtr  **RegisterCollisionCallback**\\(const  CollisionCallbackFn  & callback)\n    \n    Register a collision callback.Whenever a collision is detected between between bodies during a CheckCollision call or physics simulation, the callback is called. The callback should return an action specifying how the collision should be handled:\n    \n    *Return*\n        a handle to the registration, once the handle loses scope, the callback is unregistered \n        ";
m["en function EnvironmentBase StepSimulation"] = "\n\nvoid  **StepSimulation**\\(dReal timeStep)\n    \n    Makes one simulation time step.\n    \n    Can be called manually by the user inside planners. Keep in mind that the internal simulation thread also calls this function periodically. See Simulation Thread for more about the simulation thread.         ";
m["en function EnvironmentBase StartSimulation"] = "\n\nvoid  **StartSimulation**\\(dReal fDeltaTime, bool bRealTime = true )\n    \n    Start the internal simulation thread.\n    \n    Resets simulation time to 0. See Simulation Thread for more about the simulation thread.\\ *Parameters*\n     ``fDeltaTime`` - \n      the delta step to take in simulation \n     ``bRealTime`` - \n      if false will call SimulateStep as fast as possible, otherwise will time the simulate step calls so that simulation progresses with real system time. \n            ";
m["en function EnvironmentBase StopSimulation"] = "\n\nvoid  **StopSimulation**\\()\n    \n    Stops the internal physics loop, stops calling SimulateStep for all modules.\n    \n    See Simulation Thread for more about the simulation thread.         ";
m["en function EnvironmentBase GetSimulationTime"] = "\n\nuint64_t  **GetSimulationTime**\\()\n    \n    Return simulation time since the start of the environment (in microseconds).\n    \n    See Simulation Thread for more about the simulation thread.         ";
m["en function EnvironmentBase GetViewer"] = "\n\nViewerBasePtr  **GetViewer**\\(const std::string & name = \"\" )\n    \n    Return a viewer with a particular name.\n    \n    When no name is specified, the first loaded viewer is returned.         ";
m["en function EnvironmentBase drawlinestrip \"const float; int; int; float; const float\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawlinestrip**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a series of connected lines with individual colors.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawlinelist \"const float; int; int; float; const float\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawlinelist**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a list of individual lines, each specified by a succeeding pair of points.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawarrow"] = "\n\nOpenRAVE::GraphHandlePtr  **drawarrow**\\(const RaveVector< float > & p1, const RaveVector< float > & p2, float fwidth, const RaveVector< float > & color = RaveVector< float >(1, 0.5, 0.5, 1) )\n    \n    Draws an arrow p1 is start, p2 is finish.\n    \n    *Parameters*\n     ``color`` - \n      the rgb color of the point. The last component of the color is used for alpha blending.\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawbox"] = "\n\nOpenRAVE::GraphHandlePtr  **drawbox**\\(const RaveVector< float > & vpos, const RaveVector< float > & vextents)\n    \n    Draws a box.\n    \n    extents are half the width, height, and depth of the box\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawplane"] = "\n\nOpenRAVE::GraphHandlePtr  **drawplane**\\(const  RaveTransform < float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawplane"] = "\n\nOpenRAVE::GraphHandlePtr  **drawplane**\\(const  RaveTransform < float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawtrimesh \"const float; int; const int; int; const boost::multi_array\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawtrimesh**\\(const float * ppoints, int stride, const int * pIndices, int numTriangles, const boost::multi_array< float, 2 > & colors)\n    \n    Draws a triangle mesh, each vertices of each triangle should be counter-clockwise.\n    \n    *Parameters*\n     ``ppoints`` - \n      - array of 3D points \n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride) \n     ``pIndices`` - \n      If not NULL, zero-based indices into the points for every triangle. pIndices should be of size numTriangles. If pIndices is NULL, ppoints is assumed to contain numTriangles*3 points and triangles will be rendered in list order. \n     ``color`` - \n      The color of the triangle. The last component of the color is used for alpha blending\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase GetRobots"] = "\n\nvoid  **GetRobots**\\(std::vector<  RobotBasePtr  > & robots, uint64_t timeout = 0 )\n    \n    Fill an array with all robots loaded in the environment.\n    \n    *Parameters*\n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code A separate  is locked for reading the bodies.\n    \n            ";
m["en function EnvironmentBase GetBodies"] = "\n\nvoid  **GetBodies**\\(std::vector<  KinBodyPtr  > & bodies, uint64_t timeout = 0 )\n    \n    Get all bodies loaded in the environment (including robots).\n    \n    *Parameters*\n     ``bodies`` - \n      filled with all the bodies \n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code A separate  is locked for reading the bodies.\n    \n            ";
m["en function EnvironmentBase GetSensors"] = "\n\nvoid  **GetSensors**\\(std::vector<  SensorBasePtr  > & sensors, uint64_t timeout = 0 )\n    \n    Fill an array with all sensors loaded in the environment.\n    \n    *Parameters*\n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code The sensors come from the currently loaded robots and the explicitly added sensors\n    \n            ";
m["en function EnvironmentBase UpdatePublishedBodies"] = "\n\nvoid  **UpdatePublishedBodies**\\(uint64_t timeout = 0 )\n    \n    Updates the published bodies that viewers and other programs listening in on the environment see.\n    \n    *Parameters*\n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code For example, calling this function inside a planning loop allows the viewer to update the environment reflecting the status of the planner. Assumes that the physics are locked.\n    \n            ";
m["en function EnvironmentBase Triangulate"] = "\n\nvoid  **Triangulate**\\(KinBody::Link::TRIMESH  & trimesh, KinBodyConstPtr pbody)\n    \n    Triangulation of the body including its current transformation. trimesh will be appended the new data.\n    \n    *Parameters*\n     ``trimesh`` - \n      - The output triangle mesh \n     ``body`` - \n      body the triangulate \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to add anything\n    \n            ";
m["en function EnvironmentBase TriangulateScene"] = "\n\nvoid  **TriangulateScene**\\(KinBody::Link::TRIMESH  & trimesh, SelectionOptions options, const std::string & selectname)\n    \n    General triangulation of the whole scene.\n    \n    *Parameters*\n     ``trimesh`` - \n      - The output triangle mesh. The new triangles are appended to the existing triangles! \n     ``options`` - \n      - Controlls what to triangulate. \n     ``selectname`` - \n      - name of the body used in options \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to add anything\n    \n            ";
m["en function EnvironmentBase SetDebugLevel"] = "\n\nvoid  **SetDebugLevel**\\(int level)\n    \n    *Parameters*\n     ``level`` - \n      0 for no debug, 1 - to print all debug messeges. Default value for release builds is 0, for debug builds it is 1 declaring variables with stdcall can be a little complex sets the debug level \n            ";
m["en function EnvironmentBase GetDebugLevel"] = "\n\nint  **GetDebugLevel**\\()\n    \n            ";
m["en function EnvironmentBase GetHomeDirectory"] = "\n\nstd::string  **GetHomeDirectory**\\()\n    \n            ";
m["en function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["en function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["en function InterfaceBase GetUserData"] = "\n\nUserDataPtr  **GetUserData**\\()\n    \n    return the user custom data\n    \n            ";
m["en function RaveGetEnvironmentId"] = "\n\nOPENRAVE_API  int  **RaveGetEnvironmentId**\\(EnvironmentBasePtr penv)\n    \n    return the environment's unique id, returns 0 if environment could not be found or not registered\n    \n            ";
m["en function RaveGetEnvironment"] = "\n\nOPENRAVE_API   EnvironmentBasePtr  **RaveGetEnvironment**\\(int id)\n    \n    get the environment from its unique id\n    \n    *Parameters*\n     ``id`` - \n      the unique environment id returned by RaveGetEnvironmentId \n            ";
m["en function RaveGetEnvironments"] = "\n\nOPENRAVE_API  void  **RaveGetEnvironments**\\(std::list<  EnvironmentBasePtr  > & listenvironments)\n    \n    Return all the created OpenRAVE environments.\n    \n            ";
m["en function RaveCreateInterface"] = "\n\nOPENRAVE_API   InterfaceBasePtr  **RaveCreateInterface**\\(EnvironmentBasePtr penv, InterfaceType type, const std::string & interfacename)\n    \n            ";
m["en function IkSolverBase GetNumFreeParameters"] = "\n\nint  **GetNumFreeParameters**\\()\n    \n    Number of free parameters defining the null solution space.\n    \n    Each parameter is always in the range of [0,1].         ";
m["en function IkSolverBase GetFreeParameters"] = "\n\nbool  **GetFreeParameters**\\(std::vector<  dReal  > & vFreeParameters)\n    \n    gets the free parameters from the current robot configuration\n    \n    *Parameters*\n     ``vFreeParameters`` - \n      is filled with GetNumFreeParameters() parameters in [0,1] range\n    \n    *Return*\n        true if succeeded \n        ";
m["en function IkSolverBase Supports"] = "\n\nbool  **Supports**\\(IkParameterizationType iktype)\n    \n    returns true if the solver supports a particular ik parameterization as input.\n    \n            ";
m["en function IkSolverBase RegisterCustomFilter"] = "\n\nUserDataPtr  **RegisterCustomFilter**\\(int priority, const  IkFilterCallbackFn  & filterfn)\n    \n    Sets an ik solution filter that is called for every ik solution.\n    \n    *Parameters*\n     ``priority`` - \n      - The priority of the filter that controls the order in which filters get called. Higher priority filters get called first. If not certain what to set, use 0. \n     ``filterfn`` - \n      - an optional filter function to be called, see IkFilterCallbackFn. Multiple filters can be set at once, each filter will be called according to its priority; higher values get called first. The default implementation of IkSolverBase manages the filters internally. Users implementing their own IkSolverBase should call _CallFilters to run the internally managed filters.\n    \n    *Return*\n        a managed handle to the filter. If this handle is released, then the fitler will be removed. Release operation is . \n        ";
m["en function RaveCreateIkSolver"] = "\n\nOPENRAVE_API   IkSolverBasePtr  **RaveCreateIkSolver**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function ControllerBase Init"] = "\n\nbool  **Init**\\(RobotBasePtr robot, const std::vector< int > & dofindices, int nControlTransformation)\n    \n    initializes the controller and specifies the controlled dof\n    \n    *Parameters*\n     ``robot`` - \n      the robot that uses the controller \n     ``dofindices`` - \n      the indices that controller will have exclusive access to \n     ``nControlTransformation`` -\n    \n    *See*\n        IsControlTransformation\n\n    *Return*\n        true on successful initialization \n        ";
m["en function ControllerBase Init"] = "\n\nbool  **Init**\\(RobotBasePtr robot, const std::vector< int > & dofindices, int nControlTransformation)\n    \n    initializes the controller and specifies the controlled dof\n    \n    *Parameters*\n     ``robot`` - \n      the robot that uses the controller \n     ``dofindices`` - \n      the indices that controller will have exclusive access to \n     ``nControlTransformation`` -\n    \n    *See*\n        IsControlTransformation\n\n    *Return*\n        true on successful initialization \n        ";
m["en function ControllerBase GetControlDOFIndices"] = "\n\nconst std::vector< int > &  **GetControlDOFIndices**\\()\n    \n    returns the dof indices controlled\n    \n            ";
m["en function ControllerBase IsControlTransformation"] = "\n\nint  **IsControlTransformation**\\()\n    \n    returns non-zero value if base affine transformation is controlled.\n    \n    Only one controller can modify translation and orientation per robot. For now, the two cannot be divided.         ";
m["en function ControllerBase GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\()\n    \n            ";
m["en function ControllerBase Reset"] = "\n\nvoid  **Reset**\\(int options = 0 )\n    \n    Resets the current controller trajectories and any other state associated with the robot.\n    \n    *Parameters*\n     ``options`` - \n      - specific options that can be used to control what to reset \n            ";
m["en function ControllerBase SetDesired"] = "\n\nbool  **SetDesired**\\(const std::vector<  dReal  > & values, TransformConstPtr trans = TransformConstPtr () )\n    \n    go to a specific position in configuration space.\n    \n    *Parameters*\n     ``values`` - \n      the final configuration in the control dofs \n     ``trans`` - \n      the transformation of the base. If not specified will use the current robot transformation. Ignored if controller does not use it\n    \n    *Return*\n        true if position operation successful. \n        ";
m["en function ControllerBase SetDesired"] = "\n\nbool  **SetDesired**\\(const std::vector<  dReal  > & values, TransformConstPtr trans = TransformConstPtr () )\n    \n    go to a specific position in configuration space.\n    \n    *Parameters*\n     ``values`` - \n      the final configuration in the control dofs \n     ``trans`` - \n      the transformation of the base. If not specified will use the current robot transformation. Ignored if controller does not use it\n    \n    *Return*\n        true if position operation successful. \n        ";
m["en function ControllerBase SetPath"] = "\n\nbool  **SetPath**\\(TrajectoryBaseConstPtr ptraj)\n    \n    Follow a path in configuration space, adds to the queue of trajectories already in execution.\n    \n    *Parameters*\n     ``ptraj`` - \n      - the trajectory\n    \n    *Return*\n        true if trajectory operation successful \n        ";
m["en function ControllerBase SimulationStep \"dReal\""] = "\n\nvoid  **SimulationStep**\\(dReal fTimeElapsed)\n    \n    Simulate one step forward for controllers running in the simulation environment.\n    \n    *Parameters*\n     ``fTimeElapsed`` - \n      - time elapsed in simulation environment since last frame \n            ";
m["en function ControllerBase IsDone"] = "\n\nbool  **IsDone**\\()\n    \n    Return true when goal reached.\n    \n    If a trajectory was set, return only when trajectory is done. If SetDesired was called, return only when robot is is at the desired location. If SendCommand sent, returns true when the command was completed by the hand.         ";
m["en function ControllerBase GetTime"] = "\n\ndReal  **GetTime**\\()\n    \n    return the time along the current command\n    \n            ";
m["en function ControllerBase GetVelocity"] = "\n\nvoid  **GetVelocity**\\(std::vector<  dReal  > & vel)\n    \n    get velocity of the controlled DOFs\n    \n    *Parameters*\n     ``vel`` - \n      [out] - current velocity of robot from the dof \n            ";
m["en function ControllerBase GetTorque"] = "\n\nvoid  **GetTorque**\\(std::vector<  dReal  > & torque)\n    \n    *Parameters*\n     ``torque`` - \n      [out] - returns the current torque/current/strain exerted by each of the dofs from outside forces. The feedforward and friction terms should be subtracted out already get torque/current/strain values \n            ";
m["en function RaveCreateController"] = "\n\nOPENRAVE_API   ControllerBasePtr  **RaveCreateController**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function PhysicsEngineBase GetPhysicsOptions"] = "\n\nint  **GetPhysicsOptions**\\()\n    \n            ";
m["en function PhysicsEngineBase SetPhysicsOptions \"int\""] = "\n\nbool  **SetPhysicsOptions**\\(int physicsoptions)\n    \n    Set basic physics engine using the PhysicsEngineOptions enum.\n    \n            ";
m["en function PhysicsEngineBase InitEnvironment"] = "\n\nbool  **InitEnvironment**\\()\n    \n    called when environment sets this physics engine, engine assumes responsibility for KinBody::_pPhysicsData\n    \n            ";
m["en function PhysicsEngineBase DestroyEnvironment"] = "\n\nvoid  **DestroyEnvironment**\\()\n    \n    called when environment switches to a different physics engine has to clear/deallocate any memory associated with KinBody::_pPhysicsData         ";
m["en function PhysicsEngineBase InitKinBody"] = "\n\nbool  **InitKinBody**\\(KinBodyPtr body)\n    \n    notified when a new body has been initialized in the environment\n    \n            ";
m["en function PhysicsEngineBase SetLinkVelocity"] = "\n\nbool  **SetLinkVelocity**\\(KinBody::LinkPtr link, const  Vector  & linearvel, const  Vector  & angularvel)\n    \n    Force the body velocity of a link, velocities correspond to the link's coordinate system origin.\n    \n    *Parameters*\n     ``link`` - \n      link to set velocities. \n     ``linearvel`` - \n      linear velocity of base link \n     ``angularvel`` - \n      angular velocity rotation_axis*theta_dot \n            ";
m["en function PhysicsEngineBase SetLinkVelocities"] = "\n\nbool  **SetLinkVelocities**\\(KinBodyPtr body, const std::vector< std::pair<  Vector ,  Vector  > > & velocities)\n    \n    Sets the velocities for each link, velocities correspond to the link's coordinate system origin.\n    \n    *Parameters*\n     ``body`` - \n      the body to query velocities from. \n     ``velocities`` - \n      sets the linear and angular (axis * angular_speed) velocities for each link \n            ";
m["en function PhysicsEngineBase GetLinkVelocity"] = "\n\nbool  **GetLinkVelocity**\\(KinBody::LinkConstPtr link, Vector  & linearvel, Vector  & angularvel)\n    \n    Gets the velocity of a link, velocities correspond to the link's coordinate system origin.\n    \n    *Parameters*\n     ``linearvel`` - \n      - linear velocity of base link \n     ``angularvel`` - \n      - angular velocity rotation_axis*theta_dot \n            ";
m["en function PhysicsEngineBase GetLinkVelocities"] = "\n\nbool  **GetLinkVelocities**\\(KinBodyConstPtr body, std::vector< std::pair<  Vector ,  Vector  > > & velocities)\n    \n    Sets the velocities for each link, velocities correspond to the link's coordinate system origin.\n    \n    *Parameters*\n     ``velocities`` - \n      the linear and angular (axis * angular_speed) velocities for each link. \n            ";
m["en function PhysicsEngineBase SetBodyForce"] = "\n\nbool  **SetBodyForce**\\(KinBody::LinkPtr link, const  Vector  & force, const  Vector  & position, bool bAdd)\n    \n    *Parameters*\n     ``force`` - \n      the direction and magnitude of the force \n     ``position`` - \n      in the world where the force is getting applied \n     ``bAdd`` - \n      if true, force is added to previous forces, otherwise it is set add a force at a particular position in a link \n            ";
m["en function PhysicsEngineBase SetBodyTorque"] = "\n\nbool  **SetBodyTorque**\\(KinBody::LinkPtr link, const  Vector  & torque, bool bAdd)\n    \n    *Parameters*\n     ``link`` - \n      the link to add a torque to \n     ``torque`` - \n      torque vector \n     ``bAdd`` - \n      if true, torque is added to previous torques, otherwise it is set adds torque to a body (absolute coords) \n            ";
m["en function PhysicsEngineBase AddJointTorque"] = "\n\nbool  **AddJointTorque**\\(KinBody::JointPtr pjoint, const std::vector<  dReal  > & pTorques)\n    \n    *Parameters*\n     ``pjoint`` - \n      - the joint the torque is added to \n     ``pTorques`` - \n      - the torques added to the joint. Pointer because the joint dof can be greater than 1. adds torque to a joint \n            ";
m["en function PhysicsEngineBase GetLinkForceTorque"] = "\n\nbool  **GetLinkForceTorque**\\(KinBody::LinkConstPtr link, Vector  & force, Vector  & torque)\n    \n    *Parameters*\n     ``link`` - \n      a constant pointer to a link \n     ``force`` - \n      current force on the COM of the link \n     ``torque`` - \n      current torque on the COM of the link \n            ";
m["en function PhysicsEngineBase SetGravity"] = "\n\nvoid  **SetGravity**\\(const  Vector  & gravity)\n    \n    set the gravity direction\n    \n    *Parameters*\n     ``joint`` -\n      \n     ``force`` - \n      current accumulated force on the COM of the link \n     ``torque`` - \n      current accumulated torque on the COM of the link \n            ";
m["en function PhysicsEngineBase GetGravity"] = "\n\nVector  **GetGravity**\\()\n    \n            ";
m["en function PhysicsEngineBase SimulateStep"] = "\n\nvoid  **SimulateStep**\\(dReal fTimeElapsed)\n    \n    dynamically simulate system for fTimeElapsed seconds add torques to the joints of the body. Torques disappear after one timestep of simulation         ";
m["en function RaveCreatePhysicsEngine"] = "\n\nOPENRAVE_API   PhysicsEngineBasePtr  **RaveCreatePhysicsEngine**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function RaveCreateModule"] = "\n\nOPENRAVE_API   ModuleBasePtr  **RaveCreateModule**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function RaveCreateModule"] = "\n\nOPENRAVE_API   ModuleBasePtr  **RaveCreateModule**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function RaveCreateModule"] = "\n\nOPENRAVE_API   ModuleBasePtr  **RaveCreateModule**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function SpaceSamplerBase SetSeed"] = "\n\nvoid  **SetSeed**\\(uint32_t seed)\n    \n    sets a new seed. For sequence samplers, the seed describes the n^th sample to begin at.\n    \n            ";
m["en function SpaceSamplerBase SetSpaceDOF"] = "\n\nvoid  **SetSpaceDOF**\\(int dof)\n    \n    Sets the degrees of freedom of the space (note this is different from the parameterization dimension)\n    \n            ";
m["en function SpaceSamplerBase GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    returns the degrees of freedom of the sampling space\n    \n            ";
m["en function SpaceSamplerBase GetNumberOfValues"] = "\n\nint  **GetNumberOfValues**\\()\n    \n    Dimension of the return samples.\n    \n    Number of values used to represent the parameterization of the space (>= dof). For example, let a quaternion describe a 3D rotation. The DOF of the space is 3, while the dimension of the returned samples is 4.         ";
m["en function SpaceSamplerBase Supports"] = "\n\nbool  **Supports**\\(SampleDataType type)\n    \n            ";
m["en function SpaceSamplerBase GetLimits"] = "\n\nvoid  **GetLimits**\\(std::vector<  dReal  > & vLowerLimit, std::vector<  dReal  > & vUpperLimit)\n    \n    returns the minimum and maximum values returned for each dimension (size is GetNumberOfValues())\n    \n    By default the limits should be in [0,1]^N.         ";
m["en function SpaceSamplerBase SampleSequence \"std::vector; size_t; IntervalType\""] = "\n\nvoid  **SampleSequence**\\(std::vector<  dReal  > & samples, size_t num = 1 , IntervalType interval = IT_Closed )\n    \n    sequentially sampling returning the next 'num' samples\n    \n    *Parameters*\n     ``sample`` - \n      the values of the samples. This is a num*GetNumberOfValues() array. \n     ``num`` - \n      number of samples to return \n     ``interval`` - \n      the sampling intervel for each of the dimensions. The sampler can fail by returning an array of size 0. \n            ";
m["en function SpaceSamplerBase SampleSequence \"std::vector; size_t\""] = "\n\nvoid  **SampleSequence**\\(std::vector< uint32_t > & sample, size_t num = 1 )\n    \n    sequentially sampling returning the next 'num' samples\n    \n    *Parameters*\n     ``sample`` - \n      the values of the samples. This is a num*GetNumberOfValues() array. \n     ``num`` - \n      number of samples to return The sampler can fail by returning an array of size 0. \n            ";
m["en function SpaceSamplerBase SampleComplete \"std::vector; size_t; IntervalType\""] = "\n\nvoid  **SampleComplete**\\(std::vector<  dReal  > & samples, size_t num, IntervalType interval = IT_Closed )\n    \n    returns N samples that best approximate the entire sampling space.\n    \n    The sampler can fail by returning an array of size 0.         ";
m["en function SpaceSamplerBase SampleComplete \"std::vector; size_t\""] = "\n\nvoid  **SampleComplete**\\(std::vector< uint32_t > & samples, size_t num)\n    \n    returns N samples that best approximate the entire sampling space.\n    \n    The sampler can fail by returning an array of size 0.         ";
m["en function RaveCreateSpaceSampler"] = "\n\nOPENRAVE_API   SpaceSamplerBasePtr  **RaveCreateSpaceSampler**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function PlannerBase InitPlan \"RobotBasePtr; PlannerParametersConstPtr\""] = "\n\nbool  **InitPlan**\\(RobotBasePtr robot, PlannerParametersConstPtr params)\n    \n    Setup scene, robot, and properties of the plan, and reset all internal structures.\n    \n    *Parameters*\n     ``robot`` - \n      main robot to be used for planning \n     ``params`` - \n      The parameters of the planner, any class derived from PlannerParameters can be passed. The planner should copy these parameters for future instead of storing the pointer. \n            ";
m["en function PlannerBase InitPlan \"RobotBasePtr; std::istream\""] = "\n\nbool  **InitPlan**\\(RobotBasePtr robot, std::istream & isParameters)\n    \n    Setup scene, robot, and properties of the plan, and reset all structures with pparams.\n    \n    *Parameters*\n     ``robot`` - \n      main robot to be used for planning \n     ``isParameters`` - \n      The serialized form of the parameters. By default, this exists to allow third parties to pass information to planners without excplicitly knowning the format/internal structures used\n    \n    *Return*\n        true if plan is initialized successfully and initial conditions are satisfied. \n        ";
m["en function PlannerBase PlanPath"] = "\n\nPlannerStatus  **PlanPath**\\(TrajectoryBasePtr ptraj)\n    \n    Executes the main planner trying to solve for the goal condition.\n    \n    *Parameters*\n     ``ptraj`` - \n      The output trajectory the robot has to follow in order to successfully complete the plan. If this planner is a path optimizer, the trajectory can be used as an input for generating a smoother path. The trajectory is for the configuration degrees of freedom defined by the planner parameters. Fill ptraj with the trajectory of the planned path that the robot needs to execute\n    \n    *Return*\n        the status that the planner returned in. \n        ";
m["en function PlannerBase GetParameters"] = "\n\nPlannerParametersConstPtr  **GetParameters**\\()\n    \n    return the internal parameters of the planner\n    \n            ";
m["en function PlannerBase::PlannerParameters  SetRobotActiveJoints"] = "\n\nvoid  **SetRobotActiveJoints**\\(RobotBasePtr robot)\n    \n    sets up the planner parameters to use the active joints of the robot\n    \n            ";
m["en function PlannerBase::PlannerParameters  SetConfigurationSpecification"] = "\n\nvoid  **SetConfigurationSpecification**\\(EnvironmentBasePtr env, const  ConfigurationSpecification  & spec)\n    \n    sets up the planner parameters to use the configuration specification space\n    \n    The configuraiton groups should point to controllable target objects. By default, this includes:\n            ";
m["en function RaveCreatePlanner"] = "\n\nOPENRAVE_API   PlannerBasePtr  **RaveCreatePlanner**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function TrajectoryBase Init"] = "\n\nvoid  **Init**\\(const  ConfigurationSpecification  & spec)\n    \n            ";
m["en function TrajectoryBase Insert \"size_t; const std::vector; bool\""] = "\n\nvoid  **Insert**\\(size_t index, const std::vector<  dReal  > & data, bool bOverwrite = false )\n    \n    Sets/inserts new waypoints in the same configuration specification as the trajectory.\n    \n    *Parameters*\n     ``index`` - \n      The index where to start modifying the trajectory. \n     ``data`` - \n      The data to insert, can represent multiple consecutive waypoints. data.size()/GetConfigurationSpecification().GetDOF() waypoints are added. \n     ``bOverwrite`` - \n      If true, will overwrite the waypoints starting at index, and will insert new waypoints only if end of trajectory is reached. If false, will insert the points before index: a 0 index inserts the new data in the beginning, a GetNumWaypoints() index inserts the new data at the end. \n            ";
m["en function TrajectoryBase Insert \"size_t; const std::vector; bool\""] = "\n\nvoid  **Insert**\\(size_t index, const std::vector<  dReal  > & data, bool bOverwrite = false )\n    \n    Sets/inserts new waypoints in the same configuration specification as the trajectory.\n    \n    *Parameters*\n     ``index`` - \n      The index where to start modifying the trajectory. \n     ``data`` - \n      The data to insert, can represent multiple consecutive waypoints. data.size()/GetConfigurationSpecification().GetDOF() waypoints are added. \n     ``bOverwrite`` - \n      If true, will overwrite the waypoints starting at index, and will insert new waypoints only if end of trajectory is reached. If false, will insert the points before index: a 0 index inserts the new data in the beginning, a GetNumWaypoints() index inserts the new data at the end. \n            ";
m["en function TrajectoryBase Insert \"size_t; const std::vector; const ConfigurationSpecification; bool\""] = "\n\nvoid  **Insert**\\(size_t index, const std::vector<  dReal  > & data, const  ConfigurationSpecification  & spec, bool bOverwrite = false )\n    \n    Sets/inserts new waypoints in a  configuration specification.\n    \n    *Parameters*\n     ``index`` - \n      The index where to start modifying the trajectory. \n     ``data`` - \n      The data to insert, can represent multiple consecutive waypoints. data.size()/GetConfigurationSpecification().GetDOF() waypoints are added. \n     ``spec`` - \n      the specification in which the input data come in. Depending on what data is offered, some values of this trajectory's specification might not be initialized. \n     ``bOverwrite`` - \n      If true, will overwrite the waypoints starting at index, and will insert new waypoints only if end of trajectory is reached; if the input spec does not overwrite all the data of the trjectory spec, then the original trajectory data will not be overwritten. If false, will insert the points before index: a 0 index inserts the new data in the beginning, a GetNumWaypoints() index inserts the new data at the end. \n            ";
m["en function TrajectoryBase Insert \"size_t; const std::vector; const ConfigurationSpecification; bool\""] = "\n\nvoid  **Insert**\\(size_t index, const std::vector<  dReal  > & data, const  ConfigurationSpecification  & spec, bool bOverwrite = false )\n    \n    Sets/inserts new waypoints in a  configuration specification.\n    \n    *Parameters*\n     ``index`` - \n      The index where to start modifying the trajectory. \n     ``data`` - \n      The data to insert, can represent multiple consecutive waypoints. data.size()/GetConfigurationSpecification().GetDOF() waypoints are added. \n     ``spec`` - \n      the specification in which the input data come in. Depending on what data is offered, some values of this trajectory's specification might not be initialized. \n     ``bOverwrite`` - \n      If true, will overwrite the waypoints starting at index, and will insert new waypoints only if end of trajectory is reached; if the input spec does not overwrite all the data of the trjectory spec, then the original trajectory data will not be overwritten. If false, will insert the points before index: a 0 index inserts the new data in the beginning, a GetNumWaypoints() index inserts the new data at the end. \n            ";
m["en function TrajectoryBase Remove"] = "\n\nvoid  **Remove**\\(size_t startindex, size_t endindex)\n    \n    removes a number of waypoints starting at the specified index\n    \n            ";
m["en function TrajectoryBase Sample \"std::vector; dReal\""] = "\n\nvoid  **Sample**\\(std::vector<  dReal  > & data, dReal time)\n    \n    samples a data point on the trajectory at a particular time\n    \n    *Parameters*\n     ``data[out]`` - \n      the sampled point \n     ``time[in]`` - \n      the time to sample \n            ";
m["en function TrajectoryBase Sample \"std::vector; dReal; const ConfigurationSpecification\""] = "\n\nvoid  **Sample**\\(std::vector<  dReal  > & data, dReal time, const  ConfigurationSpecification  & spec)\n    \n    samples a data point on the trajectory at a particular time and returns data for the group specified.\n    \n    *Parameters*\n     ``data[out]`` - \n      the sampled point \n     ``time[in]`` - \n      the time to sample \n     ``spec[in]`` - \n      the specification format to return the data in The default implementation is slow, so interface developers should override it. \n            ";
m["en function TrajectoryBase GetConfigurationSpecification"] = "\n\nconst  ConfigurationSpecification  &  **GetConfigurationSpecification**\\()\n    \n            ";
m["en function TrajectoryBase GetNumWaypoints"] = "\n\nsize_t  **GetNumWaypoints**\\()\n    \n    return the number of waypoints\n    \n            ";
m["en function TrajectoryBase  GetWaypoints \"size_t; size_t; std::vector\""] = "\n\nvoid  **GetWaypoints**\\(size_t startindex, size_t endindex, std::vector<  dReal  > & data)\n    \n    return a set of waypoints in the range [startindex,endindex)\n    \n    *Parameters*\n     ``startindex[in]`` - \n      the start index of the waypoint (included) \n     ``endindex[in]`` - \n      the end index of the waypoint (not included) \n     ``data[out]`` - \n      the data of the waypoint \n            ";
m["en function TrajectoryBase  GetWaypoint \"int; std::vector\""] = "\n\nvoid  **GetWaypoint**\\(int index, std::vector<  dReal  > & data)\n    \n    returns one waypoint\n    \n    *Parameters*\n     ``index[in]`` - \n      index of the waypoint. If < 0, then counting starts from the last waypoint. For example GetWaypoints(-1,data) returns the last waypoint. \n     ``data[out]`` - \n      the data of the waypoint \n            ";
m["en function TrajectoryBase  GetWaypoint \"int; std::vector; const ConfigurationSpecification\""] = "\n\nvoid  **GetWaypoint**\\(int index, std::vector<  dReal  > & data, const  ConfigurationSpecification  & spec)\n    \n    returns one waypoint\n    \n    *Parameters*\n     ``index[in]`` - \n      index of the waypoint. If < 0, then counting starts from the last waypoint. For example GetWaypoints(-1,data) returns the last waypoint. \n     ``data[out]`` - \n      the data of the waypoint \n            ";
m["en function TrajectoryBase  GetDuration"] = "\n\ndReal  **GetDuration**\\()\n    \n    return the duration of the trajectory in seconds\n    \n            ";
m["en function TrajectoryBase serialize"] = "\n\nvoid  **serialize**\\(std::ostream & O, int options = 0 )\n    \n    output the trajectory in XML format\n    \n            ";
m["en function TrajectoryBase deserialize"] = "\n\nInterfaceBasePtr  **deserialize**\\(std::istream & I)\n    \n    initialize the trajectory\n    \n            ";
m["en function TrajectoryBase Write"] = "\n\nbool  **Write**\\(std::ostream & O, int options)\n    \n            ";
m["en function TrajectoryBase Read"] = "\n\nbool  **Read**\\(std::istream & I, RobotBaseConstPtr )\n    \n            ";
m["en function RaveCreateTrajectory"] = "\n\nOPENRAVE_API   TrajectoryBasePtr  **RaveCreateTrajectory**\\(EnvironmentBasePtr penv, const std::string & name = \"\" )\n    \n    Return an empty trajectory instance.\n    \n            ";
m["en function ViewerBase main"] = "\n\nint  **main**\\(bool bShow = true )\n    \n    goes into the main loop\n    \n    *Parameters*\n     ``bShow`` - \n      if true will show the window \n            ";
m["en function ViewerBase quitmainloop"] = "\n\nvoid  **quitmainloop**\\()\n    \n    destroys the main loop\n    \n            ";
m["en function ViewerBase SetSize"] = "\n\nvoid  **SetSize**\\(int w, int h)\n    \n            ";
m["en function ViewerBase Move"] = "\n\nvoid  **Move**\\(int x, int y)\n    \n            ";
m["en function ViewerBase SetName"] = "\n\nvoid  **SetName**\\(const std::string & name)\n    \n            ";
m["en function ViewerBase SetName"] = "\n\nvoid  **SetName**\\(const std::string & name)\n    \n            ";
m["en function ViewerBase GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["en function ViewerBase RegisterItemSelectionCallback"] = "\n\nUserDataPtr  **RegisterItemSelectionCallback**\\(const  ItemSelectionCallbackFn  & fncallback)\n    \n    registers a function with the viewer that gets called everytime mouse button is clicked\n    \n    *Return*\n        a handle to the callback. If this handle is deleted, the callback will be unregistered. \n        ";
m["en function ViewerBase RegisterItemSelectionCallback"] = "\n\nUserDataPtr  **RegisterItemSelectionCallback**\\(const  ItemSelectionCallbackFn  & fncallback)\n    \n    registers a function with the viewer that gets called everytime mouse button is clicked\n    \n    *Return*\n        a handle to the callback. If this handle is deleted, the callback will be unregistered. \n        ";
m["en function ViewerBase EnvironmentSync"] = "\n\nvoid  **EnvironmentSync**\\()\n    \n    forces synchronization with the environment, returns when the environment is fully synchronized.\n    \n    Note that this method might not work if environment is locked in current thread         ";
m["en function ViewerBase SetCamera"] = "\n\nvoid  **SetCamera**\\(const  RaveTransform < float > & trans, float focalDistance = 0 )\n    \n    Set the camera transformation.\n    \n    *Parameters*\n     ``trans`` - \n      new camera transformation in the world coordinate system \n     ``focalDistance`` - \n      The new focal distance of the camera (higher values is higher zoom). If 0, then the previous focal distance is preserved. \n            ";
m["en function ViewerBase SetCamera"] = "\n\nvoid  **SetCamera**\\(const  RaveTransform < float > & trans, float focalDistance = 0 )\n    \n    Set the camera transformation.\n    \n    *Parameters*\n     ``trans`` - \n      new camera transformation in the world coordinate system \n     ``focalDistance`` - \n      The new focal distance of the camera (higher values is higher zoom). If 0, then the previous focal distance is preserved. \n            ";
m["en function ViewerBase SetBkgndColor"] = "\n\nvoid  **SetBkgndColor**\\(const RaveVector< float > & color)\n    \n            ";
m["en function ViewerBase GetCameraTransform"] = "\n\nRaveTransform < float >  **GetCameraTransform**\\()\n    \n    Return the current camera transform that the viewer is rendering the environment at.\n    \n            ";
m["en function ViewerBase GetCameraImage"] = "\n\nbool  **GetCameraImage**\\(std::vector< uint8_t > & memory, int width, int height, const  RaveTransform < float > & t, const  SensorBase::CameraIntrinsics  & intrinsics)\n    \n    Renders a 24bit RGB image of dimensions width and height from the current scene.\n    \n    *Parameters*\n     ``memory`` - \n      the memory where the image will be stored at, has to store 3*width*height \n     ``width`` - \n      width of the image, if 0 the width of the viewer is used \n     ``height`` - \n      height of the image, if 0 the width of the viewer is used \n     ``t`` - \n      the rotation and translation of the camera. Note that +z is treated as the camera direction axis! So all points in front of the camera have a positive dot product with its +z direction. \n     ``intrinsics`` - \n      the intrinsic parameters of the camera defining FOV, distortion, principal point, and focal length. The focal length is used to define the near plane for culling. The camera is meant to show the underlying OpenRAVE world as a robot would see it, so all graphs rendered with the plotX and drawX functions are hidden by default. Some viewers support the SetFiguresInCamera command to allow graphs to be also displayed. \n            ";
m["en function RaveCreateViewer"] = "\n\nOPENRAVE_API   ViewerBasePtr  **RaveCreateViewer**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["en function GraphHandle SetTransform"] = "\n\nvoid  **SetTransform**\\(const  RaveTransform < float > & t)\n    \n    Changes the underlying transformation of the plot.\n    \n    *Parameters*\n     ``t`` - \n      new transformation of the plot \n            ";
m["en function GraphHandle SetShow"] = "\n\nvoid  **SetShow**\\(bool bshow)\n    \n    Shows or hides the plot without destroying its resources.\n    \n            ";
m["en function SerializableData  Serialize"] = "\n\nvoid  **Serialize**\\(std::ostream & O, int options = 0 )\n    \n    output the data of the object\n    \n            ";
m["en function SerializableData  Deserialize"] = "\n\nvoid  **Deserialize**\\(std::istream & I)\n    \n    initialize the object\n    \n            ";
m["en function XMLReadable  GetXMLId"] = "\n\nconst std::string &  **GetXMLId**\\()\n    \n            ";
m["en function XMLReadable  Serialize"] = "\n\nvoid  **Serialize**\\(BaseXMLWriterPtr writer, int options = 0 )\n    \n    serializes the interface\n    \n            ";
m["en function ConfigurationSpecification GetGroupFromName"] = "\n\nconst  Group  &  **GetGroupFromName**\\(const std::string & name)\n    \n    return the group whose name begins with a particular string.\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      if a group is not found If multiple groups exist that begin with the same string, then the shortest one is returned. \n            ";
m["en function ConfigurationSpecification FindCompatibleGroup"] = "\n\nstd::vector<  Group  >::const_iterator  **FindCompatibleGroup**\\(const  Group  & g, bool exactmatch = false )\n    \n    finds the most compatible group to the given group\n    \n    *Parameters*\n     ``g`` - \n      the group to query, only the Group::name and Group::dof values are used \n     ``exactmatch`` - \n      if true, will only return groups whose name exactly matches with g.name\n    \n    *Return*\n        an iterator part of _vgroups that represents the most compatible group. If no group is found, will return _vgroups.end() \n        ";
m["en function ConfigurationSpecification FindTimeDerivativeGroup"] = "\n\nstd::vector<  Group  >::const_iterator  **FindTimeDerivativeGroup**\\(const  Group  & g, bool exactmatch = false )\n    \n    Return the most compatible group that represents the time-derivative data of the group.\n    \n    *Parameters*\n     ``g`` - \n      the group to query, only the Group::name and Group::dof values are used \n     ``exactmatch`` - \n      if true, will only return groups whose name exactly matches with g.name For example given a 'joint_values' group, this will return the closest 'joint_velocities' group.\n    \n    *Return*\n        an iterator part of _vgroups that represents the most compatible group. If no group is found, will return _vgroups.end() \n        ";
m["en function ConfigurationSpecification GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    return the dimension of the configuraiton space (degrees of freedom)\n    \n            ";
m["en function ConfigurationSpecification IsValid"] = "\n\nbool  **IsValid**\\()\n    \n    check if the groups form a continguous space\n    \n    If there are two or more groups with the same semantic names, will fail. Theese groups should be merged into one.\n    \n    *Return*\n        true if valid, otherwise false \n        ";
m["en function ConfigurationSpecification ResetGroupOffsets"] = "\n\nvoid  **ResetGroupOffsets**\\()\n    \n    set the offsets of each group in order to get a contiguous configuration space\n    \n            ";
m["en function ConfigurationSpecification AddVelocityGroups"] = "\n\nvoid  **AddVelocityGroups**\\(bool adddeltatime)\n    \n            ";
m["en function ConfigurationSpecification AddDerivativeGroups"] = "\n\nvoid  **AddDerivativeGroups**\\(int deriv, bool adddeltatime = false )\n    \n    adds velocity, acceleration, etc groups for every position group.\n    \n    *Parameters*\n     ``deriv`` - \n      The position derivative to add, this must be greater than 0. If 2 is specified, only the acceleration groups of the alread present position groups will be added. \n     ``adddeltatime`` - \n      If true will add the 'deltatime' tag, which is necessary for trajectory sampling If the derivative groups already exist, they are checked for and/or modified. Note that the configuration space might be re-ordered as a result of this function call. If a new group is added, its interpolation will be the derivative of the position group as returned by GetInterpolationDerivative. \n            ";
m["en function ConfigurationSpecification AddDeltaTimeGroup"] = "\n\nint  **AddDeltaTimeGroup**\\()\n    \n    adds the deltatime tag to the end if one doesn't exist and returns the index into the configuration space\n    \n            ";
m["en function ConfigurationSpecification AddGroup \"const std::string; int; const std::string\""] = "\n\nint  **AddGroup**\\(const std::string & name, int dof, const std::string & interpolation = \"\" )\n    \n    Adds a new group to the specification and returns its new offset.\n    \n    If the new group's semantic name does not exist in the current specification, adds it and returns the new offset. If the new group's semantic name exists in the current specification and it exactly matches, then function returns the old group's index. If the semantic names match, but parameters do not match, then an openrave_exception is thrown. This method is not responsible for merging semantic information         ";
m["en function ConfigurationSpecification AddGroup \"const\""] = "\n\nint  **AddGroup**\\(const  Group  & g)\n    \n    Adds a new group to the specification and returns its new offset.\n    \n    *Parameters*\n     ``g`` - \n      the group whose name, dof, and interpolation are extracted. If the new group's semantic name does not exist in the current specification, adds it and returns the new offset. If the new group's semantic name exists in the current specification and it exactly matches, then function returns the old group's index. If the semantic names match, but parameters do not match, then an openrave_exception is thrown. This method is not responsible for merging semantic information \n            ";
m["en function ConfigurationSpecification ConvertToVelocitySpecification"] = "\n\nConfigurationSpecification  **ConvertToVelocitySpecification**\\()\n    \n    converts all the groups to the corresponding velocity groups and returns the specification\n    \n    The velocity configuration space will have a one-to-one correspondence with the original configuration. The interpolation of each of the groups will correspondingly represent the derivative as returned by GetInterpolationDerivative. Only position specifications will be converted, any other groups will be left untouched.         ";
m["en function ConfigurationSpecification GetTimeDerivativeSpecification"] = "\n\nConfigurationSpecification  **GetTimeDerivativeSpecification**\\(int timederivative)\n    \n    returns a new specification of just particular time-derivative groups.\n    \n    *Parameters*\n     ``timederivative`` - \n      the time derivative to query groups from. 0 is positions/joint values, 1 is velocities, 2 is accelerations, etc \n            ";
m["en function ConfigurationSpecification ExtractTransform"] = "\n\nbool  **ExtractTransform**\\(Transform  & t, std::vector<  dReal  >::const_iterator itdata, KinBodyConstPtr pbody, int timederivative = 0 )\n    \n    extracts an affine transform given the start of a configuration space point\n    \n    *Parameters*\n     ``inout]`` - \n      t the transform holding the default values, which will be overwritten with the new values. \n     ``itdata`` - \n      data in the format of this configuration specification. \n     ``timederivative`` - \n      the time derivative of the data to extract Looks for 'affine_transform' groups. If pbody is not initialized, will choose the first affine_transform found.\n    \n    *Return*\n        true if at least one group was found for extracting \n        ";
m["en function ConfigurationSpecification ExtractJointValues"] = "\n\nbool  **ExtractJointValues**\\(std::vector<  dReal  >::iterator itvalues, std::vector<  dReal  >::const_iterator itdata, KinBodyConstPtr pbody, const std::vector< int > & indices, int timederivative = 0 )\n    \n    extracts a body's joint values given the start of a configuration space point\n    \n    *Parameters*\n     ``inout]`` - \n      itvalues iterator to vector that holds the default values and will be overwritten with the new values. must be initialized \n     ``itdata`` - \n      data in the format of this configuration specification. \n     ``indices`` - \n      the set of DOF indices of the body to extract and write into itvalues. \n     ``timederivative`` - \n      the time derivative of the data to extract Looks for 'joint_X' groups. If pbody is not initialized, will choose the first joint_X found.\n    \n    *Return*\n        true if at least one group was found for extracting \n        ";
m["en function ConfigurationSpecification ExtractDeltaTime"] = "\n\nbool  **ExtractDeltaTime**\\(dReal  & deltatime, std::vector<  dReal  >::const_iterator itdata)\n    \n    extracts the delta time from the configuration if one exists\n    \n    *Return*\n        true if deltatime exists in the current configuration, otherwise false \n        ";
m["en function ConfigurationSpecification InsertDeltaTime"] = "\n\nbool  **InsertDeltaTime**\\(std::vector<  dReal  >::iterator itdata, dReal deltatime)\n    \n    sets the deltatime field of the data if one exists\n    \n    *Parameters*\n     ``inout]`` - \n      itdata data in the format of this configuration specification. \n     ``deltatime`` - \n      the delta time of the time stamp (from previous point)\n    \n    *Return*\n        true if at least one group was found for inserting \n        ";
m["en function planningutils::ManipulatorIKGoalSampler  Sample"] = "\n\nIkReturnPtr  **Sample**\\()\n    \n    if can sample, returns IkReturn pointer\n    \n            ";
m["en function planningutils::ManipulatorIKGoalSampler  SampleAll"] = "\n\nbool  **SampleAll**\\(std::list<  IkReturnPtr  > & samples)\n    \n    samples the rests of the samples until cannot be sampled anymore.\n    \n    *Parameters*\n     ``vsamples`` - \n      vector is rest with samples\n    \n    *Return*\n        true if a sample was inserted into vsamples \n        ";
m["en function ConvertTrajectorySpecification"] = "\n\nOPENRAVE_API  void  **ConvertTrajectorySpecification**\\(TrajectoryBasePtr traj, const  ConfigurationSpecification  & spec)\n    \n    convert the trajectory and all its points to a new specification\n    \n            ";
m["en function ComputeTrajectoryDerivatives"] = "\n\nOPENRAVE_API  void  **ComputeTrajectoryDerivatives**\\(TrajectoryBasePtr traj, int maxderiv)\n    \n    computes the trajectory derivatives and modifies the trajetory configuration to store them.\n    \n    *Parameters*\n     ``traj`` - \n      the re-timed trajectory \n     ``maxderiv`` - \n      the maximum derivative to assure. If 1, will assure velocities, if 2 will assure accelerations, etc. If necessary will change the configuration specification of the trajectory. If more derivatives are requested than the trajectory supports, will ignore them. For example, acceleration of a linear trajectory. \n            ";
m["en function ReverseTrajectory"] = "\n\nOPENRAVE_API   TrajectoryBasePtr  **ReverseTrajectory**\\(TrajectoryBaseConstPtr traj)\n    \n    returns a new trajectory with the order of the waypoints and times reversed.\n    \n    Velocities are just negated and the new trajectory is not guaranteed to be executable or valid         ";
m["en function VerifyTrajectory"] = "\n\nvoid  **VerifyTrajectory**\\(TrajectoryBaseConstPtr trajectory, dReal samplingstep)\n    \n            ";
m["en function SmoothActiveDOFTrajectory"] = "\n\nOPENRAVE_API  void  **SmoothActiveDOFTrajectory**\\(TrajectoryBasePtr traj, RobotBasePtr robot, dReal fmaxvelmult = 1 , dReal fmaxaccelmult = 1 , const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Smooth the trajectory points to avoiding collisions by extracting and using the currently set active dofs of the robot.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``robot`` - \n      use the robot's active dofs to initialize the trajectory space \n     ``plannername`` - \n      the name of the planner to use to smooth. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Only initial and goal configurations are preserved. The velocities for the current trajectory are overwritten. The returned trajectory will contain data only for the currenstly set active dofs of the robot. \n            ";
m["en function SmoothAffineTrajectory"] = "\n\nOPENRAVE_API  void  **SmoothAffineTrajectory**\\(TrajectoryBasePtr traj, const std::vector<  dReal  > & maxvelocities, const std::vector<  dReal  > & maxaccelerations, const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Smooth the trajectory points consisting of affine transformation values while avoiding collisions.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``maxvelocities`` - \n      the max velocities of each dof \n     ``maxaccelerations`` - \n      the max acceleration of each dof \n     ``plannername`` - \n      the name of the planner to use to smooth. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Only initial and goal configurations are preserved. \n            ";
m["en function SmoothTrajectory"] = "\n\nOPENRAVE_API  void  **SmoothTrajectory**\\(TrajectoryBasePtr traj, dReal fmaxvelmult = 1 , dReal fmaxaccelmult = 1 , const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Smooth the trajectory points to avoiding collisions by extracting and using the positional data from the trajectory.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``plannername`` - \n      the name of the planner to use to smooth. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Only initial and goal configurations are preserved. The velocities for the current trajectory are overwritten. The returned trajectory will contain data only for the currenstly set active dofs of the robot. \n            ";
m["en function RetimeActiveDOFTrajectory"] = "\n\nOPENRAVE_API  void  **RetimeActiveDOFTrajectory**\\(TrajectoryBasePtr traj, RobotBasePtr robot, bool hastimestamps = false , dReal fmaxvelmult = 1 , dReal fmaxaccelmult = 1 , const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Retime the trajectory points by extracting and using the currently set active dofs of the robot.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``robot`` - \n      use the robot's active dofs to initialize the trajectory space \n     ``plannername`` - \n      the name of the planner to use to retime. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Collision is not checked. Every waypoint in the trajectory is guaranteed to be hit. The velocities for the current trajectory are overwritten. The returned trajectory will contain data only for the currenstly set active dofs of the robot. \n            ";
m["en function RetimeAffineTrajectory"] = "\n\nOPENRAVE_API  void  **RetimeAffineTrajectory**\\(TrajectoryBasePtr traj, const std::vector<  dReal  > & maxvelocities, const std::vector<  dReal  > & maxaccelerations, bool hastimestamps = false , const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Retime the trajectory points consisting of affine transformation values while avoiding collisions.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``maxvelocities`` - \n      the max velocities of each dof \n     ``maxaccelerations`` - \n      the max acceleration of each dof \n     ``plannername`` - \n      the name of the planner to use to retime. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Collision is not checked. Every waypoint in the trajectory is guaranteed to be hit. The velocities for the current trajectory are overwritten. \n            ";
m["en function RetimeTrajectory"] = "\n\nOPENRAVE_API  void  **RetimeTrajectory**\\(TrajectoryBasePtr traj, bool hastimestamps = false , dReal fmaxvelmult = 1 , dReal fmaxaccelmult = 1 , const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Retime the trajectory points using all the positional data from the trajectory.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``plannername`` - \n      the name of the planner to use to retime. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Collision is not checked. Every waypoint in the trajectory is guaranteed to be hit. The velocities for the current trajectory are overwritten. The returned trajectory will contain data only for the currenstly set active dofs of the robot. \n            ";
m["en function InsertWaypointWithSmoothing"] = "\n\nOPENRAVE_API  void  **InsertWaypointWithSmoothing**\\(int index, const std::vector<  dReal  > & dofvalues, const std::vector<  dReal  > & dofvelocities, TrajectoryBasePtr traj, dReal fmaxvelmult = 1 , dReal fmaxaccelmult = 1 , const std::string & plannername = \"\" )\n    \n    insert a waypoint in a timed trajectory and smooth so that the trajectory always goes through the waypoint at the specified velocity.\n    \n    *Parameters*\n     ``index`` - \n      The index where to insert the new waypoint. A negative value starts from the end. \n     ``dofvalues`` - \n      the configuration to insert into the trajectcory (active dof values of the robot) \n     ``dofvelocities`` - \n      the velocities that the inserted point should start with \n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``plannername`` - \n      the name of the planner to use to smooth. If empty, will use the default trajectory smoother. The PlannerParameters is automatically determined from the trajectory's configuration space \n            ";
m["en function MergeTrajectories"] = "\n\nOPENRAVE_API   TrajectoryBasePtr  **MergeTrajectories**\\(const std::list<  TrajectoryBaseConstPtr  > & listtrajectories)\n    \n    merges the contents of multiple trajectories into one so that everything can be played simultaneously.\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      throws an exception if the trajectory data is incompatible and cannot be merged. Each trajectory needs to have a 'deltatime' group for timestamps. The trajectories cannot share common configuration data because only one trajectories's data can be set at a time. \n            ";
m["en function GetDHParameters"] = "\n\nOPENRAVE_API  void  **GetDHParameters**\\(std::vector<  DHParameter  > & vparameters, KinBodyConstPtr pbody)\n    \n    returns the Denavit-Hartenberg parameters of the kinematics structure of the body.\n    \n    *Parameters*\n     ``vparameters`` - \n      One set of parameters are returned for each joint. \\ *Parameters*\n     ``tstart`` - \n      the initial transform in the body coordinate system to the first joint If the robot has joints that cannot be represented by DH, will throw an exception. Passive joints are ignored. Joints are ordered by hierarchy dependency. By convention N joints give N-1 DH parameters, but GetDHParameters returns N parameters. The reason is because the first parameter is used to define the coordinate system of the first axis relative to the robot origin.\n    \n    *Note*\n        The coordinate systems computed from the DH parameters do not match the OpenRAVE link coordinate systems.\n\n    *See*\n        DHParameter. \n        ";
m["en function RaveSetDebugLevel"] = "\n\nOPENRAVE_API  void  **RaveSetDebugLevel**\\(int level)\n    \n    Sets the global openrave debug level. A combination of DebugLevel.\n    \n            ";
m["en function RaveGetDebugLevel"] = "\n\nOPENRAVE_API  int  **RaveGetDebugLevel**\\()\n    \n    Returns the openrave debug level.\n    \n            ";
m["en function RaveSetDataAccess"] = "\n\nOPENRAVE_API  void  **RaveSetDataAccess**\\(int accessoptions)\n    \n    Sets the default data access options for cad resources/robot files.\n    \n    *Parameters*\n     ``accessoptions`` - \n      - if 1 will only allow resources inside directories specified from OPERNAVE_DATA environment variable. This allows reject of full paths from unsecure/unauthenticated resources. Controls how files are processed in functions like RaveFindLocalFile \n            ";
m["en function RaveGetDataAccess"] = "\n\nOPENRAVE_API  int  **RaveGetDataAccess**\\()\n    \n    Returns the acess options set.\n    \n    *See*\n        RaveSetDataAccess \n        ";
m["en function RaveGetHomeDirectory"] = "\n\nOPENRAVE_API  std::string  **RaveGetHomeDirectory**\\()\n    \n    Returns the openrave home directory where settings, cache, and other files are stored.\n    \n    On Linux/Unix systems, this is usually $HOME/.openrave, on Windows this is $HOMEPATH/.openrave         ";
m["en function RaveFindDatabaseFile"] = "\n\nOPENRAVE_API  std::string  **RaveFindDatabaseFile**\\(const std::string & filename, bool bRead = true )\n    \n    Searches for a filename in the database and returns a full path/URL to it.\n    \n    *Parameters*\n     ``filename`` - \n      the relative filename in the database \n     ``bRead`` - \n      if true will only return a file if it exists. If false, will return the filename of the first valid database directory.\n    \n    *Return*\n        a non-empty string if a file could be found. \n        ";
m["en function RaveInitialize"] = "\n\nOPENRAVE_API  int  **RaveInitialize**\\(bool bLoadAllPlugins = true , int level = Level_Info )\n    \n    Explicitly initializes the global OpenRAVE state (optional).\n    \n    *Parameters*\n     ``bLoadAllPlugins`` - \n      If true will load all the openrave plugins automatically that can be found in the OPENRAVE_PLUGINS environment path Optional function to initialize openrave plugins, logging, and read OPENRAVE_* environment variables. Although environment creation will automatically make sure this function is called, users might want explicit control of when this happens. Will not do anything if OpenRAVE runtime is already initialized. If OPENRAVE_* environment variables must be re-read, first call RaveDestroy.\n    \n    *Return*\n        0 if successful, otherwise an error code \n        ";
m["en function RaveDestroy"] = "\n\nOPENRAVE_API  void  **RaveDestroy**\\()\n    \n    Destroys the entire OpenRAVE state and all loaded environments.\n    \n    This functions should be always called before program shutdown in order to assure all resources are relased appropriately.         ";
m["en function RaveGetPluginInfo"] = "\n\nOPENRAVE_API  void  **RaveGetPluginInfo**\\(std::list< std::pair< std::string,  PLUGININFO  > > & plugins)\n    \n    Get all the loaded plugins and the interfaces they support.\n    \n    *Parameters*\n     ``plugins`` - \n      A list of plugins. Each entry has the plugin name and the interfaces it supports \n            ";
m["en function RaveGetLoadedInterfaces"] = "\n\nOPENRAVE_API  void  **RaveGetLoadedInterfaces**\\(std::map< InterfaceType, std::vector< std::string > > & interfacenames)\n    \n    Get a list of all the loaded interfaces.\n    \n            ";
m["en function RaveReloadPlugins"] = "\n\nOPENRAVE_API  void  **RaveReloadPlugins**\\()\n    \n    Reloads all the plugins.\n    \n    The interfaces currently created remain will continue using the old plugins, so this function is safe in that plugins currently loaded remain loaded until the last interface that uses them is released.         ";
m["en function RaveHasInterface"] = "\n\nOPENRAVE_API  bool  **RaveHasInterface**\\(InterfaceType type, const std::string & interfacename)\n    \n    Returns true if interface can be created, otherwise false.\n    \n            ";
m["en function RaveGlobalState"] = "\n\nOPENRAVE_API   UserDataPtr  **RaveGlobalState**\\()\n    \n    A pointer to the global openrave state.\n    \n    *Return*\n        a managed pointer to the state. \n        ";
m["en function RaveClone"] = "\n\nboost::shared_ptr< T >  **RaveClone**\\(boost::shared_ptr< T const  > preference, int cloningoptions)\n    \n    returned a fully cloned interface\n    \n            ";
m["en function RaveGetIkTypeFromUniqueId"] = "\n\nOPENRAVE_API   IkParameterizationType  **RaveGetIkTypeFromUniqueId**\\(int uniqueid)\n    \n    returns the IkParameterizationType given the unique id detmerined b IKP_UniqueIdMask\n    \n            ";
m["en function RaveGetIndexFromAffineDOF"] = "\n\nOPENRAVE_API  int  **RaveGetIndexFromAffineDOF**\\(int affinedofs, DOFAffine dof)\n    \n    Given a mask of affine dofs and a dof inside that mask, returns the index where the value could be found.\n    \n    *Parameters*\n     ``affinedofs`` - \n      a mask of DOFAffine values \n     ``dof`` - \n      a set of values inside affinedofs, the index of the first value is returned \\ *Exceptions*\n     ``openrave_exception`` - \n      throws if dof is not present in affinedofs\n    \n            ";
m["en function RaveGetAffineDOFFromIndex"] = "\n\nOPENRAVE_API   DOFAffine  **RaveGetAffineDOFFromIndex**\\(int affinedofs, int index)\n    \n    Given a mask of affine dofs and an index into the array, returns the affine dof that is being referenced.\n    \n    *Parameters*\n     ``affinedofs`` - \n      a mask of DOFAffine values \n     ``index`` - \n      an index into the affine dof array \\ *Exceptions*\n     ``openrave_exception`` - \n      throws if dof if index is out of bounds\n    \n            ";
m["en function RaveGetAffineDOF"] = "\n\nOPENRAVE_API  int  **RaveGetAffineDOF**\\(int affinedofs)\n    \n    Returns the degrees of freedom needed to represent all the values in the affine dof mask.\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      throws if \n            ";
m["en function RaveGetAffineDOFValuesFromTransform"] = "\n\nOPENRAVE_API  void  **RaveGetAffineDOFValuesFromTransform**\\(std::vector<  dReal  >::iterator itvalues, const  Transform  & t, int affinedofs, const  Vector  & vActvAffineRotationAxis = Vector (0, 0, 1) )\n    \n    Converts the transformation matrix into the specified affine values format.\n    \n    *Parameters*\n     ``itvalues`` - \n      an iterator to the vector to write the values to. Will write exactly RaveGetAffineDOF(affinedofs) values. \n     ``the`` - \n      affine transformation to convert \n     ``affinedofs`` - \n      the affine format to output values in \n     ``vActvAffineRotationAxis`` - \n      optional rotation axis if affinedofs specified DOF_RotationAxis \n            ";
m["en function RaveGetAffineConfigurationSpecification"] = "\n\nOPENRAVE_API   ConfigurationSpecification  **RaveGetAffineConfigurationSpecification**\\(int affinedofs, KinBodyConstPtr pbody = KinBodyConstPtr () , const std::string & interpolation = \"\" )\n    \n            ";
m["en function RaveSetDebugLevel"] = "\n\nOPENRAVE_API  void  **RaveSetDebugLevel**\\(int level)\n    \n    Sets the global openrave debug level. A combination of DebugLevel.\n    \n            ";
m["en function RaveGetDebugLevel"] = "\n\nOPENRAVE_API  int  **RaveGetDebugLevel**\\()\n    \n    Returns the openrave debug level.\n    \n            ";
m["en function quatFromAxisAngle \"const RaveVector\""] = "\n\nRaveVector < T >  **quatFromAxisAngle**\\(const  RaveVector < T > & axisangle)\n    \n    Converts an axis-angle rotation into a quaternion.\n    \n    *Parameters*\n     ``axisangle`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["en function quatFromAxisAngle \"const RaveVector; T\""] = "\n\nRaveVector < T >  **quatFromAxisAngle**\\(const  RaveVector < T > & axis, T angle)\n    \n    Converts an axis-angle rotation into a quaternion.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis, 3 values \n     ``angle`` - \n      rotation angle (radians) \n            ";
m["en function quatFromMatrix \"const RaveTransform\""] = "\n\nRaveVector < T >  **quatFromMatrix**\\(const  RaveTransformMatrix < T > & rotation)\n    \n    Converts the rotation of a matrix into a quaternion.\n    \n    *Parameters*\n     ``t`` - \n      transform for extracting the 3x3 rotation. \n            ";
m["en function quatSlerp \"const RaveVector; const RaveVector; T\""] = "\n\nRaveVector < T >  **quatSlerp**\\(const  RaveVector < T > & quat0, const  RaveVector < T > & quat1, T t)\n    \n    Sphereical linear interpolation between two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n     ``t`` - \n      real value in [0,1]. 0 returns quat1, 1 returns quat2 \n            ";
m["en function axisAngleFromMatrix \"const RaveTransformMatrix\""] = "\n\nRaveVector < T >  **axisAngleFromMatrix**\\(const  RaveTransformMatrix < T > & rotation)\n    \n    Converts the rotation of a matrix into axis-angle representation.\n    \n    *Parameters*\n     ``rotation`` - \n      3x3 rotation matrix \n            ";
m["en function axisAngleFromQuat \"const RaveVector\""] = "\n\nRaveVector < T >  **axisAngleFromQuat**\\(const  RaveVector < T > & quat)\n    \n    Converts a quaternion into the axis-angle representation.\n    \n    *Parameters*\n     ``quat`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["en function matrixFromQuat \"const RaveVector\""] = "\n\nRaveTransformMatrix < T >  **matrixFromQuat**\\(const  RaveVector < T > & quat)\n    \n    Converts a quaternion to a 3x3 matrix.\n    \n    *Parameters*\n     ``quat`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["en function matrixFromAxisAngle \"const RaveVector\""] = "\n\nRaveTransformMatrix < T >  **matrixFromAxisAngle**\\(const  RaveVector < T > & axisangle)\n    \n    Converts an axis-angle rotation to a 3x3 matrix.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["en function matrixFromAxisAngle \"const RaveVector\""] = "\n\nRaveTransformMatrix < T >  **matrixFromAxisAngle**\\(const  RaveVector < T > & axisangle)\n    \n    Converts an axis-angle rotation to a 3x3 matrix.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["en function quatRotateDirection"] = "\n\nRaveVector < T >  **quatRotateDirection**\\(const  RaveVector < T > & sourcedir, const  RaveVector < T > & targetdir)\n    \n    Return the minimal quaternion that orients sourcedir to targetdir.\n    \n    *Parameters*\n     ``sourcedir`` - \n      direction of the original vector, 3 values \n     ``targetdir`` - \n      new direction, 3 values \n            ";
m["en function quatMultiply"] = "\n\nRaveVector < T >  **quatMultiply**\\(const  RaveVector < T > & quat0, const  RaveVector < T > & quat1)\n    \n    Multiply two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["en function quatMultiply"] = "\n\nRaveVector < T >  **quatMultiply**\\(const  RaveVector < T > & quat0, const  RaveVector < T > & quat1)\n    \n    Multiply two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["en function quatInverse"] = "\n\nRaveVector < T >  **quatInverse**\\(const  RaveVector < T > & quat)\n    \n    Inverted a quaternion rotation.\n    \n    *Parameters*\n     ``quat`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["en function normalizeAxisRotation"] = "\n\nstd::pair< T,  RaveVector < T > >  **normalizeAxisRotation**\\(const  RaveVector < T > & axis, const  RaveVector < T > & quat)\n    \n    Find the rotation theta around axis such that rot(axis,theta) * q is closest to the identity rotation.\n    \n    *Parameters*\n     ``axis`` - \n      axis to minimize rotation about \n     ``quat`` - \n      input\n    \n    *Return*\n        The angle that minimizes the rotation along with the normalized rotation rot(axis,theta)*q \n        ";
m["en enum DOFAffine"] = "\n\n **DOFAffine**\n    \n    Selects which DOFs of the affine transformation to include in the active configuration.\n    \n            ";
m["en enum SaveParameters"] = "\n\n **SaveParameters**\n    \n    Parameters passed into the state savers to control what information gets saved.\n    \n            ";
m["en enum CheckLimitsAction"] = "\n\n **CheckLimitsAction**\n    \n    used for specifying the type of limit checking and the messages associated with it\n    \n            ";
m["en enum AdjacentOptions"] = "\n\n **AdjacentOptions**\n    \n    specifies the type of adjacent link information to receive\n    \n            ";
m["en enum GeomType"] = "\n\n **GeomType**\n    \n    The type of geometry primitive.\n    \n            ";
m["en enum JointType"] = "\n\n **JointType**\n    \n    The type of joint movement.\n    \n    Non-special joints that are combinations of revolution and prismatic joints. The first 4 bits specify the joint DOF, the next bits specify whether the joint is revolute (0) or prismatic (1). There can be also special joint types that are valid if the JointSpecialBit is set.For multi-dof joints, the order is transform(parentlink) * transform(axis0) * transform(axis1) ...         ";
m["en enum ActuatorState"] = "\n\n **ActuatorState**\n    \n    the state of the actuator\n    \n            ";
m["en enum SensorType"] = "\n\n **SensorType**\n    \n            ";
m["en enum ConfigureCommand"] = "\n\n **ConfigureCommand**\n    \n    A set of commands used for run-time sensor configuration.\n    \n            ";
m["en enum CollisionOptions"] = "\n\n **CollisionOptions**\n    \n    options for collision checker\n    \n            ";
m["en enum CollisionAction"] = "\n\n **CollisionAction**\n    \n    action to perform whenever a collision is detected between objects\n    \n            ";
m["en enum IkParameterizationType"] = "\n\n **IkParameterizationType**\n    \n    The types of inverse kinematics parameterizations supported.\n    \n    The minimum degree of freedoms required is set in the upper 4 bits of each type. The number of values used to represent the parameterization ( >= dof ) is the next 4 bits. The lower bits contain a unique id of the type.         ";
m["en enum SelectionOptions"] = "\n\n **SelectionOptions**\n    \n    A set of options used to select particular parts of the scene.\n    \n            ";
m["en enum IkFilterOptions"] = "\n\n **IkFilterOptions**\n    \n    Controls what information gets validated when searching for an inverse kinematics solution.\n    \n            ";
m["en enum IkReturnAction"] = "\n\n **IkReturnAction**\n    \n    Return value for the ik filter that can be optionally set on an ik solver.\n    \n            ";
m["en enum PlannerStatus"] = "\n\n **PlannerStatus**\n    \n    the status of the PlanPath method. Used when PlanPath can be called multiple times to resume planning.\n    \n            ";
m["en enum PlannerAction"] = "\n\n **PlannerAction**\n    \n    action to send to the planner while it is planning. This is usually done by the user-specified planner callback function\n    \n            ";
m["en enum ViewerEvents"] = "\n\n **ViewerEvents**\n    \n            ";
m["en enum OpenRAVEErrorCode"] = "\n\n **OpenRAVEErrorCode**\n    \n    OpenRAVE error codes\n    \n            ";
m["en enum DebugLevel"] = "\n\n **DebugLevel**\n    \n            ";
m["en enum SerializationOptions"] = "\n\n **SerializationOptions**\n    \n    serialization options for interfaces\n    \n            ";
m["en enum CloningOptions"] = "\n\n **CloningOptions**\n    \n            ";
m["en enum PhysicsEngineOptions"] = "\n\n **PhysicsEngineOptions**\n    \n    basic options for physics engine\n    \n            ";
m["en enum IntervalType"] = "\n\n **IntervalType**\n    \n    Specifies the boundary conditions of intervals for sampling.\n    \n            ";
m["en enum SampleDataType"] = "\n\n **SampleDataType**\n    \n            ";
m["ja function RaveCreateSensorSystem"] = "\n\nOPENRAVE_API   SensorSystemBasePtr  **RaveCreateSensorSystem**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function KinBody::KinBodyStateSaver  GetBody"] = "\n\nKinBodyPtr  **GetBody**\\()\n    \n            ";
m["ja function KinBody::KinBodyStateSaver  Restore"] = "\n\nvoid  **Restore**\\(boost::shared_ptr<  KinBody  > body = boost::shared_ptr<  KinBody  >() )\n    \n    restore the state\n    \n    *Parameters*\n     ``body`` - \n      if set, will attempt to restore the stored state to the passed in body, otherwise will restore it for the original body. \\ *Exceptions*\n     ``openrave_exception`` - \n      if the passed in body is not compatible with the saved state, will throw\n    \n            ";
m["ja function KinBody::KinBodyStateSaver  Release"] = "\n\nvoid  **Release**\\()\n    \n    release the body state. _pbody will not get restored on destruction\n    \n    After this call, it will still be possible to use Restore.         ";
m["ja function KinBody InitFromBoxes \"const std::vector< AABB; bool\""] = "\n\nbool  **InitFromBoxes**\\(const std::vector<  AABB  > & boxes, bool visible)\n    \n    Create a kinbody with one link composed of an array of aligned bounding boxes.\n    \n    *Parameters*\n     ``boxes`` - \n      the array of aligned bounding boxes that will comprise of the body \n     ``visible`` - \n      if true, the boxes will be rendered in the scene \n            ";
m["ja function KinBody GetChain"] = "\n\nbool  **GetChain**\\(int linkindex1, int linkindex2, std::vector<  JointPtr  > & vjoints)\n    \n    2\n    \n    *Parameters*\n     ``linkindex1`` - \n       \n     ``linkindex2`` - \n       \n     ``vjoints`` - \n       \n    \n    *Return*\n        true \n        ";
m["ja function KinBody  ComputeInverseDynamics"] = "\n\nvoid  **ComputeInverseDynamics**\\(std::vector<  dReal  > & doftorques, const std::vector<  dReal  > & dofaccelerations, const  ForceTorqueMap  & externalforcetorque = ForceTorqueMap () )\n    \n    Computes the inverse dynamics (torques) from the current robot position, velocity, and acceleration.\n    \n    *Parameters*\n     ``doftorques`` - \n      The output torques. \n     ``dofaccelerations`` - \n      The dof accelerations of the current robot state. If the size is 0, assumes all accelerations are 0 (this should be faster) \n     ``externalforcetorque`` - \n      [optional] Specifies all the external forces/torques acting on the links at their center of mass. The dof values are ready from GetDOFValues() and GetDOFVelocities(). Because openrave does not have a state for robot acceleration, it has to be inserted as a parameter to this function. Acceleration due to gravitation is extracted from GetEnv()->GetPhysicsEngine()->GetGravity(). The method uses Recursive Newton Euler algorithm from Walker Orin and Corke. \n            ";
m["ja function KinBody InitFromSpheres"] = "\n\nbool  **InitFromSpheres**\\(const std::vector<  Vector  > & spheres, bool visible)\n    \n    Create a kinbody with one link composed of an array of spheres.\n    \n    *Parameters*\n     ``spheres`` - \n      the XYZ position of the spheres with the W coordinate representing the individual radius \n     ``visible`` - \n      if true, the boxes will be rendered in the scene \n            ";
m["ja function KinBody InitFromTrimesh"] = "\n\nbool  **InitFromTrimesh**\\(const  Link::TRIMESH  & trimesh, bool visible)\n    \n    Create a kinbody with one link composed of a triangle mesh surface.\n    \n    *Parameters*\n     ``trimesh`` - \n      the triangle mesh \n     ``visible`` - \n      if true, will be rendered in the scene \n            ";
m["ja function KinBody InitFromGeometries"] = "\n\nbool  **InitFromGeometries**\\(const std::list<  KinBody::Link::GeometryInfo  > & geometries)\n    \n    Create a kinbody with one link composed of a list of geometries.\n    \n    *Parameters*\n     ``geometries`` - \n      a list of geometry infos to be initialized into new geometry objects, note that the geometry info data is copied \n     ``visible`` - \n      if true, will be rendered in the scene \n            ";
m["ja function KinBody SetName"] = "\n\nvoid  **SetName**\\(const std::string & name)\n    \n    Set the name of the robot, notifies the environment and checks for uniqueness.\n    \n            ";
m["ja function KinBody GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n    Unique name of the robot.\n    \n            ";
m["ja function KinBody GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    Number controllable degrees of freedom of the body.\n    \n    Only uses _vecjoints and last joint for computation, so can work before _ComputeInternalInformation is called.         ";
m["ja function KinBody GetDOFValues"] = "\n\nvoid  **GetDOFValues**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint values as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFValues"] = "\n\nvoid  **GetDOFValues**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint values as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFVelocities"] = "\n\nvoid  **GetDOFVelocities**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint velocities as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFVelocities"] = "\n\nvoid  **GetDOFVelocities**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint velocities as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFLimits"] = "\n\nvoid  **GetDOFLimits**\\(std::vector<  dReal  > & lowerlimit, std::vector<  dReal  > & upperlimit, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint limits as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFLimits"] = "\n\nvoid  **GetDOFLimits**\\(std::vector<  dReal  > & lowerlimit, std::vector<  dReal  > & upperlimit, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint limits as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFVelocityLimits"] = "\n\nvoid  **GetDOFVelocityLimits**\\(std::vector<  dReal  > & lowerlimit, std::vector<  dReal  > & upperlimit, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint velocity limits as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFVelocityLimits"] = "\n\nvoid  **GetDOFVelocityLimits**\\(std::vector<  dReal  > & lowerlimit, std::vector<  dReal  > & upperlimit, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns all the joint velocity limits as organized by the DOF indices.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFAccelerationLimits"] = "\n\nvoid  **GetDOFAccelerationLimits**\\(std::vector<  dReal  > & maxaccelerations, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns the max acceleration for each DOF.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFAccelerationLimits"] = "\n\nvoid  **GetDOFAccelerationLimits**\\(std::vector<  dReal  > & maxaccelerations, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Returns the max acceleration for each DOF.\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFTorqueLimits"] = "\n\nvoid  **GetDOFTorqueLimits**\\(std::vector<  dReal  > & maxaccelerations)\n    \n    Returns the max torque for each DOF.\n    \n            ";
m["ja function KinBody GetDOFTorqueLimits"] = "\n\nvoid  **GetDOFTorqueLimits**\\(std::vector<  dReal  > & maxaccelerations)\n    \n    Returns the max torque for each DOF.\n    \n            ";
m["ja function KinBody GetDOFMaxVel"] = "\n\nvoid  **GetDOFMaxVel**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function KinBody GetDOFMaxTorque"] = "\n\nvoid  **GetDOFMaxTorque**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function KinBody GetDOFMaxAccel"] = "\n\nvoid  **GetDOFMaxAccel**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function KinBody GetDOFWeights"] = "\n\nvoid  **GetDOFWeights**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    get dof weights\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFWeights"] = "\n\nvoid  **GetDOFWeights**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    get dof weights\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody SetDOFWeights"] = "\n\nvoid  **SetDOFWeights**\\(const std::vector<  dReal  > & weights, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    sets dof weights\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to set the values for. If empty, will use all the dofs \n            ";
m["ja function KinBody SetDOFLimits"] = "\n\nvoid  **SetDOFLimits**\\(const std::vector<  dReal  > & lower, const std::vector<  dReal  > & upper)\n    \n    *See*\n        GetDOFLimits \n        ";
m["ja function KinBody SetDOFVelocityLimits"] = "\n\nvoid  **SetDOFVelocityLimits**\\(const std::vector<  dReal  > & maxlimits)\n    \n    *See*\n        GetDOFVelocityLimits \n        ";
m["ja function KinBody SetDOFAccelerationLimits"] = "\n\nvoid  **SetDOFAccelerationLimits**\\(const std::vector<  dReal  > & maxlimits)\n    \n    *See*\n        GetDOFAccelerationLimits \n        ";
m["ja function KinBody SetDOFTorqueLimits"] = "\n\nvoid  **SetDOFTorqueLimits**\\(const std::vector<  dReal  > & maxlimits)\n    \n    *See*\n        GetDOFTorqueLimits \n        ";
m["ja function KinBody GetDOFResolutions"] = "\n\nvoid  **GetDOFResolutions**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    get the dof resolutions\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetDOFResolutions"] = "\n\nvoid  **GetDOFResolutions**\\(std::vector<  dReal  > & v, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    get the dof resolutions\n    \n    *Parameters*\n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody GetLinks"] = "\n\nconst std::vector<  LinkPtr  > &  **GetLinks**\\()\n    \n    Returns all the rigid links of the body.\n    \n            ";
m["ja function KinBody GetLinks"] = "\n\nconst std::vector<  LinkPtr  > &  **GetLinks**\\()\n    \n    Returns all the rigid links of the body.\n    \n            ";
m["ja function KinBody GetLink"] = "\n\nLinkPtr  **GetLink**\\(const std::string & name)\n    \n    return a pointer to the link with the given name\n    \n            ";
m["ja function KinBody GetJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetJoints**\\()\n    \n    Returns the joints making up the controllable degrees of freedom of the body.\n    \n            ";
m["ja function KinBody GetJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetJoints**\\()\n    \n    Returns the joints making up the controllable degrees of freedom of the body.\n    \n            ";
m["ja function KinBody GetPassiveJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetPassiveJoints**\\()\n    \n    Returns the passive joints, order does not matter.\n    \n    A passive joint is not directly controlled by the body's degrees of freedom so it has no joint index and no dof index. Passive joints allows mimic joints to be hidden from the users. However, there are cases when passive joints are not mimic; for example, suspension mechanism on vehicles.         ";
m["ja function KinBody GetDependencyOrderedJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetDependencyOrderedJoints**\\()\n    \n    Returns the joints in hierarchical order starting at the base link.\n    \n    In the case of closed loops, the joints are returned in the order closest to the root. All the joints affecting a particular joint's transformation will always come before the joint in the list.         ";
m["ja function KinBody GetClosedLoops"] = "\n\nconst std::vector< std::vector< std::pair<  LinkPtr ,  JointPtr  > > > &  **GetClosedLoops**\\()\n    \n    Return the set of unique closed loops of the kinematics hierarchy.\n    \n    Each loop is a set of link indices and joint indices. For example, a loop of link indices: [l_0,l_1,l_2] will consist of three joints connecting l_0 to l_1, l_1 to l_2, and l_2 to l_0. The first element in the pair is the link l_X, the second element in the joint connecting l_X to l_(X+1).         ";
m["ja function KinBody GetRigidlyAttachedLinks"] = "\n\nvoid  **GetRigidlyAttachedLinks**\\(std::vector< boost::shared_ptr<  Link  > > & vattachedlinks)\n    \n    Gets all the rigidly attached links to linkindex, also adds the link to the list.\n    \n    *Parameters*\n     ``vattachedlinks`` - \n      the array to insert all links attached to linkindex with the link itself. \n            ";
m["ja function KinBody IsDOFInChain"] = "\n\nbool  **IsDOFInChain**\\(int linkindex1, int linkindex2, int dofindex)\n    \n    Returns true if the dof index affects the relative transformation between the two links.\n    \n    *Parameters*\n     ``linkindex1`` - \n      the link index to start the search \n     ``linkindex2`` - \n      the link index where the search ends The internal implementation uses KinBody::DoesAffect, therefore mimic indices are correctly handled. \n            ";
m["ja function KinBody GetJointIndex"] = "\n\nint  **GetJointIndex**\\(const std::string & name)\n    \n    Return the index of the joint with the given name, else -1.\n    \n            ";
m["ja function KinBody GetJoint"] = "\n\nJointPtr  **GetJoint**\\(const std::string & name)\n    \n    Return a pointer to the joint with the given name. Search in the regular and passive joints.\n    \n            ";
m["ja function KinBody GetJointFromDOFIndex"] = "\n\nJointPtr  **GetJointFromDOFIndex**\\(int dofindex)\n    \n    Returns the joint that covers the degree of freedom index.\n    \n    Note that the mapping of joint structures is not the same as the values in GetJointValues since each joint can have more than one degree of freedom.         ";
m["ja function KinBody GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    queries the transfromation of the first link of the body\n    \n            ";
m["ja function KinBody GetLinkTransformations"] = "\n\nvoid  **GetLinkTransformations**\\(std::vector<  Transform  > & transforms)\n    \n    get the transformations of all the links at once\n    \n            ";
m["ja function KinBody GetLinkTransformations"] = "\n\nvoid  **GetLinkTransformations**\\(std::vector<  Transform  > & transforms)\n    \n    get the transformations of all the links at once\n    \n            ";
m["ja function KinBody SetLinkTransformations"] = "\n\nvoid  **SetLinkTransformations**\\(const std::vector<  Transform  > & transforms)\n    \n    sets the transformations of all the links at once\n    \n            ";
m["ja function KinBody SetLinkTransformations"] = "\n\nvoid  **SetLinkTransformations**\\(const std::vector<  Transform  > & transforms)\n    \n    sets the transformations of all the links at once\n    \n            ";
m["ja function KinBody SetLinkVelocities"] = "\n\nvoid  **SetLinkVelocities**\\(const std::vector< std::pair<  Vector ,  Vector  > > & velocities)\n    \n    sets the link velocities\n    \n            ";
m["ja function KinBody SetVelocity \"const Vector; const Vector\""] = "\n\nbool  **SetVelocity**\\(const  Vector  & linearvel, const  Vector  & angularvel)\n    \n    Set the velocity of the base link, rest of links are set to a consistent velocity so entire robot moves correctly.\n    \n    *Parameters*\n     ``linearvel`` - \n      linear velocity \n     ``angularvel`` - \n      is the rotation axis * angular speed \n            ";
m["ja function KinBody SetDOFVelocities \"const std::vector; uint32_t\""] = "\n\nvoid  **SetDOFVelocities**\\(const std::vector<  dReal  > & dofvelocities, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the velocity of the joints.\n    \n    *Parameters*\n     ``dofvelocities`` - \n      - velocities of each of the degrees of freeom \n     ``checklimits`` - \n      if >0, will excplicitly check the joint velocity limits before setting the values and clamp them. If == 1, then will warn if the limits are overboard, if == 2, then will not warn (used for code that knows it's giving bad values) Copies the current velocity of the base link and calls SetDOFVelocities(linearvel,angularvel,vDOFVelocities) \n            ";
m["ja function KinBody SetDOFVelocities \"const std::vector; const Vector; const Vector; uint32_t\""] = "\n\nvoid  **SetDOFVelocities**\\(const std::vector<  dReal  > & dofvelocities, const  Vector  & linearvel, const  Vector  & angularvel, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the velocity of the base link and each of the joints.\n    \n    *Parameters*\n     ``linearvel`` - \n      linear velocity of base link \n     ``angularvel`` - \n      angular velocity rotation_axis*theta_dot \n     ``dofvelocities`` - \n      - velocities of each of the degrees of freeom \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint velocity limits before setting the values and clamp them. Computes internally what the correponding velocities of each of the links should be in order to achieve consistent results with the joint velocities. Sends the velocities to the physics engine. Velocities correspond to the link's coordinate system origin. \n            ";
m["ja function KinBody SetDOFVelocities \"const std::vector; uint32_t\""] = "\n\nvoid  **SetDOFVelocities**\\(const std::vector<  dReal  > & dofvelocities, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the velocity of the joints.\n    \n    *Parameters*\n     ``dofvelocities`` - \n      - velocities of each of the degrees of freeom \n     ``checklimits`` - \n      if >0, will excplicitly check the joint velocity limits before setting the values and clamp them. If == 1, then will warn if the limits are overboard, if == 2, then will not warn (used for code that knows it's giving bad values) Copies the current velocity of the base link and calls SetDOFVelocities(linearvel,angularvel,vDOFVelocities) \n            ";
m["ja function KinBody SetDOFVelocities \"const std::vector; const Vector; const Vector; uint32_t\""] = "\n\nvoid  **SetDOFVelocities**\\(const std::vector<  dReal  > & dofvelocities, const  Vector  & linearvel, const  Vector  & angularvel, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the velocity of the base link and each of the joints.\n    \n    *Parameters*\n     ``linearvel`` - \n      linear velocity of base link \n     ``angularvel`` - \n      angular velocity rotation_axis*theta_dot \n     ``dofvelocities`` - \n      - velocities of each of the degrees of freeom \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint velocity limits before setting the values and clamp them. Computes internally what the correponding velocities of each of the links should be in order to achieve consistent results with the joint velocities. Sends the velocities to the physics engine. Velocities correspond to the link's coordinate system origin. \n            ";
m["ja function KinBody GetLinkVelocities"] = "\n\nvoid  **GetLinkVelocities**\\(std::vector< std::pair<  Vector ,  Vector  > > & velocities)\n    \n    Returns the linear and angular velocities for each link.\n    \n    *Parameters*\n     ``velocities`` - \n      The velocities of the link frames with respect to the world coordinate system are returned. \n            ";
m["ja function KinBody GetLinkAccelerations"] = "\n\nvoid  **GetLinkAccelerations**\\(const std::vector<  dReal  > & dofaccelerations, std::vector< std::pair<  Vector ,  Vector  > > & linkaccelerations)\n    \n    Returns the linear and angular accelerations for each link given the dof accelerations.\n    \n    *Parameters*\n     ``dofaccelerations`` - \n      the accelerations of each of the DOF \n     ``linkaccelerations`` - \n      the linear and angular accelerations of link (in that order) Computes accelerations of the link frames with respect to the world coordinate system are returned. The base angular velocity is used when computing accelerations. The gravity vector from the physics engine is used as the accelerations for the base link and static links. The derivate is taken with respect to the world origin fixed in space (also known as spatial acceleration). The current angles and velocities set on the robot are used. Note that this function calls the internal _ComputeLinkAccelerations function, so for users that are interested in overriding it, override _ComputeLinkAccelerations \n            ";
m["ja function KinBody ComputeAABB"] = "\n\nAABB  **ComputeAABB**\\()\n    \n    Return an axis-aligned bounding box of the entire object in the world coordinate system.\n    \n            ";
m["ja function KinBody Enable"] = "\n\nvoid  **Enable**\\(bool enable)\n    \n    Enables or disables all the links.\n    \n            ";
m["ja function KinBody IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    *Return*\n        true if any link of the KinBody is enabled \n        ";
m["ja function KinBody SetVisible"] = "\n\nbool  **SetVisible**\\(bool visible)\n    \n    Sets all the links as visible or not visible.\n    \n    *Return*\n        true if changed \n        ";
m["ja function KinBody IsVisible"] = "\n\nbool  **IsVisible**\\()\n    \n    *Return*\n        true if any link of the KinBody is visible. \n        ";
m["ja function KinBody SetTransform"] = "\n\nvoid  **SetTransform**\\(const  Transform  & transform)\n    \n    \n    \n    *Parameters*\n     ``transform`` - \n       \n            ";
m["ja function KinBody SetDOFValues \"const std::vector; uint32_t; const std::vector\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = CLA_CheckLimits , const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody SetDOFValues \"const std::vector; uint32_t; const std::vector\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = CLA_CheckLimits , const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody SetDOFValues \"const std::vector; uint32_t; const std::vector\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = CLA_CheckLimits , const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody SetDOFValues \"const std::vector; uint32_t; const std::vector\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = CLA_CheckLimits , const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody SetDOFValues \"const std::vector; uint32_t; const std::vector\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = CLA_CheckLimits , const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n     ``dofindices`` - \n      the dof indices to return the values for. If empty, will compute for all the dofs \n            ";
m["ja function KinBody SubtractDOFValues"] = "\n\nvoid  **SubtractDOFValues**\\(std::vector<  dReal  > & values1, const std::vector<  dReal  > & values2, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Computes the configuration difference values1-values2 and stores it in values1.\n    \n    *Parameters*\n     ``inout]`` - \n      values1 the result is stored back in this \n     ``values2`` -\n      \n     ``dofindices`` - \n      the dof indices to compute the subtraction for. If empty, will compute for all the dofs Takes into account joint limits and wrapping of circular joints. \n            ";
m["ja function KinBody SetDOFTorques"] = "\n\nvoid  **SetDOFTorques**\\(const std::vector<  dReal  > & torques, bool add)\n    \n    Adds a torque to every joint.\n    \n    *Parameters*\n     ``bAdd`` - \n      if true, adds to previous torques, otherwise resets the torques on all bodies and starts from 0 \n            ";
m["ja function KinBody SetDOFTorques"] = "\n\nvoid  **SetDOFTorques**\\(const std::vector<  dReal  > & torques, bool add)\n    \n    Adds a torque to every joint.\n    \n    *Parameters*\n     ``bAdd`` - \n      if true, adds to previous torques, otherwise resets the torques on all bodies and starts from 0 \n            ";
m["ja function KinBody SetDOFValues \"const std::vector; const Transform; uint32_t\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, const  Transform  & transform, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the joint values and transformation of the body.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``transform`` - \n      represents the transformation of the first body. \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n            ";
m["ja function KinBody SetDOFValues \"const std::vector; const Transform; uint32_t\""] = "\n\nvoid  **SetDOFValues**\\(const std::vector<  dReal  > & values, const  Transform  & transform, uint32_t checklimits = CLA_CheckLimits )\n    \n    Sets the joint values and transformation of the body.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``transform`` - \n      represents the transformation of the first body. \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n            ";
m["ja function KinBody ComputeJacobianTranslation"] = "\n\nvoid  **ComputeJacobianTranslation**\\(int linkindex, const  Vector  & position, std::vector<  dReal  > & jacobian, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Computes the translation jacobian with respect to a world position.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that defines the frame the position is attached to \n     ``position`` - \n      position in world space where to compute derivatives from. \n     ``jacobian`` - \n      3xDOF matrix \n     ``dofindices`` - \n      the dof indices to compute the jacobian for. If empty, will compute for all the dofs Gets the jacobian with respect to a link by computing the partial differentials for all joints that in the path from the root node to GetLinks()[index] (doesn't touch the rest of the values) \n            ";
m["ja function KinBody ComputeJacobianAxisAngle"] = "\n\nvoid  **ComputeJacobianAxisAngle**\\(int linkindex, std::vector<  dReal  > & jacobian, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Computes the angular velocity jacobian of a specified link about the axes of world coordinates.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that the rotation is attached to \n     ``vjacobian`` - \n      3xDOF matrix \n            ";
m["ja function KinBody CalculateJacobian \"int; const Vector; std::vector\""] = "\n\nvoid  **CalculateJacobian**\\(int linkindex, const  Vector  & position, std::vector<  dReal  > & jacobian)\n    \n    calls std::vector version of ComputeJacobian internally\n    \n            ";
m["ja function KinBody CalculateRotationJacobian \"int; const Vector; std::vector\""] = "\n\nvoid  **CalculateRotationJacobian**\\(int linkindex, const  Vector  & quat, std::vector<  dReal  > & jacobian)\n    \n    Computes the rotational jacobian as a quaternion with respect to an initial rotation.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that the rotation is attached to \n     ``qInitialRot`` - \n      the rotation in world space whose derivative to take from. \n     ``jacobian`` - \n      4xDOF matrix \n            ";
m["ja function KinBody CalculateAngularVelocityJacobian \"int; std::vector\""] = "\n\nvoid  **CalculateAngularVelocityJacobian**\\(int linkindex, std::vector<  dReal  > & jacobian)\n    \n    Computes the angular velocity jacobian of a specified link about the axes of world coordinates.\n    \n            ";
m["ja function KinBody ComputeHessianTranslation"] = "\n\nvoid  **ComputeHessianTranslation**\\(int linkindex, const  Vector  & position, std::vector<  dReal  > & hessian, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Computes the DOFx3xDOF hessian of the linear translation.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that defines the frame the position is attached to / \n     ``position`` - \n      position in world space where to compute derivatives from. / \n     ``hessian`` - \n      DOFx3xDOF matrix such that numpy.dot(dq,numpy.dot(hessian,dq)) is the expected second-order delta translation / \n     ``dofindices`` - \n      the dof indices to compute the hessian for. If empty, will compute for all the dofs / \n            ";
m["ja function KinBody ComputeHessianAxisAngle"] = "\n\nvoid  **ComputeHessianAxisAngle**\\(int linkindex, std::vector<  dReal  > & hessian, const std::vector< int > & dofindices = std::vector< int >() )\n    \n    Computes the DOFx3xDOF hessian of the rotation represented as angle-axis.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that defines the frame the position is attached to / \n     ``hessian`` - \n      DOFx3xDOF matrix such that numpy.dot(dq,numpy.dot(hessian,dq)) is the expected second-order delta angle-axis / \n     ``dofindices`` - \n      the dof indices to compute the hessian for. If empty, will compute for all the dofs / \n            ";
m["ja function KinBody CheckSelfCollision"] = "\n\nbool  **CheckSelfCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    Check if body is self colliding. Links that are joined together are ignored.\n    \n            ";
m["ja function KinBody CheckSelfCollision"] = "\n\nbool  **CheckSelfCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    Check if body is self colliding. Links that are joined together are ignored.\n    \n            ";
m["ja function KinBody IsAttached"] = "\n\nbool  **IsAttached**\\(KinBodyConstPtr body)\n    \n    *Return*\n        true if two bodies should be considered as one during collision (ie one is grabbing the other) \n        ";
m["ja function KinBody GetAttached"] = "\n\nvoid  **GetAttached**\\(std::set<  KinBodyPtr  > & setAttached)\n    \n    Recursively get all attached bodies of this body, including this body.\n    \n    *Parameters*\n     ``setAttached`` - \n      fills with the attached bodies. If any bodies are already in setAttached, then ignores recursing on their attached bodies. \n            ";
m["ja function KinBody SetZeroConfiguration"] = "\n\nvoid  **SetZeroConfiguration**\\()\n    \n    Sets the joint offsets so that the current configuration becomes the new zero state of the robot.\n    \n    When this function returns, the returned DOF values should be all zero for controllable joints. Mimic equations will use the new offsetted values when computing their joints. This is primarily used for calibrating a robot's zero position         ";
m["ja function KinBody SetNonCollidingConfiguration"] = "\n\nvoid  **SetNonCollidingConfiguration**\\()\n    \n    Treats the current pose as a pose not in collision, which sets the adjacent pairs of links.\n    \n            ";
m["ja function KinBody GetConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n    return the configuration specification of the joint values and transform\n    \n    Note that the return type is by-value, so should not be used in iteration         ";
m["ja function KinBody GetConfigurationSpecificationIndices"] = "\n\nConfigurationSpecification  **GetConfigurationSpecificationIndices**\\(const std::vector< int > & indices, const std::string & interpolation = \"\" )\n    \n    return the configuration specification of the specified joint indices.\n    \n    Note that the return type is by-value, so should not be used in iteration         ";
m["ja function KinBody SetConfigurationValues"] = "\n\nvoid  **SetConfigurationValues**\\(std::vector<  dReal  >::const_iterator itvalues, uint32_t checklimits = CLA_CheckLimits )\n    \n    sets joint values and transform of the body using configuration values as specified by GetConfigurationSpecification()\n    \n    *Parameters*\n     ``itvalues`` - \n      the iterator to the vector containing the dof values. Must have GetConfigurationSpecification().GetDOF() values! \n     ``checklimits`` - \n      one of CheckLimitsAction and will excplicitly check the joint limits before setting the values and clamp them. \n            ";
m["ja function KinBody GetConfigurationValues"] = "\n\nvoid  **GetConfigurationValues**\\(std::vector<  dReal  > & v)\n    \n    returns the configuration values as specified by GetConfigurationSpecification()\n    \n            ";
m["ja function KinBody IsRobot"] = "\n\nbool  **IsRobot**\\()\n    \n    Return true if this body is derived from RobotBase.\n    \n            ";
m["ja function KinBody GetEnvironmentId"] = "\n\nint  **GetEnvironmentId**\\()\n    \n    return a unique id of the body used in the environment.\n    \n    If object is not added to the environment, this will return 0. So checking if GetEnvironmentId() is 0 is a good way to check if object is present in the environment. This id will not be copied when cloning in order to respect another environment's ids.         ";
m["ja function KinBody DoesAffect"] = "\n\nint8_t  **DoesAffect**\\(int jointindex, int linkindex)\n    \n    Returns a nonzero value if the joint effects the link transformation.\n    \n    *Parameters*\n     ``jointindex`` - \n      index of the joint \n     ``linkindex`` - \n      index of the link In closed loops, all joints on all paths to the root link are counted as affecting the link. If a mimic joint affects the link, then all the joints used in the mimic joint's computation affect the link. If negative, the partial derivative of the Jacobian should be negated. \n            ";
m["ja function KinBody GetViewerData"] = "\n\nUserDataPtr  **GetViewerData**\\()\n    \n    *See*\n        SetViewerData \n        ";
m["ja function KinBody GetViewerData"] = "\n\nUserDataPtr  **GetViewerData**\\()\n    \n    *See*\n        SetViewerData \n        ";
m["ja function InterfaceBase GetURI"] = "\n\nconst std::string &  **GetURI**\\()\n    \n    the URI used to load the interface (sometimes this is not possible if the definition lies inside an environment file).\n    \n            ";
m["ja function InterfaceBase GetURI"] = "\n\nconst std::string &  **GetURI**\\()\n    \n    the URI used to load the interface (sometimes this is not possible if the definition lies inside an environment file).\n    \n            ";
m["ja function KinBody GetNonAdjacentLinks"] = "\n\nconst std::set< int > &  **GetNonAdjacentLinks**\\(int adjacentoptions = 0 )\n    \n    return all possible link pairs that could get in collision.\n    \n    *Parameters*\n     ``adjacentoptions`` - \n      a bitmask of AdjacentOptions values \n            ";
m["ja function KinBody GetNonAdjacentLinks"] = "\n\nconst std::set< int > &  **GetNonAdjacentLinks**\\(int adjacentoptions = 0 )\n    \n    return all possible link pairs that could get in collision.\n    \n    *Parameters*\n     ``adjacentoptions`` - \n      a bitmask of AdjacentOptions values \n            ";
m["ja function KinBody GetAdjacentLinks"] = "\n\nconst std::set< int > &  **GetAdjacentLinks**\\()\n    \n    return all possible link pairs whose collisions are ignored.\n    \n            ";
m["ja function KinBody GetPhysicsData"] = "\n\nUserDataPtr  **GetPhysicsData**\\()\n    \n    *See*\n        SetPhysicsData \n        ";
m["ja function KinBody GetCollisionData"] = "\n\nUserDataPtr  **GetCollisionData**\\()\n    \n    SetCollisionData.\n    \n            ";
m["ja function KinBody GetManageData"] = "\n\nManageDataPtr  **GetManageData**\\()\n    \n            ";
m["ja function KinBody GetUpdateStamp"] = "\n\nint  **GetUpdateStamp**\\()\n    \n    Return a unique id for every transformation state change of any link. Used to check if robot state has changed.\n    \n    The stamp is used by the collision checkers, physics engines, or any other item that needs to keep track of any changes of the KinBody as it moves. Currently stamps monotonically increment for every transformation/joint angle change.         ";
m["ja function KinBody serialize"] = "\n\nvoid  **serialize**\\(std::ostream & o, int options)\n    \n    only used for hashes...\n    \n            ";
m["ja function KinBody GetKinematicsGeometryHash"] = "\n\nconst std::string &  **GetKinematicsGeometryHash**\\()\n    \n    A md5 hash unique to the particular kinematic and geometric structure of a KinBody.\n    \n    This 32 byte string can be used to check if two bodies have the same kinematic structure and can be used to index into tables when looking for body-specific models. OpenRAVE stores all such models in the OPENRAVE_HOME directory (usually ~/.openrave), indexed by the particular robot/body hashes.\n    \n    *Return*\n        md5 hash string of kinematics/geometry \n        ";
m["ja function KinBody::Link GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["ja function KinBody::Link GetIndex"] = "\n\nint  **GetIndex**\\()\n    \n    unique index into parent KinBody::GetLinks vector\n    \n            ";
m["ja function KinBody::Link Enable"] = "\n\nvoid  **Enable**\\(bool enable)\n    \n    Enables a Link. An enabled link takes part in collision detection and physics simulations.\n    \n            ";
m["ja function KinBody::Link IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    returns true if the link is enabled.\n    \n    *See*\n        Enable \n        ";
m["ja function KinBody::Link IsStatic"] = "\n\nbool  **IsStatic**\\()\n    \n    Indicates a static body that does not move with respect to the root link.\n    \n    Static should be used when an object has infinite mass and shouldn't be affected by physics (including gravity). Collision still works.         ";
m["ja function KinBody::Link SetVisible"] = "\n\nbool  **SetVisible**\\(bool visible)\n    \n    Sets all the geometries of the link as visible or non visible.\n    \n    *Return*\n        true if changed \n        ";
m["ja function KinBody::Link IsVisible"] = "\n\nbool  **IsVisible**\\()\n    \n    *Return*\n        true if any geometry of the link is visible. \n        ";
m["ja function KinBody::Link GetParent"] = "\n\nKinBodyPtr  **GetParent**\\()\n    \n    parent body that link belong to.\n    \n            ";
m["ja function KinBody::Link GetParentLinks"] = "\n\nvoid  **GetParentLinks**\\(std::vector< boost::shared_ptr<  Link  > > & vParentLinks)\n    \n    Return all the direct parent links in the kinematics hierarchy of this link.\n    \n    *Parameters*\n     ``filled`` - \n      with the parent links A parent link is is immediately connected to this link by a joint and has a path to the root joint so that it is possible to compute this link's transformation from its parent. \n            ";
m["ja function KinBody::Link IsParentLink"] = "\n\nbool  **IsParentLink**\\(boost::shared_ptr<  Link  const  > plink)\n    \n    Tests if a link is a direct parent.\n    \n    *Parameters*\n     ``link`` - \n      The link to test if it is one of the parents of this link.\n    \n    *See*\n        GetParentLinks \n        ";
m["ja function KinBody::Link GetCollisionData"] = "\n\nconst  TRIMESH  &  **GetCollisionData**\\()\n    \n            ";
m["ja function KinBody::Link ComputeAABB"] = "\n\nAABB  **ComputeAABB**\\()\n    \n    Compute the aabb of all the geometries of the link in the world coordinate system.\n    \n            ";
m["ja function KinBody::Link GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    Return the current transformation of the link in the world coordinate system.\n    \n            ";
m["ja function KinBody::Link GetCOMOffset"] = "\n\nVector  **GetCOMOffset**\\()\n    \n            ";
m["ja function KinBody::Link GetLocalCOM"] = "\n\nVector  **GetLocalCOM**\\()\n    \n    return center of mass offset in the link's local coordinate frame\n    \n            ";
m["ja function KinBody::Link GetGlobalCOM"] = "\n\nVector  **GetGlobalCOM**\\()\n    \n    return center of mass of the link in the global coordinate system\n    \n            ";
m["ja function KinBody::Link GetLocalInertia"] = "\n\nTransformMatrix  **GetLocalInertia**\\()\n    \n    return inertia in link's local coordinate frame. The translation component is the the COM in the link's frame.\n    \n            ";
m["ja function KinBody::Link GetPrincipalMomentsOfInertia"] = "\n\nconst  Vector  &  **GetPrincipalMomentsOfInertia**\\()\n    \n    return the principal moments of inertia inside the mass frame\n    \n            ";
m["ja function KinBody::Link GetLocalMassFrame"] = "\n\nconst  Transform  &  **GetLocalMassFrame**\\()\n    \n    return the mass frame in the link's local coordinate system that holds the center of mass and principal axes for inertia.\n    \n            ";
m["ja function KinBody::Link GetGlobalMassFrame"] = "\n\nTransform  **GetGlobalMassFrame**\\()\n    \n    return the mass frame in the global coordinate system that holds the center of mass and principal axes for inertia.\n    \n            ";
m["ja function KinBody::Link GetMass"] = "\n\ndReal  **GetMass**\\()\n    \n            ";
m["ja function KinBody::Link SetLocalMassFrame"] = "\n\nvoid  **SetLocalMassFrame**\\(const  Transform  & massframe)\n    \n    sets a new mass frame with respect to the link coordinate system\n    \n            ";
m["ja function KinBody::Link SetPrincipalMomentsOfInertia"] = "\n\nvoid  **SetPrincipalMomentsOfInertia**\\(const  Vector  & inertiamoments)\n    \n    sets new principal moments of inertia (with respect to the mass frame)\n    \n            ";
m["ja function KinBody::Link SetMass"] = "\n\nvoid  **SetMass**\\(dReal mass)\n    \n    set a new mass\n    \n            ";
m["ja function KinBody::Link SetStatic"] = "\n\nvoid  **SetStatic**\\(bool bStatic)\n    \n    sets a link to be static.\n    \n    Because this can affect the kinematics, it requires the body's internal structures to be recomputed         ";
m["ja function KinBody::Link SetTransform"] = "\n\nvoid  **SetTransform**\\(const  Transform  & transform)\n    \n    Sets the transform of the link regardless of kinematics.\n    \n    *Parameters*\n     ``t`` - \n      the new transformation \n            ";
m["ja function KinBody::Link SetForce"] = "\n\nvoid  **SetForce**\\(const  Vector  & force, const  Vector  & pos, bool add)\n    \n    *Parameters*\n     ``force`` - \n      the direction and magnitude of the force \n     ``pos`` - \n      in the world where the force is getting applied \n     ``add`` - \n      if true, force is added to previous forces, otherwise it is set adds an external force at pos (absolute coords) \n            ";
m["ja function KinBody::Link SetTorque"] = "\n\nvoid  **SetTorque**\\(const  Vector  & torque, bool add)\n    \n    *Parameters*\n     ``add`` - \n      if true, torque is added to previous torques, otherwise it is set adds torque to a body (absolute coords) \n            ";
m["ja function KinBody::Link GetGeometries"] = "\n\nconst std::vector<  GeometryPtr  > &  **GetGeometries**\\()\n    \n    returns a list of all the geometry objects.\n    \n            ";
m["ja function KinBody::Link GetRigidlyAttachedLinks"] = "\n\nvoid  **GetRigidlyAttachedLinks**\\(std::vector< boost::shared_ptr<  Link  > > & vattachedlinks)\n    \n    Gets all the rigidly attached links to linkindex, also adds the link to the list.\n    \n    *Parameters*\n     ``vattachedlinks`` - \n      the array to insert all links attached to linkindex with the link itself. \n            ";
m["ja function KinBody::Link IsRigidlyAttached"] = "\n\nbool  **IsRigidlyAttached**\\(boost::shared_ptr<  Link  const  > plink)\n    \n    returns true if plink is rigidily attahced to this link.\n    \n            ";
m["ja function KinBody::Link GetVelocity"] = "\n\nvoid  **GetVelocity**\\(Vector  & linearvel, Vector  & angularvel)\n    \n    get the velocity of the link\n    \n    *Parameters*\n     ``linearvel`` - \n      the translational velocity \n     ``angularvel`` - \n      is the rotation axis * angular speed \n            ";
m["ja function KinBody::Link SetVelocity"] = "\n\nvoid  **SetVelocity**\\(const  Vector  & linearvel, const  Vector  & angularvel)\n    \n    *Parameters*\n     ``linearvel`` - \n      the translational velocity \n     ``angularvel`` - \n      is the rotation axis * angular speed forces the velocity of the link \n            ";
m["ja function KinBody::Link::Geometry SetCollisionMesh"] = "\n\nvoid  **SetCollisionMesh**\\(const  TRIMESH  & mesh)\n    \n    sets a new collision mesh and notifies every registered callback about it\n    \n            ";
m["ja function KinBody::Link::Geometry GetCollisionMesh"] = "\n\nconst  TRIMESH  &  **GetCollisionMesh**\\()\n    \n    returns the local collision mesh\n    \n            ";
m["ja function KinBody::Link::Geometry ComputeAABB"] = "\n\nAABB  **ComputeAABB**\\(const  Transform  & trans)\n    \n    returns an axis aligned bounding box given that the geometry is transformed by trans\n    \n            ";
m["ja function KinBody::Link::Geometry SetDraw"] = "\n\nvoid  **SetDraw**\\(bool bDraw)\n    \n            ";
m["ja function KinBody::Link::Geometry SetTransparency"] = "\n\nvoid  **SetTransparency**\\(float f)\n    \n    set transparency level (0 is opaque)\n    \n            ";
m["ja function KinBody::Link::Geometry SetDiffuseColor"] = "\n\nvoid  **SetDiffuseColor**\\(const RaveVector< float > & color)\n    \n    override diffuse color of geometry material\n    \n            ";
m["ja function KinBody::Link::Geometry SetAmbientColor"] = "\n\nvoid  **SetAmbientColor**\\(const RaveVector< float > & color)\n    \n    override ambient color of geometry material\n    \n            ";
m["ja function KinBody::Link::Geometry SetRenderFilename"] = "\n\nvoid  **SetRenderFilename**\\(const std::string & renderfilename)\n    \n    sets a new render filename for the geometry. This does not change the collision\n    \n            ";
m["ja function KinBody::Link::Geometry IsDraw"] = "\n\nbool  **IsDraw**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry IsVisible"] = "\n\nbool  **IsVisible**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry IsModifiable"] = "\n\nbool  **IsModifiable**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry GetType"] = "\n\nGeomType  **GetType**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry GetTransform"] = "\n\nconst  Transform  &  **GetTransform**\\()\n    \n    get local geometry transform\n    \n            ";
m["ja function KinBody::Link::Geometry GetSphereRadius"] = "\n\ndReal  **GetSphereRadius**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry GetCylinderRadius"] = "\n\ndReal  **GetCylinderRadius**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry GetCylinderHeight"] = "\n\ndReal  **GetCylinderHeight**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry GetBoxExtents"] = "\n\nconst  Vector  &  **GetBoxExtents**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry GetRenderScale"] = "\n\nconst  Vector  &  **GetRenderScale**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry GetRenderFilename"] = "\n\nconst std::string &  **GetRenderFilename**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry GetTransparency"] = "\n\nfloat  **GetTransparency**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry GetDiffuseColor"] = "\n\nconst RaveVector< float > &  **GetDiffuseColor**\\()\n    \n            ";
m["ja function KinBody::Link::Geometry GetAmbientColor"] = "\n\nconst RaveVector< float > &  **GetAmbientColor**\\()\n    \n            ";
m["ja function KinBody::Joint GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n    The unique name of the joint.\n    \n            ";
m["ja function KinBody::Joint IsMimic"] = "\n\nbool  **IsMimic**\\(int axis = -1 )\n    \n    Returns true if a particular axis of the joint is mimiced.\n    \n    *Parameters*\n     ``axis`` - \n      the axis to query. When -1 returns true if any of the axes have mimic joints \n            ";
m["ja function KinBody::Joint GetMimicEquation"] = "\n\nstd::string  **GetMimicEquation**\\(int axis = 0 , int type = 0 , const std::string & format = \"\" )\n    \n    If the joint is mimic, returns the equation to compute its value.\n    \n    *Parameters*\n     ``axis`` - \n      the axis index \n     ``type`` - \n      0 for position, 1 for velocity, 2 for acceleration. \n     ``format`` - \n      the format the equations are returned in. If empty or \"fparser\", equation in fparser format. Also supports: \"mathml\".\n    MathML:Set 'format' to \"mathml\". The joint variables are specified with <csymbol>. If a targetted joint has more than one degree of freedom, then axis is suffixed with _%d. If 'type' is 1 or 2, the partial derivatives are outputted as consecutive <math></math> tags in the same order as MIMIC::_vdofformat         ";
m["ja function KinBody::Joint GetMimicDOFIndices"] = "\n\nvoid  **GetMimicDOFIndices**\\(std::vector< int > & vmimicdofs, int axis = 0 )\n    \n    Returns the set of DOF indices that the computation of a joint axis depends on. Order is arbitrary.\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      Throws an exception if the axis is not mimic. If the mimic joint uses the values of other mimic joints, then the dependent DOFs of that joint are also copied over. Therefore, the dof indices returned can be more than the actual variables used in the equation. \n            ";
m["ja function KinBody::Joint SetMimicEquations"] = "\n\nvoid  **SetMimicEquations**\\(int axis, const std::string & poseq, const std::string & veleq, const std::string & acceleq = \"\" )\n    \n    Sets the mimic properties of the joint.\n    \n    The equations can use the joint names directly in the equation, which represent the position of the joint. Any non-mimic joint part of KinBody::GetJoints() can be used in the computation of the values. If a joint has more than one degree of freedom, then suffix it '_' and the axis index. For example universaljoint_0 * 10 + sin(universaljoint_1).See  for a full description of the equation formats.The velocity and acceleration equations are specified in terms of partial derivatives, which means one expression needs to be specified per degree of freedom of used. In order to separate the expressions use \"|name ...\". The name should immediately follow '|'. For example:|universaljoint_0 10 |universaljoint_1 10*cos(universaljoint_1)If there is only one variable used in the position equation, then the equation can be specified directly without using \"{}\".\\ *Parameters*\n     ``axis`` - \n      the axis to set the properties for. \n     ``poseq`` - \n      Equation for joint's position. If it is empty, the mimic properties are turned off for this joint. \n     ``veleq`` - \n      First-order partial derivatives of poseq with respect to all used DOFs. Only the variables used in poseq are allowed to be used. If poseq is not empty, this is required. \n     ``acceleq`` - \n      Second-order partial derivatives of poseq with respect to all used DOFs. Only the variables used in poseq are allowed to be used. Optional. \\ *Exceptions*\n     ``openrave_exception`` - \n      Throws an exception if the mimic equation is invalid in any way.\n    \n            ";
m["ja function KinBody::Joint GetMaxVel"] = "\n\ndReal  **GetMaxVel**\\(int iaxis = 0 )\n    \n            ";
m["ja function KinBody::Joint GetMaxAccel"] = "\n\ndReal  **GetMaxAccel**\\(int iaxis = 0 )\n    \n            ";
m["ja function KinBody::Joint GetMaxTorque"] = "\n\ndReal  **GetMaxTorque**\\(int iaxis = 0 )\n    \n            ";
m["ja function KinBody::Joint GetDOFIndex"] = "\n\nint  **GetDOFIndex**\\()\n    \n    Get the degree of freedom index in the body's DOF array.\n    \n    This does not index in KinBody::GetJoints() directly! In other words, KinBody::GetDOFValues()[GetDOFIndex()] == GetValues()[0]         ";
m["ja function KinBody::Joint GetJointIndex"] = "\n\nint  **GetJointIndex**\\()\n    \n    Get the joint index into KinBody::GetJoints.\n    \n            ";
m["ja function KinBody::Joint GetParent"] = "\n\nKinBodyPtr  **GetParent**\\()\n    \n            ";
m["ja function KinBody::Joint GetFirstAttached"] = "\n\nLinkPtr  **GetFirstAttached**\\()\n    \n            ";
m["ja function KinBody::Joint GetSecondAttached"] = "\n\nLinkPtr  **GetSecondAttached**\\()\n    \n            ";
m["ja function KinBody::Joint IsStatic"] = "\n\nbool  **IsStatic**\\()\n    \n    Return true if joint can be treated as a static binding (ie all limits are 0)\n    \n            ";
m["ja function KinBody::Joint IsCircular"] = "\n\nbool  **IsCircular**\\(int iaxis)\n    \n    Return true if joint axis has an identification at some of its lower and upper limits.\n    \n    An identification of the lower and upper limits means that once the joint reaches its upper limits, it is also at its lower limit. The most common identification on revolute joints at -pi and pi. 'circularity' means the joint does not stop at limits. Although currently not developed, it could be possible to support identification for joints that are not revolute.         ";
m["ja function KinBody::Joint IsRevolute"] = "\n\nbool  **IsRevolute**\\(int iaxis)\n    \n    returns true if the axis describes a rotation around an axis.\n    \n    *Parameters*\n     ``iaxis`` - \n      the axis of the joint to return the results for \n            ";
m["ja function KinBody::Joint IsPrismatic"] = "\n\nbool  **IsPrismatic**\\(int iaxis)\n    \n    returns true if the axis describes a translation around an axis.\n    \n    *Parameters*\n     ``iaxis`` - \n      the axis of the joint to return the results for \n            ";
m["ja function KinBody::Joint GetType"] = "\n\nJointType  **GetType**\\()\n    \n            ";
m["ja function KinBody::Joint GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    The degrees of freedom of the joint. Each joint supports a max of 3 degrees of freedom.\n    \n            ";
m["ja function KinBody::Joint GetValues"] = "\n\nvoid  **GetValues**\\(std::vector<  dReal  > & values, bool bAppend = false )\n    \n    Return all the joint values with the correct offsets applied.\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it\n    \n    *Return*\n        degrees of freedom of the joint (even if pValues is NULL) \n        ";
m["ja function KinBody::Joint GetVelocities"] = "\n\nvoid  **GetVelocities**\\(std::vector<  dReal  > & values, bool bAppend = false )\n    \n    Gets the joint velocities.\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it\n    \n    *Return*\n        the degrees of freedom of the joint (even if pValues is NULL) \n        ";
m["ja function KinBody::Joint GetAnchor"] = "\n\nVector  **GetAnchor**\\()\n    \n    The anchor of the joint in global coordinates.\n    \n            ";
m["ja function KinBody::Joint GetAxis"] = "\n\nVector  **GetAxis**\\(int axis = 0 )\n    \n    The axis of the joint in global coordinates.\n    \n    *Parameters*\n     ``axis`` - \n      the axis to get \n            ";
m["ja function KinBody::Joint GetHierarchyParentLink"] = "\n\nLinkPtr  **GetHierarchyParentLink**\\()\n    \n    Return the parent link which the joint measures its angle off from (either GetFirstAttached() or GetSecondAttached())\n    \n            ";
m["ja function KinBody::Joint GetHierarchyChildLink"] = "\n\nLinkPtr  **GetHierarchyChildLink**\\()\n    \n    Return the child link whose transformation is computed by this joint's values (either GetFirstAttached() or GetSecondAttached())\n    \n            ";
m["ja function KinBody::Joint GetInternalHierarchyAxis"] = "\n\nVector  **GetInternalHierarchyAxis**\\(int axis = 0 )\n    \n    The axis of the joint in local coordinates.\n    \n            ";
m["ja function KinBody::Joint GetInternalHierarchyLeftTransform"] = "\n\nTransform  **GetInternalHierarchyLeftTransform**\\()\n    \n    Left multiply transform given the base body.\n    \n            ";
m["ja function KinBody::Joint GetInternalHierarchyRightTransform"] = "\n\nTransform  **GetInternalHierarchyRightTransform**\\()\n    \n    Right multiply transform given the base body.\n    \n            ";
m["ja function KinBody::Joint GetLimits"] = "\n\nvoid  **GetLimits**\\(std::vector<  dReal  > & vLowerLimit, std::vector<  dReal  > & vUpperLimit, bool bAppend = false )\n    \n    Get the limits of the joint.\n    \n    *Parameters*\n     ``vLowerLimit`` - \n      the lower limits \n     ``vUpperLimit`` - \n      the upper limits \n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["ja function KinBody::Joint GetVelocityLimits"] = "\n\nvoid  **GetVelocityLimits**\\(std::vector<  dReal  > & vmax, bool bAppend = false )\n    \n    Returns the max velocities of the joint.\n    \n    *Parameters*\n     ``the`` - \n      max velocity \n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["ja function KinBody::Joint GetAccelerationLimits"] = "\n\nvoid  **GetAccelerationLimits**\\(std::vector<  dReal  > & vmax, bool bAppend = false )\n    \n    Returns the max accelerations of the joint.\n    \n    *Parameters*\n     ``the`` - \n      max acceleration \n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["ja function KinBody::Joint GetTorqueLimits"] = "\n\nvoid  **GetTorqueLimits**\\(std::vector<  dReal  > & vmax, bool bAppend = false )\n    \n    Returns the max torques of the joint.\n    \n    *Parameters*\n     ``the`` - \n      max torque \n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["ja function KinBody::Joint SetWrapOffset"] = "\n\nvoid  **SetWrapOffset**\\(dReal offset, int iaxis = 0 )\n    \n    *See*\n        GetWrapOffset \n        ";
m["ja function KinBody::Joint GetWrapOffset"] = "\n\ndReal  **GetWrapOffset**\\(int iaxis = 0 )\n    \n    Return internal offset parameter that determines the branch the angle centers on.\n    \n    *Parameters*\n     ``iaxis`` - \n      the axis to get the offset from Wrap offsets are needed for rotation joints since the range is limited to 2*pi. This allows the wrap offset to be set so the joint can function in [-pi+offset,pi+offset].. \n            ";
m["ja function KinBody::Joint SetLimits"] = "\n\nvoid  **SetLimits**\\(const std::vector<  dReal  > & lower, const std::vector<  dReal  > & upper)\n    \n    *See*\n        GetLimits \n        ";
m["ja function KinBody::Joint SetVelocityLimits"] = "\n\nvoid  **SetVelocityLimits**\\(const std::vector<  dReal  > & vmax)\n    \n    *See*\n        GetVelocityLimits \n        ";
m["ja function KinBody::Joint SetAccelerationLimits"] = "\n\nvoid  **SetAccelerationLimits**\\(const std::vector<  dReal  > & vmax)\n    \n    *See*\n        GetAccelerationLimits \n        ";
m["ja function KinBody::Joint SetTorqueLimits"] = "\n\nvoid  **SetTorqueLimits**\\(const std::vector<  dReal  > & vmax)\n    \n    *See*\n        GetTorqueLimits \n        ";
m["ja function KinBody::Joint GetResolution"] = "\n\ndReal  **GetResolution**\\(int iaxis = 0 )\n    \n    The discretization of the joint used when line-collision checking.\n    \n    The resolutions are set as large as possible such that the joint will not go through obstacles of determined size.         ";
m["ja function KinBody::Joint GetResolutions"] = "\n\nvoid  **GetResolutions**\\(std::vector<  dReal  > & resolutions, bool bAppend = false )\n    \n    gets all resolutions for the joint axes\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["ja function KinBody::Joint SetResolution"] = "\n\nvoid  **SetResolution**\\(dReal resolution, int iaxis = 0 )\n    \n            ";
m["ja function KinBody::Joint GetWeight"] = "\n\ndReal  **GetWeight**\\(int axis = 0 )\n    \n    The weight associated with a joint's axis for computing a distance in the robot configuration space.\n    \n            ";
m["ja function KinBody::Joint GetWeights"] = "\n\nvoid  **GetWeights**\\(std::vector<  dReal  > & weights, bool bAppend = false )\n    \n    gets all weights for the joint axes\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it \n            ";
m["ja function KinBody::Joint SetWeights"] = "\n\nvoid  **SetWeights**\\(const std::vector<  dReal  > & weights)\n    \n    *See*\n        GetWeight \n        ";
m["ja function KinBody::Joint SubtractValues"] = "\n\nvoid  **SubtractValues**\\(std::vector<  dReal  > & values1, const std::vector<  dReal  > & values2)\n    \n    Computes the configuration difference values1-values2 and stores it in values1.\n    \n    Takes into account joint limits and wrapping of circular joints.         ";
m["ja function KinBody::Joint SubtractValue"] = "\n\ndReal  **SubtractValue**\\(dReal value1, dReal value2, int iaxis)\n    \n    Returns the configuration difference value1-value2 for axis i.\n    \n    Takes into account joint limits and wrapping of circular joints.         ";
m["ja function KinBody::Joint AddTorque"] = "\n\nvoid  **AddTorque**\\(const std::vector<  dReal  > & torques)\n    \n    Add effort (force or torque) to the joint.\n    \n            ";
m["ja function KinBody::KinBodyStateSaver  GetBody"] = "\n\nKinBodyPtr  **GetBody**\\()\n    \n            ";
m["ja function KinBody::KinBodyStateSaver  Restore"] = "\n\nvoid  **Restore**\\(boost::shared_ptr<  KinBody  > body = boost::shared_ptr<  KinBody  >() )\n    \n    restore the state\n    \n    *Parameters*\n     ``body`` - \n      if set, will attempt to restore the stored state to the passed in body, otherwise will restore it for the original body. \\ *Exceptions*\n     ``openrave_exception`` - \n      if the passed in body is not compatible with the saved state, will throw\n    \n            ";
m["ja function KinBody::KinBodyStateSaver  Release"] = "\n\nvoid  **Release**\\()\n    \n    release the body state. _pbody will not get restored on destruction\n    \n    After this call, it will still be possible to use Restore.         ";
m["ja function KinBody::ManageData GetSystem"] = "\n\nSensorSystemBasePtr  **GetSystem**\\()\n    \n            ";
m["ja function KinBody::ManageData GetData"] = "\n\nXMLReadableConstPtr  **GetData**\\()\n    \n    returns a pointer to the data used to initialize the BODY with AddKinBody. if psize is not NULL, will be filled with the size of the data in bytes This function will be used to restore bodies that were removed         ";
m["ja function KinBody::ManageData GetOffsetLink"] = "\n\nKinBody::LinkPtr  **GetOffsetLink**\\()\n    \n    particular link that sensor system is tracking. All transformations describe this link.         ";
m["ja function KinBody::ManageData IsPresent"] = "\n\nbool  **IsPresent**\\()\n    \n    true if the object is being updated by the system due to its presence in the real environment\n    \n            ";
m["ja function KinBody::ManageData IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    true if should update openrave body\n    \n            ";
m["ja function KinBody::ManageData IsLocked"] = "\n\nbool  **IsLocked**\\()\n    \n    if true, the vision system should not destroy this object once it stops being present\n    \n            ";
m["ja function KinBody::ManageData Lock"] = "\n\nbool  **Lock**\\(bool bDoLock)\n    \n    set a lock on a particular body\n    \n            ";
m["ja function RobotBase GetManipulators"] = "\n\nstd::vector<  ManipulatorPtr  > &  **GetManipulators**\\()\n    \n    Returns the manipulators of the robot.\n    \n            ";
m["ja function RobotBase GetManipulators"] = "\n\nstd::vector<  ManipulatorPtr  > &  **GetManipulators**\\()\n    \n    Returns the manipulators of the robot.\n    \n            ";
m["ja function RobotBase SetActiveManipulator \"int\""] = "\n\nvoid  **SetActiveManipulator**\\(int index)\n    \n            ";
m["ja function RobotBase SetActiveManipulator \"const std::string\""] = "\n\nvoid  **SetActiveManipulator**\\(const std::string & manipname)\n    \n    sets the active manipulator of the robot\n    \n    *Parameters*\n     ``manipname`` - \n      manipulator name \\ *Exceptions*\n     ``openrave_exception`` - \n      if manipulator not present, will throw an exception\n    \n            ";
m["ja function RobotBase GetActiveManipulator"] = "\n\nManipulatorPtr  **GetActiveManipulator**\\()\n    \n            ";
m["ja function RobotBase AddManipulator"] = "\n\nManipulatorPtr  **AddManipulator**\\(const  ManipulatorInfo  & manipinfo)\n    \n    adds a manipulator the list\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      If there exists a manipulator with the same name, will throw an exception Will copy the information of this manipulator object into a new manipulator and initialize it with the robot. Will change the robot structure hash..\n    \n    *Return*\n        the new manipulator attached to the robot \n        ";
m["ja function RobotBase RemoveManipulator"] = "\n\nvoid  **RemoveManipulator**\\(ManipulatorPtr manip)\n    \n    removes a manipulator from the robot list.\n    \n    Will change the robot structure hash.. if the active manipulator is set to this manipulator, it will be set to None afterwards         ";
m["ja function RobotBase GetActiveManipulatorIndex"] = "\n\nint  **GetActiveManipulatorIndex**\\()\n    \n            ";
m["ja function RobotBase GetAttachedSensors"] = "\n\nstd::vector<  AttachedSensorPtr  > &  **GetAttachedSensors**\\()\n    \n            ";
m["ja function RobotBase GetController"] = "\n\nControllerBasePtr  **GetController**\\()\n    \n    gets the robot controller\n    \n            ";
m["ja function RobotBase SetController"] = "\n\nbool  **SetController**\\(ControllerBasePtr controller, const std::vector< int > & dofindices, int nControlTransformation)\n    \n    set a controller for a robot\n    \n    *Parameters*\n     ``pController`` - \n      - if NULL, sets the controller of this robot to NULL. otherwise attemps to set the controller to this robot. \n     ``args`` - \n      - the argument list to pass when initializing the controller \n            ";
m["ja function RobotBase SetController"] = "\n\nbool  **SetController**\\(ControllerBasePtr controller, const std::vector< int > & dofindices, int nControlTransformation)\n    \n    set a controller for a robot\n    \n    *Parameters*\n     ``pController`` - \n      - if NULL, sets the controller of this robot to NULL. otherwise attemps to set the controller to this robot. \n     ``args`` - \n      - the argument list to pass when initializing the controller \n            ";
m["ja function RobotBase SetController"] = "\n\nbool  **SetController**\\(ControllerBasePtr controller, const std::vector< int > & dofindices, int nControlTransformation)\n    \n    set a controller for a robot\n    \n    *Parameters*\n     ``pController`` - \n      - if NULL, sets the controller of this robot to NULL. otherwise attemps to set the controller to this robot. \n     ``args`` - \n      - the argument list to pass when initializing the controller \n            ";
m["ja function RobotBase SetActiveDOFs \"const std::vector; int\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine = OpenRAVE::DOF_NoTransform )\n    \n    Set the joint indices and affine transformation dofs that the planner should use. If DOF_RotationAxis is specified, the previously set axis is used.\n    \n    *Parameters*\n     ``dofindices`` - \n      the indices of the original degrees of freedom to use. \n     ``affine`` - \n      A bitmask of DOFAffine values \n            ";
m["ja function RobotBase SetActiveDOFs \"const std::vector; int\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine = OpenRAVE::DOF_NoTransform )\n    \n    Set the joint indices and affine transformation dofs that the planner should use. If DOF_RotationAxis is specified, the previously set axis is used.\n    \n    *Parameters*\n     ``dofindices`` - \n      the indices of the original degrees of freedom to use. \n     ``affine`` - \n      A bitmask of DOFAffine values \n            ";
m["ja function RobotBase SetActiveDOFs \"const std::vector; int; const Vector\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine, const  Vector  & rotationaxis)\n    \n    Set the joint indices and affine transformation dofs that the planner should use. If DOF_RotationAxis is specified, then rotationaxis is set as the new axis.\n    \n    *Parameters*\n     ``dofindices`` - \n      the indices of the original degrees of freedom to use. \n     ``affine`` - \n      A bitmask of DOFAffine values \n     ``rotationaxis`` - \n      if DOF_RotationAxis is specified, pRotationAxis is used as the new axis \n            ";
m["ja function RobotBase GetActiveDOF"] = "\n\nint  **GetActiveDOF**\\()\n    \n            ";
m["ja function RobotBase GetAffineDOF"] = "\n\nint  **GetAffineDOF**\\()\n    \n            ";
m["ja function RobotBase GetAffineDOFIndex"] = "\n\nint  **GetAffineDOFIndex**\\(DOFAffine dof)\n    \n            ";
m["ja function RobotBase GetAffineRotationAxis"] = "\n\nVector  **GetAffineRotationAxis**\\()\n    \n            ";
m["ja function RobotBase SetAffineTranslationLimits"] = "\n\nvoid  **SetAffineTranslationLimits**\\(const  Vector  & lower, const  Vector  & upper)\n    \n            ";
m["ja function RobotBase SetAffineRotationAxisLimits"] = "\n\nvoid  **SetAffineRotationAxisLimits**\\(const  Vector  & lower, const  Vector  & upper)\n    \n            ";
m["ja function RobotBase SetAffineRotation3DLimits"] = "\n\nvoid  **SetAffineRotation3DLimits**\\(const  Vector  & lower, const  Vector  & upper)\n    \n            ";
m["ja function RobotBase SetAffineRotationQuatLimits"] = "\n\nvoid  **SetAffineRotationQuatLimits**\\(const  Vector  & quatangle)\n    \n    sets the quaternion limits using a starting rotation and the max angle deviation from it.\n    \n    *Parameters*\n     ``quatangle`` - \n      quaternion_start * max_angle. acos(q dot quaternion_start) <= max_angle. If max_angle is 0, then will take the current transform of the robot \n            ";
m["ja function RobotBase SetAffineTranslationMaxVels"] = "\n\nvoid  **SetAffineTranslationMaxVels**\\(const  Vector  & vels)\n    \n            ";
m["ja function RobotBase SetAffineRotationAxisMaxVels"] = "\n\nvoid  **SetAffineRotationAxisMaxVels**\\(const  Vector  & vels)\n    \n            ";
m["ja function RobotBase SetAffineRotation3DMaxVels"] = "\n\nvoid  **SetAffineRotation3DMaxVels**\\(const  Vector  & vels)\n    \n            ";
m["ja function RobotBase SetAffineRotationQuatMaxVels"] = "\n\nvoid  **SetAffineRotationQuatMaxVels**\\(dReal vels)\n    \n            ";
m["ja function RobotBase SetAffineTranslationResolution"] = "\n\nvoid  **SetAffineTranslationResolution**\\(const  Vector  & resolution)\n    \n            ";
m["ja function RobotBase SetAffineRotationAxisResolution"] = "\n\nvoid  **SetAffineRotationAxisResolution**\\(const  Vector  & resolution)\n    \n            ";
m["ja function RobotBase SetAffineRotation3DResolution"] = "\n\nvoid  **SetAffineRotation3DResolution**\\(const  Vector  & resolution)\n    \n            ";
m["ja function RobotBase SetAffineRotationQuatResolution"] = "\n\nvoid  **SetAffineRotationQuatResolution**\\(dReal resolution)\n    \n            ";
m["ja function RobotBase SetAffineTranslationWeights"] = "\n\nvoid  **SetAffineTranslationWeights**\\(const  Vector  & weights)\n    \n            ";
m["ja function RobotBase SetAffineRotationAxisWeights"] = "\n\nvoid  **SetAffineRotationAxisWeights**\\(const  Vector  & weights)\n    \n            ";
m["ja function RobotBase SetAffineRotation3DWeights"] = "\n\nvoid  **SetAffineRotation3DWeights**\\(const  Vector  & weights)\n    \n            ";
m["ja function RobotBase SetAffineRotationQuatWeights"] = "\n\nvoid  **SetAffineRotationQuatWeights**\\(dReal weights)\n    \n            ";
m["ja function RobotBase GetAffineTranslationLimits"] = "\n\nvoid  **GetAffineTranslationLimits**\\(Vector  & lower, Vector  & upper)\n    \n            ";
m["ja function RobotBase GetAffineRotationAxisLimits"] = "\n\nvoid  **GetAffineRotationAxisLimits**\\(Vector  & lower, Vector  & upper)\n    \n            ";
m["ja function RobotBase GetAffineRotation3DLimits"] = "\n\nvoid  **GetAffineRotation3DLimits**\\(Vector  & lower, Vector  & upper)\n    \n            ";
m["ja function RobotBase GetAffineRotationQuatLimits"] = "\n\nVector  **GetAffineRotationQuatLimits**\\()\n    \n    gets the quaternion limits\n    \n    *Parameters*\n     ``quatangle`` - \n      quaternion_start * max_angle. acos(q dot quaternion_start) <= max_angle \n            ";
m["ja function RobotBase GetAffineTranslationMaxVels"] = "\n\nVector  **GetAffineTranslationMaxVels**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationAxisMaxVels"] = "\n\nVector  **GetAffineRotationAxisMaxVels**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotation3DMaxVels"] = "\n\nVector  **GetAffineRotation3DMaxVels**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationQuatMaxVels"] = "\n\ndReal  **GetAffineRotationQuatMaxVels**\\()\n    \n            ";
m["ja function RobotBase GetAffineTranslationResolution"] = "\n\nVector  **GetAffineTranslationResolution**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationAxisResolution"] = "\n\nVector  **GetAffineRotationAxisResolution**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotation3DResolution"] = "\n\nVector  **GetAffineRotation3DResolution**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationQuatResolution"] = "\n\ndReal  **GetAffineRotationQuatResolution**\\()\n    \n            ";
m["ja function RobotBase GetAffineTranslationWeights"] = "\n\nVector  **GetAffineTranslationWeights**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationAxisWeights"] = "\n\nVector  **GetAffineRotationAxisWeights**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotation3DWeights"] = "\n\nVector  **GetAffineRotation3DWeights**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationQuatWeights"] = "\n\ndReal  **GetAffineRotationQuatWeights**\\()\n    \n            ";
m["ja function RobotBase SetActiveDOFValues"] = "\n\nvoid  **SetActiveDOFValues**\\(const std::vector<  dReal  > & values, uint32_t checklimits = 1 )\n    \n            ";
m["ja function RobotBase GetActiveDOFValues"] = "\n\nvoid  **GetActiveDOFValues**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function RobotBase GetActiveDOFWeights"] = "\n\nvoid  **GetActiveDOFWeights**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function RobotBase SetActiveDOFVelocities"] = "\n\nvoid  **SetActiveDOFVelocities**\\(const std::vector<  dReal  > & velocities, uint32_t checklimits = 1 )\n    \n            ";
m["ja function RobotBase GetActiveDOFVelocities"] = "\n\nvoid  **GetActiveDOFVelocities**\\(std::vector<  dReal  > & velocities)\n    \n            ";
m["ja function RobotBase GetActiveDOFLimits"] = "\n\nvoid  **GetActiveDOFLimits**\\(std::vector<  dReal  > & lower, std::vector<  dReal  > & upper)\n    \n            ";
m["ja function RobotBase GetActiveDOFMaxVel"] = "\n\nvoid  **GetActiveDOFMaxVel**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function RobotBase GetActiveDOFMaxAccel"] = "\n\nvoid  **GetActiveDOFMaxAccel**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function RobotBase GetActiveDOFResolutions"] = "\n\nvoid  **GetActiveDOFResolutions**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function RobotBase GetActiveConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetActiveConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n    return a copy of the configuration specification of the active dofs\n    \n    Note that the return type is by-value, so should not be used in iteration         ";
m["ja function RobotBase GetActiveDOFIndices"] = "\n\nconst std::vector< int > &  **GetActiveDOFIndices**\\()\n    \n    Return the set of active dof indices of the joints.\n    \n            ";
m["ja function RobotBase SubtractActiveDOFValues"] = "\n\nvoid  **SubtractActiveDOFValues**\\(std::vector<  dReal  > & q1, const std::vector<  dReal  > & q2)\n    \n    computes the configuration difference q1-q2 and stores it in q1. Takes into account joint limits and circular joints\n    \n            ";
m["ja function RobotBase CalculateActiveJacobian \"int; const Vector; std::vector\""] = "\n\nvoid  **CalculateActiveJacobian**\\(int index, const  Vector  & offset, std::vector<  dReal  > & jacobian)\n    \n    Calculates the translation jacobian with respect to a link.\n    \n    *Parameters*\n     ``mjacobian`` - \n      a 3 x ActiveDOF matrix Calculates the partial differentials for the active degrees of freedom that in the path from the root node to _veclinks[index] (doesn't touch the rest of the values). \n            ";
m["ja function RobotBase CalculateActiveRotationJacobian \"int; const Vector; std::vector\""] = "\n\nvoid  **CalculateActiveRotationJacobian**\\(int index, const  Vector  & qInitialRot, std::vector<  dReal  > & jacobian)\n    \n            ";
m["ja function RobotBase CalculateActiveAngularVelocityJacobian \"int; std::vector\""] = "\n\nvoid  **CalculateActiveAngularVelocityJacobian**\\(int index, std::vector<  dReal  > & jacobian)\n    \n    Calculates the angular velocity jacobian of a specified link about the axes of world coordinates.\\ *Parameters*\n     ``index`` - \n      of the link that the rotation is attached to \n     ``mjacobian`` - \n      3x(num ACTIVE DOF) matrix \n            ";
m["ja function RobotBase Grab \"KinBodyPtr\""] = "\n\nbool  **Grab**\\(KinBodyPtr body)\n    \n    Grabs the body with the active manipulator's end effector.\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["ja function RobotBase Grab \"KinBodyPtr; const std::set\""] = "\n\nbool  **Grab**\\(KinBodyPtr body, const std::set< int > & setRobotLinksToIgnore)\n    \n    Grabs the body with the active manipulator's end effector.\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``setRobotLinksToIgnore`` - \n      Additional robot link indices that collision checker ignore when checking collisions between the grabbed body and the robot.\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["ja function RobotBase Grab \"KinBodyPtr; LinkPtr\""] = "\n\nbool  **Grab**\\(KinBodyPtr body, LinkPtr pRobotLinkToGrabWith)\n    \n    Grab a body with the specified link.\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``pRobotLinkToGrabWith`` - \n      the link of this robot that will perform the grab\n    \n    *Return*\n        true if successful and body is grabbed/ \n        ";
m["ja function RobotBase Grab \"KinBodyPtr; LinkPtr; const std::set\""] = "\n\nbool  **Grab**\\(KinBodyPtr body, LinkPtr pRobotLinkToGrabWith, const std::set< int > & setRobotLinksToIgnore)\n    \n    Grab the body with the specified link.\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``pRobotLinkToGrabWith`` - \n      the link of this robot that will perform the grab \n     ``setRobotLinksToIgnore`` - \n      Additional robot link indices that collision checker ignore when checking collisions between the grabbed body and the robot.\n    \n    *Return*\n        true if successful and body is grabbed. \n        ";
m["ja function RobotBase Release"] = "\n\nvoid  **Release**\\(KinBodyPtr body)\n    \n    Release the body if grabbed.\n    \n    *Parameters*\n     ``body`` - \n      body to release \n            ";
m["ja function RobotBase ReleaseAllGrabbed"] = "\n\nvoid  **ReleaseAllGrabbed**\\()\n    \n    Release all grabbed bodies.\n    \n    release all bodies         ";
m["ja function RobotBase RegrabAll"] = "\n\nvoid  **RegrabAll**\\()\n    \n    Releases and grabs all bodies, has the effect of recalculating all the initial collision with the bodies.\n    \n    This has the effect of resetting the current collisions any grabbed body makes with the robot into an ignore list.         ";
m["ja function RobotBase IsGrabbing"] = "\n\nLinkPtr  **IsGrabbing**\\(KinBodyConstPtr body)\n    \n    return the robot link that is currently grabbing the body. If the body is not grabbed, will return an empty pointer.\n    \n    *Parameters*\n     ``body`` - \n      the body to check \n            ";
m["ja function RobotBase GetGrabbed"] = "\n\nvoid  **GetGrabbed**\\(std::vector<  KinBodyPtr  > & vbodies)\n    \n    gets all grabbed bodies of the robot\n    \n    *Parameters*\n     ``vbodies`` - \n      filled with the grabbed bodies \n            ";
m["ja function RobotBase GetRobotStructureHash"] = "\n\nconst std::string &  **GetRobotStructureHash**\\()\n    \n    A md5 hash unique to the particular robot structure that involves manipulation and sensing components The serialization for the attached sensors will not involve any sensor specific properties (since they can change through calibration)         ";
m["ja function RobotBase::Manipulator GetIkParameterization \"const IkParameterization; bool\""] = "\n\nIkParameterization  **GetIkParameterization**\\(const  IkParameterization  & ikparam, bool inworld = true )\n    \n    returns a full parameterization of a given IK type for the current manipulator position using an existing IkParameterization as the seed.\n    \n    *Parameters*\n     ``ikparam`` - \n      The parameterization to use as seed. \n     ``inworld`` - \n      if true will return the parameterization in the world coordinate system, otherwise in the base link (GetBase()) coordinate system Custom data is copied to the new parameterization. Furthermore, some IK types like Lookat3D and TranslationLocalGlobal6D set constraints in the global coordinate system of the manipulator. Because these values are not stored in manipulator itself, they have to be passed in through an existing IkParameterization. Ideally pluging the returned ik parameterization into FindIkSolution should return the a manipulator configuration such that a new call to GetIkParameterization returns the same values. \n            ";
m["ja function RobotBase::Manipulator GetIkParameterization \"IkParameterizationType; bool\""] = "\n\nIkParameterization  **GetIkParameterization**\\(IkParameterizationType iktype, bool inworld = true )\n    \n    returns the parameterization of a given IK type for the current manipulator position.\n    \n    *Parameters*\n     ``iktype`` - \n      the type of parameterization to request \n     ``inworld`` - \n      if true will return the parameterization in the world coordinate system, otherwise in the base link (GetBase()) coordinate system Ideally pluging the returned ik parameterization into FindIkSolution should return the a manipulator configuration such that a new call to GetIkParameterization returns the same values. In other words:  \n            ";
m["ja function RobotBase::Manipulator GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    Return the transformation of the manipulator frame.\n    \n    The manipulator frame is defined by the the end effector link position * GetLocalToolTransform() All inverse kinematics and jacobian queries are specifying this frame.         ";
m["ja function RobotBase::Manipulator GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    Return the transformation of the manipulator frame.\n    \n    The manipulator frame is defined by the the end effector link position * GetLocalToolTransform() All inverse kinematics and jacobian queries are specifying this frame.         ";
m["ja function RobotBase::Manipulator GetVelocity"] = "\n\nstd::pair<  Vector ,  Vector  >  **GetVelocity**\\()\n    \n    return the linear/angular velocity of the manipulator coordinate system\n    \n            ";
m["ja function RobotBase::Manipulator GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["ja function RobotBase::Manipulator SetName"] = "\n\nvoid  **SetName**\\(const std::string & name)\n    \n    new name for manipulator\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      if name is already used in another manipulator \n            ";
m["ja function RobotBase::Manipulator GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\()\n    \n            ";
m["ja function RobotBase::Manipulator SetIkSolver"] = "\n\nbool  **SetIkSolver**\\(IkSolverBasePtr iksolver)\n    \n    Sets the ik solver and initializes it with the current manipulator.\n    \n    Due to complications with translation,rotation,direction,and ray ik, the ik solver should take into account the grasp transform (_info._tLocalTool) internally. The actual ik primitives are transformed into the base frame only.         ";
m["ja function RobotBase::Manipulator GetIkSolver"] = "\n\nIkSolverBasePtr  **GetIkSolver**\\()\n    \n    Returns the currently set ik solver.\n    \n            ";
m["ja function RobotBase::Manipulator SetIkSolver"] = "\n\nbool  **SetIkSolver**\\(IkSolverBasePtr iksolver)\n    \n    Sets the ik solver and initializes it with the current manipulator.\n    \n    Due to complications with translation,rotation,direction,and ray ik, the ik solver should take into account the grasp transform (_info._tLocalTool) internally. The actual ik primitives are transformed into the base frame only.         ";
m["ja function RobotBase::Manipulator GetNumFreeParameters"] = "\n\nint  **GetNumFreeParameters**\\()\n    \n    Number of free parameters defining the null solution space.\n    \n    Each parameter is always in the range of [0,1].         ";
m["ja function RobotBase::Manipulator GetFreeParameters"] = "\n\nbool  **GetFreeParameters**\\(std::vector<  dReal  > & vFreeParameters)\n    \n    gets the free parameters from the current robot configuration\n    \n    *Parameters*\n     ``vFreeParameters`` - \n      is filled with GetNumFreeParameters() parameters in [0,1] range\n    \n    *Return*\n        true if succeeded \n        ";
m["ja function RobotBase::Manipulator FindIKSolution \"const IkParameterization; std::vector; int\""] = "\n\nbool  **FindIKSolution**\\(const  IkParameterization  & param, std::vector<  dReal  > & solution, int filteroptions)\n    \n    Find a close solution to the current robot's joint values.\n    \n    *Parameters*\n     ``param`` - \n      The transformation of the end-effector in the global coord system \n     ``solution`` - \n      Will be of size GetArmIndices().size() and contain the best solution \n     ``filteroptions`` - \n      A bitmask of IkFilterOptions values controlling what is checked for each ik solution. The function is a wrapper around the IkSolver interface. Note that the solution returned is not guaranteed to be the closest solution. In order to compute that, will have to compute all the ik solutions using FindIKSolutions. \n            ";
m["ja function RobotBase::Manipulator FindIKSolution \"const IkParameterization; const std::vector; std::vector; int\""] = "\n\nbool  **FindIKSolution**\\(const  IkParameterization  & param, const std::vector<  dReal  > & vFreeParameters, std::vector<  dReal  > & solution, int filteroptions)\n    \n            ";
m["ja function RobotBase::Manipulator FindIKSolutions \"const IkParameterization; std::vector; int\""] = "\n\nbool  **FindIKSolutions**\\(const  IkParameterization  & param, std::vector< std::vector<  dReal  > > & solutions, int filteroptions)\n    \n    Find all the IK solutions for the given end effector transform.\n    \n    *Parameters*\n     ``param`` - \n      The transformation of the end-effector in the global coord system \n     ``solutions`` - \n      An array of all solutions, each element in solutions is of size GetArmIndices().size() \n     ``filteroptions`` - \n      A bitmask of IkFilterOptions values controlling what is checked for each ik solution. \n            ";
m["ja function RobotBase::Manipulator FindIKSolutions \"const IkParameterization; const std::vector; std::vector; int\""] = "\n\nbool  **FindIKSolutions**\\(const  IkParameterization  & param, const std::vector<  dReal  > & vFreeParameters, std::vector< std::vector<  dReal  > > & solutions, int filteroptions)\n    \n            ";
m["ja function RobotBase::Manipulator GetBase"] = "\n\nLinkPtr  **GetBase**\\()\n    \n    the base used for the iksolver\n    \n            ";
m["ja function RobotBase::Manipulator GetEndEffector"] = "\n\nLinkPtr  **GetEndEffector**\\()\n    \n    the end effector link (used to define workspace distance)\n    \n            ";
m["ja function RobotBase::Manipulator GetLocalToolTransform"] = "\n\nTransform  **GetLocalToolTransform**\\()\n    \n    Return transform with respect to end effector defining the grasp coordinate system.\n    \n            ";
m["ja function RobotBase::Manipulator GetLocalToolTransform"] = "\n\nTransform  **GetLocalToolTransform**\\()\n    \n    Return transform with respect to end effector defining the grasp coordinate system.\n    \n            ";
m["ja function RobotBase::Manipulator SetLocalToolTransform"] = "\n\nvoid  **SetLocalToolTransform**\\(const  Transform  & t)\n    \n    Sets the local tool transform with respect to the end effector.\n    \n    Because this call will change manipulator hash, it resets the loaded IK and sets the Prop_RobotManipulatorTool message.         ";
m["ja function RobotBase::Manipulator GetGripperIndices"] = "\n\nconst std::vector< int > &  **GetGripperIndices**\\()\n    \n    Gripper indices of the joints that the manipulator controls.\n    \n            ";
m["ja function RobotBase::Manipulator GetGripperIndices"] = "\n\nconst std::vector< int > &  **GetGripperIndices**\\()\n    \n    Gripper indices of the joints that the manipulator controls.\n    \n            ";
m["ja function RobotBase::Manipulator GetArmIndices"] = "\n\nconst std::vector< int > &  **GetArmIndices**\\()\n    \n    Return the indices of the DOFs of the arm (used for IK, etc).\n    \n    Usually the DOF indices from pBase to pEndEffector         ";
m["ja function RobotBase::Manipulator GetArmIndices"] = "\n\nconst std::vector< int > &  **GetArmIndices**\\()\n    \n    Return the indices of the DOFs of the arm (used for IK, etc).\n    \n    Usually the DOF indices from pBase to pEndEffector         ";
m["ja function RobotBase::Manipulator GetClosingDirection"] = "\n\nconst std::vector<  dReal  > &  **GetClosingDirection**\\()\n    \n    return the normal direction to move joints to 'close' the hand\n    \n            ";
m["ja function RobotBase::Manipulator GetLocalToolDirection"] = "\n\nVector  **GetLocalToolDirection**\\()\n    \n    direction of palm/head/manipulator used for approaching. defined inside the manipulator/grasp coordinate system\n    \n            ";
m["ja function RobotBase::Manipulator GetLocalToolDirection"] = "\n\nVector  **GetLocalToolDirection**\\()\n    \n    direction of palm/head/manipulator used for approaching. defined inside the manipulator/grasp coordinate system\n    \n            ";
m["ja function RobotBase::Manipulator GetLocalToolDirection"] = "\n\nVector  **GetLocalToolDirection**\\()\n    \n    direction of palm/head/manipulator used for approaching. defined inside the manipulator/grasp coordinate system\n    \n            ";
m["ja function RobotBase::Manipulator IsGrabbing"] = "\n\nbool  **IsGrabbing**\\(KinBodyConstPtr body)\n    \n    Checks collision with a target body and all the independent links of the robot. Ignores disabled links.\n    \n    *Parameters*\n     ``the`` - \n      body to check the independent links with \n     ``report`` - \n      [optional] collision report\n    \n    *Return*\n        true if a collision occurredreturn true if the body is being grabbed by any link on this manipulator \n        ";
m["ja function RobotBase::Manipulator GetChildJoints"] = "\n\nvoid  **GetChildJoints**\\(std::vector<  JointPtr  > & vjoints)\n    \n    Get all child joints of the manipulator starting at the pEndEffector link.\n    \n            ";
m["ja function RobotBase::Manipulator GetChildDOFIndices"] = "\n\nvoid  **GetChildDOFIndices**\\(std::vector< int > & vdofndices)\n    \n    Get all child DOF indices of the manipulator starting at the pEndEffector link.\n    \n            ";
m["ja function RobotBase::Manipulator GetChildLinks"] = "\n\nvoid  **GetChildLinks**\\(std::vector<  LinkPtr  > & vlinks)\n    \n    Get all child links of the manipulator starting at pEndEffector link.\n    \n    The child links do not include the arm links.         ";
m["ja function RobotBase::Manipulator IsChildLink"] = "\n\nbool  **IsChildLink**\\(LinkConstPtr plink)\n    \n    returns true if a link is part of the child links of the manipulator.\n    \n    The child links do not include the arm links.         ";
m["ja function RobotBase::Manipulator GetIndependentLinks"] = "\n\nvoid  **GetIndependentLinks**\\(std::vector<  LinkPtr  > & vlinks)\n    \n    Get all links that are independent of the arm and gripper joints.\n    \n    In other words, returns all links not on the path from the base to the end effector and not children of the end effector. The base and all links rigidly attached to it are also returned.         ";
m["ja function RobotBase::Manipulator GetArmConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetArmConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n    return a copy of the configuration specification of the arm indices\n    \n    Note that the return type is by-value, so should not be used in iteration         ";
m["ja function RobotBase::Manipulator CheckEndEffectorCollision"] = "\n\nbool  **CheckEndEffectorCollision**\\(const  Transform  & tEE, CollisionReportPtr report = CollisionReportPtr () )\n    \n    Checks collision with only the gripper given its end-effector transform. Ignores disabled links.\n    \n    *Parameters*\n     ``tEE`` - \n      the end effector transform \n     ``report`` - \n      [optional] collision report\n    \n    *Return*\n        true if a collision occurred \n        ";
m["ja function RobotBase::Manipulator CheckEndEffectorCollision"] = "\n\nbool  **CheckEndEffectorCollision**\\(const  Transform  & tEE, CollisionReportPtr report = CollisionReportPtr () )\n    \n    Checks collision with only the gripper given its end-effector transform. Ignores disabled links.\n    \n    *Parameters*\n     ``tEE`` - \n      the end effector transform \n     ``report`` - \n      [optional] collision report\n    \n    *Return*\n        true if a collision occurred \n        ";
m["ja function RobotBase::Manipulator CheckIndependentCollision"] = "\n\nbool  **CheckIndependentCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    Checks collision with the environment with all the independent links of the robot. Ignores disabled links.\n    \n    *Parameters*\n     ``report`` - \n      [optional] collision report\n    \n    *Return*\n        true if a collision occurred \n        ";
m["ja function RobotBase::Manipulator CheckIndependentCollision"] = "\n\nbool  **CheckIndependentCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    Checks collision with the environment with all the independent links of the robot. Ignores disabled links.\n    \n    *Parameters*\n     ``report`` - \n      [optional] collision report\n    \n    *Return*\n        true if a collision occurred \n        ";
m["ja function RobotBase::Manipulator CalculateJacobian"] = "\n\nvoid  **CalculateJacobian**\\(std::vector<  dReal  > & jacobian)\n    \n    computes the jacobian of the manipulator arm indices of the current manipulator frame world position.\n    \n    The manipulator frame is computed from Manipulator::GetTransform()         ";
m["ja function RobotBase::Manipulator CalculateRotationJacobian"] = "\n\nvoid  **CalculateRotationJacobian**\\(std::vector<  dReal  > & jacobian)\n    \n    computes the quaternion jacobian of the manipulator arm indices from the current manipulator frame rotation.\n    \n            ";
m["ja function RobotBase::Manipulator CalculateAngularVelocityJacobian"] = "\n\nvoid  **CalculateAngularVelocityJacobian**\\(std::vector<  dReal  > & jacobian)\n    \n    computes the angule axis jacobian of the manipulator arm indices.\n    \n            ";
m["ja function RobotBase::Manipulator GetStructureHash"] = "\n\nconst std::string &  **GetStructureHash**\\()\n    \n    Return hash of just the manipulator definition.\n    \n            ";
m["ja function RobotBase::Manipulator GetKinematicsStructureHash"] = "\n\nconst std::string &  **GetKinematicsStructureHash**\\()\n    \n    Return hash of all kinematics information that involves solving the inverse kinematics equations.\n    \n    This includes joint axes, joint positions, and final grasp transform. Hash is used to cache the solvers.         ";
m["ja function RobotBase::AttachedSensor GetSensor"] = "\n\nSensorBasePtr  **GetSensor**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetAttachingLink"] = "\n\nLinkPtr  **GetAttachingLink**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetRelativeTransform"] = "\n\nTransform  **GetRelativeTransform**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetData"] = "\n\nSensorBase::SensorDataPtr  **GetData**\\()\n    \n    retrieves the current data from the sensor\n    \n            ";
m["ja function RobotBase::AttachedSensor SetRelativeTransform"] = "\n\nvoid  **SetRelativeTransform**\\(const  Transform  & t)\n    \n            ";
m["ja function RobotBase::AttachedSensor GetStructureHash"] = "\n\nconst std::string &  **GetStructureHash**\\()\n    \n    *Return*\n        hash of the sensor definition \n        ";
m["ja function Robot::RobotStateSaver  GetBody"] = "\n\nKinBodyPtr  **GetBody**\\()\n    \n            ";
m["ja function Robot::RobotStateSaver  Restore"] = "\n\nvoid  **Restore**\\(boost::shared_ptr<  KinBody  > body = boost::shared_ptr<  KinBody  >() )\n    \n    restore the state\n    \n    *Parameters*\n     ``body`` - \n      if set, will attempt to restore the stored state to the passed in body, otherwise will restore it for the original body. \\ *Exceptions*\n     ``openrave_exception`` - \n      if the passed in body is not compatible with the saved state, will throw\n    \n            ";
m["ja function Robot::RobotStateSaver  Release"] = "\n\nvoid  **Release**\\()\n    \n    release the body state. _pbody will not get restored on destruction\n    \n    After this call, it will still be possible to use Restore.         ";
m["ja function RaveCreateRobot"] = "\n\nOPENRAVE_API   RobotBasePtr  **RaveCreateRobot**\\(EnvironmentBasePtr penv, const std::string & name = \"\" )\n    \n            ";
m["ja function RaveCreateKinBody"] = "\n\nOPENRAVE_API   KinBodyPtr  **RaveCreateKinBody**\\(EnvironmentBasePtr penv, const std::string & name = \"\" )\n    \n            ";
m["ja function SensorBase Configure"] = "\n\nint  **Configure**\\(ConfigureCommand command, bool blocking = false )\n    \n    Configures properties of the sensor like power.\n    \n    *Parameters*\n     ``type`` - \n      ConfigureCommand \n     ``blocking`` - \n      If set to true, makes sure the configuration ends before this function returns.(might cause problems if environment is locked). \\ *Exceptions*\n     ``openrave_exception`` - \n      if command doesn't succeed\n    \n            ";
m["ja function SensorBase GetSensorData"] = "\n\nbool  **GetSensorData**\\(SensorDataPtr psensordata)\n    \n    Copy the most recent published data of the sensor given the type.\n    \n    *Parameters*\n     ``psensordata`` - \n      A pointer to SensorData returned from CreateSensorData, the plugin will use psensordata->GetType() in order to return the correctly supported type. Once GetSensorData returns, the caller has full unrestricted access to the data. This method is thread safe. \n            ";
m["ja function SensorBase GetSensorData"] = "\n\nbool  **GetSensorData**\\(SensorDataPtr psensordata)\n    \n    Copy the most recent published data of the sensor given the type.\n    \n    *Parameters*\n     ``psensordata`` - \n      A pointer to SensorData returned from CreateSensorData, the plugin will use psensordata->GetType() in order to return the correctly supported type. Once GetSensorData returns, the caller has full unrestricted access to the data. This method is thread safe. \n            ";
m["ja function SensorBase GetSensorGeometry"] = "\n\nSensorGeometryPtr  **GetSensorGeometry**\\(SensorType type = ST_Invalid )\n    \n    Returns the sensor geometry. This method is thread safe.\n    \n    *Parameters*\n     ``type`` - \n      the requested sensor type to create. A sensor can support many types. If type is ST_Invalid, then returns a data structure\n    \n    *Return*\n        sensor geometry pointer, use delete to destroy it \n        ";
m["ja function SensorBase SetTransform"] = "\n\nvoid  **SetTransform**\\(const  Transform  & trans)\n    \n    Set the transform of a sensor (global coordinate system).\n    \n    *Parameters*\n     ``trans`` - \n      - The transform defining the frame of the sensor. Sensors attached to the robot have their transforms automatically set every time the robot is moved \n            ";
m["ja function SensorBase GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    the position of the sensor in the world coordinate system\n    \n            ";
m["ja function SensorBase GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n    *Return*\n        the name of the sensor \n        ";
m["ja function SensorBase Supports"] = "\n\nbool  **Supports**\\(SensorType type)\n    \n    returns true if sensor supports a particular sensor type\n    \n            ";
m["ja function RaveCreateSensor"] = "\n\nOPENRAVE_API   SensorBasePtr  **RaveCreateSensor**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function CollisionCheckerBase SetCollisionOptions \"int\""] = "\n\nbool  **SetCollisionOptions**\\(int collisionoptions)\n    \n    Set basic collision options using the CollisionOptions enum.\n    \n            ";
m["ja function CollisionCheckerBase GetCollisionOptions"] = "\n\nint  **GetCollisionOptions**\\()\n    \n    get the current collision options\n    \n            ";
m["ja function RaveCreateCollisionChecker"] = "\n\nOPENRAVE_API   CollisionCheckerBasePtr  **RaveCreateCollisionChecker**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function IkParameterization GetType"] = "\n\nIkParameterizationType  **GetType**\\()\n    \n            ";
m["ja function IkParameterization SetTransform6D"] = "\n\nvoid  **SetTransform6D**\\(const  Transform  & t)\n    \n            ";
m["ja function IkParameterization SetRotation3D"] = "\n\nvoid  **SetRotation3D**\\(const  Vector  & quaternion)\n    \n            ";
m["ja function IkParameterization SetTranslation3D"] = "\n\nvoid  **SetTranslation3D**\\(const  Vector  & trans)\n    \n            ";
m["ja function IkParameterization SetDirection3D"] = "\n\nvoid  **SetDirection3D**\\(const  Vector  & dir)\n    \n            ";
m["ja function IkParameterization SetRay4D"] = "\n\nvoid  **SetRay4D**\\(const  RAY  & ray)\n    \n            ";
m["ja function IkParameterization SetLookat3D"] = "\n\nvoid  **SetLookat3D**\\(const  Vector  & trans)\n    \n            ";
m["ja function IkParameterization SetTranslationDirection5D"] = "\n\nvoid  **SetTranslationDirection5D**\\(const  RAY  & ray)\n    \n            ";
m["ja function IkParameterization SetTranslationXY2D"] = "\n\nvoid  **SetTranslationXY2D**\\(const  Vector  & trans)\n    \n            ";
m["ja function IkParameterization SetTranslationXYOrientation3D"] = "\n\nvoid  **SetTranslationXYOrientation3D**\\(const  Vector  & trans)\n    \n            ";
m["ja function IkParameterization SetTranslationLocalGlobal6D"] = "\n\nvoid  **SetTranslationLocalGlobal6D**\\(const  Vector  & localtrans, const  Vector  & trans)\n    \n            ";
m["ja function IkParameterization SetTranslationXAxisAngle4D"] = "\n\nvoid  **SetTranslationXAxisAngle4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["ja function IkParameterization SetTranslationYAxisAngle4D"] = "\n\nvoid  **SetTranslationYAxisAngle4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["ja function IkParameterization SetTranslationZAxisAngle4D"] = "\n\nvoid  **SetTranslationZAxisAngle4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["ja function IkParameterization SetTranslationXAxisAngleZNorm4D"] = "\n\nvoid  **SetTranslationXAxisAngleZNorm4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["ja function IkParameterization SetTranslationYAxisAngleXNorm4D"] = "\n\nvoid  **SetTranslationYAxisAngleXNorm4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["ja function IkParameterization SetTranslationZAxisAngleYNorm4D"] = "\n\nvoid  **SetTranslationZAxisAngleYNorm4D**\\(const  Vector  & trans, dReal angle)\n    \n            ";
m["ja function IkParameterization GetTransform6D"] = "\n\nconst  Transform  &  **GetTransform6D**\\()\n    \n            ";
m["ja function IkParameterization GetRotation3D"] = "\n\nconst  Vector  &  **GetRotation3D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslation3D"] = "\n\nconst  Vector  &  **GetTranslation3D**\\()\n    \n            ";
m["ja function IkParameterization GetDirection3D"] = "\n\nconst  Vector  &  **GetDirection3D**\\()\n    \n            ";
m["ja function IkParameterization GetRay4D"] = "\n\nconst  RAY  **GetRay4D**\\()\n    \n            ";
m["ja function IkParameterization GetLookat3D"] = "\n\nconst  Vector  &  **GetLookat3D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslationDirection5D"] = "\n\nconst  RAY  **GetTranslationDirection5D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslationXY2D"] = "\n\nconst  Vector  &  **GetTranslationXY2D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslationXYOrientation3D"] = "\n\nconst  Vector  &  **GetTranslationXYOrientation3D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslationLocalGlobal6D"] = "\n\nstd::pair<  Vector ,  Vector  >  **GetTranslationLocalGlobal6D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslationXAxisAngle4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationXAxisAngle4D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslationYAxisAngle4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationYAxisAngle4D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslationZAxisAngle4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationZAxisAngle4D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslationXAxisAngleZNorm4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationXAxisAngleZNorm4D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslationYAxisAngleXNorm4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationYAxisAngleXNorm4D**\\()\n    \n            ";
m["ja function IkParameterization GetTranslationZAxisAngleYNorm4D"] = "\n\nstd::pair<  Vector ,  dReal  >  **GetTranslationZAxisAngleYNorm4D**\\()\n    \n            ";
m["ja function IkParameterization GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    Returns the minimum degree of freedoms required for the IK type. Does  count custom data.\n    \n            ";
m["ja function IkParameterization GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    Returns the minimum degree of freedoms required for the IK type. Does  count custom data.\n    \n            ";
m["ja function IkParameterization GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    Returns the minimum degree of freedoms required for the IK type. Does  count custom data.\n    \n            ";
m["ja function IkParameterization GetNumberOfValues"] = "\n\nint  **GetNumberOfValues**\\()\n    \n    Returns the number of values used to represent the parameterization ( >= dof ). Does  count custom data.\n    \n            ";
m["ja function IkParameterization GetNumberOfValues"] = "\n\nint  **GetNumberOfValues**\\()\n    \n    Returns the number of values used to represent the parameterization ( >= dof ). Does  count custom data.\n    \n            ";
m["ja function IkParameterization GetNumberOfValues"] = "\n\nint  **GetNumberOfValues**\\()\n    \n    Returns the number of values used to represent the parameterization ( >= dof ). Does  count custom data.\n    \n            ";
m["ja function IkParameterization GetConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n            ";
m["ja function IkParameterization GetConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n            ";
m["ja function IkParameterization GetConfigurationSpecification"] = "\n\nConfigurationSpecification  **GetConfigurationSpecification**\\(const std::string & interpolation = \"\" )\n    \n            ";
m["ja function IkParameterization ComputeDistanceSqr"] = "\n\ndReal  **ComputeDistanceSqr**\\(const  IkParameterization  & ikparam)\n    \n    Computes the distance squared between two IK parmaeterizations.\n    \n            ";
m["ja function IkParameterization MultiplyTransform"] = "\n\nIkParameterization  &  **MultiplyTransform**\\(const  Transform  & t)\n    \n    in-place left-transform into a new coordinate system. Equivalent to t * ikparam\n    \n            ";
m["ja function IkParameterization GetValues"] = "\n\nvoid  **GetValues**\\(std::vector<  dReal  >::iterator itvalues)\n    \n    fills the iterator with the serialized values of the ikparameterization.\n    \n    The container the iterator points to needs to have GetNumberOfValues() available. Does not support custom data Don't normalize quaternions since it could hold velocity data.         ";
m["ja function IkParameterization SetValues"] = "\n\nvoid  **SetValues**\\(std::vector<  dReal  >::const_iterator itvalues, IkParameterizationType iktype)\n    \n    sets a serialized set of values for the IkParameterization\n    \n    Function does not handle custom data. Don't normalize quaternions since it could hold velocity data.         ";
m["ja function IkParameterization GetCustomDataMap"] = "\n\nconst std::map< std::string, std::vector<  dReal  > > &  **GetCustomDataMap**\\()\n    \n    returns a const reference of the custom data key/value pairs\n    \n            ";
m["ja function IkParameterization GetCustomValues"] = "\n\nbool  **GetCustomValues**\\(const std::string & name, std::vector<  dReal  > & values)\n    \n    gets custom data if it exists, returns false if it doesn't\n    \n            ";
m["ja function IkParameterization SetCustomValues"] = "\n\nvoid  **SetCustomValues**\\(const std::string & name, const std::vector<  dReal  > & values)\n    \n    sets named custom data in the ik parameterization\n    \n    The custom data is serialized along with the rest of the parameters and can also be part of a configuration specification under the \"ikparam_values\" anotation. The custom data name can have meta-tags for the type of transformation the data undergos when MultiplyTransform is called. For example, if the user wants to have an extra 3 values that represent \"direction\", then the direction has to be rotated along with all the data or coordinate systems can get lost. The anotations are specified by putting: somewhere in the string. The s can be: , , ,  If , the first value is expected to be the unique id of the ik type (GetType()&IKP_UniqueIdMask). The other values can be computed from IkParameterization::GetValues\\ *Parameters*\n     ``name`` - \n      Describes the type of data, cannot contain spaces or new lines. \n     ``values`` - \n      the values representing the data \\ *Exceptions*\n     ``openrave_exception`` - \n      throws if the name is invalid\n    \n            ";
m["ja function IkParameterization SetCustomValue"] = "\n\nvoid  **SetCustomValue**\\(const std::string & name, dReal value)\n    \n    sets named custom data in the ik parameterization (\n    \n    *See*\n        SetCustomValues) \n        ";
m["ja function IkParameterization ClearCustomValues"] = "\n\nsize_t  **ClearCustomValues**\\(const std::string & name = std::string() )\n    \n    clears custom data\n    \n    *Parameters*\n     ``name`` - \n      if name is empty, will clear all the data, otherwise will clear only the custom data with that name\n    \n    *Return*\n        number of elements erased \n        ";
m["ja function InterfaceBase SendCommand"] = "\n\nbool  **SendCommand**\\(std::ostream & os, std::istream & is)\n    \n    Used to send special commands to the interface and receive output.\n    \n    The command must be registered by RegisterCommand. A special command ' is always supported and provides a way for the user to query the current commands and the help string. The format of the returned help commands are in reStructuredText. The following commands are possible:\n    *Parameters*\n     ``is`` - \n      the input stream containing the command \n     ``os`` - \n      the output stream containing the output \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if the command is not supported.\n    \n    *Return*\n        true if the command is successfully processed, otherwise false. \n        ";
m["ja function InterfaceBase GetInterfaceType"] = "\n\nInterfaceType  **GetInterfaceType**\\()\n    \n            ";
m["ja function InterfaceBase GetXMLId"] = "\n\nconst std::string &  **GetXMLId**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the unique identifier that describes this class type, case is ignored should be the same id used to create the object \n        ";
m["ja function InterfaceBase GetPluginName"] = "\n\nconst std::string &  **GetPluginName**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the pluginname this interface was loaded from \n        ";
m["ja function InterfaceBase GetDescription"] = "\n\nconst std::string &  **GetDescription**\\()\n    \n    Documentation of the interface in reStructuredText format. See Documenting Interfaces.\n    \n            ";
m["ja function InterfaceBase SetDescription"] = "\n\nvoid  **SetDescription**\\(const std::string & description)\n    \n            ";
m["ja function InterfaceBase GetEnv"] = "\n\nEnvironmentBasePtr  **GetEnv**\\()\n    \n    *Return*\n        the environment that this interface is attached to \n        ";
m["ja function InterfaceBase Clone"] = "\n\nvoid  **Clone**\\(InterfaceBaseConstPtr preference, int cloningoptions)\n    \n    Clone the contents of an interface to the current interface.\n    \n    *Parameters*\n     ``preference`` - \n      the interface whose information to clone \n     ``cloningoptions`` - \n      mask of CloningOptions \\ *Exceptions*\n     ``openrave_exception`` - \n      if command doesn't succeed\n    \n            ";
m["ja function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["ja function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["ja function InterfaceBase GetUserData"] = "\n\nUserDataPtr  **GetUserData**\\()\n    \n    return the user custom data\n    \n            ";
m["ja function InterfaceBase GetReadableInterfaces"] = "\n\nconst  READERSMAP  &  **GetReadableInterfaces**\\()\n    \n            ";
m["ja function InterfaceBase SetReadableInterface"] = "\n\nXMLReadablePtr  **SetReadableInterface**\\(const std::string & xmltag, XMLReadablePtr readable)\n    \n    set a new readable interface and return the previously set interface if it exists\n    \n            ";
m["ja function EnvironmentBase Reset"] = "\n\nvoid  **Reset**\\()\n    \n    Resets all objects of the scene (preserves all problems, planners).\n    \n    Do not call inside a SimulationStep call         ";
m["ja function EnvironmentBase Destroy"] = "\n\nvoid  **Destroy**\\()\n    \n    Releases all environment resources, should be always called when environment stops being used.\n    \n    Removing all environment pointer might not be enough to destroy the environment resources.         ";
m["ja function EnvironmentBase CloneSelf"] = "\n\nEnvironmentBasePtr  **CloneSelf**\\(int options)\n    \n    Create and return a clone of the current environment.\n    \n    *Parameters*\n     ``options`` - \n      A set of CloningOptions describing what is actually cloned. Clones do not share any memory or resource between each other. or their parent making them ideal for performing separte planning experiments while keeping the parent environment unchanged. By default a clone only copies the collision checkers and physics engine. When bodies are cloned, the unique ids are preserved across environments (each body can be referenced with its id in both environments). The attached and grabbed bodies of each body/robot are also copied to the new environment.\n    \n    *Return*\n        An environment of the same type as this environment containing the copied information. \n        ";
m["ja function EnvironmentBase Clone"] = "\n\nvoid  **Clone**\\(EnvironmentBaseConstPtr preference, int cloningoptions)\n    \n    Clones the reference environment into the current environment.\n    \n    *Parameters*\n     ``cloningoptions`` - \n      The parts of the environment to clone. Parts not specified are left as is. Tries to preserve computation by re-using bodies/interfaces that are already similar between the current and reference environments. \n            ";
m["ja function EnvironmentBase SetCollisionChecker"] = "\n\nbool  **SetCollisionChecker**\\(CollisionCheckerBasePtr pchecker)\n    \n    set the global environment collision checker\n    \n            ";
m["ja function EnvironmentBase GetCollisionChecker"] = "\n\nCollisionCheckerBasePtr  **GetCollisionChecker**\\()\n    \n            ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, KinBodyConstPtr pbody2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, KinBodyConstPtr pbody2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink1, KinBody::LinkConstPtr plink2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink1, KinBody::LinkConstPtr plink2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase LoadURI"] = "\n\nbool  **LoadURI**\\(const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from a URI and adds all objects in the environment.\n    \n    Currently only collada files are supported. Options are passed through to          ";
m["ja function EnvironmentBase Load"] = "\n\nbool  **Load**\\(const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from a file and adds all objects in the environment.\n    \n    For collada readers, the options are passed through to          ";
m["ja function EnvironmentBase Load"] = "\n\nbool  **Load**\\(const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from a file and adds all objects in the environment.\n    \n    For collada readers, the options are passed through to          ";
m["ja function EnvironmentBase LoadData"] = "\n\nbool  **LoadData**\\(const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from in-memory data and adds all objects in the environment.\n    \n            ";
m["ja function EnvironmentBase LoadData"] = "\n\nbool  **LoadData**\\(const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Loads a scene from in-memory data and adds all objects in the environment.\n    \n            ";
m["ja function EnvironmentBase Save"] = "\n\nvoid  **Save**\\(const std::string & filename, SelectionOptions options = SO_Everything , const  AttributesList  & atts = AttributesList () )\n    \n    Saves a scene depending on the filename extension. Default is in COLLADA format.\n    \n    *Parameters*\n     ``filename`` - \n      the filename to save the results at \n     ``options`` - \n      controls what to save \n     ``atts`` - \n      attributes that refine further options. For collada parsing, the options are passed through  Several default options are:\n      \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to save anything\n    \n            ";
m["ja function EnvironmentBase ReadRobotURI \"const std::string\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(const std::string & filename)\n    \n    Creates a new robot from a file with no extra load options specified.\n    \n            ";
m["ja function EnvironmentBase ReadRobotURI \"const std::string\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(const std::string & filename)\n    \n    Creates a new robot from a file with no extra load options specified.\n    \n            ";
m["ja function EnvironmentBase ReadRobotURI \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(RobotBasePtr robot, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a robot from a resource file. The robot is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. \n            ";
m["ja function EnvironmentBase ReadRobotURI \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotURI**\\(RobotBasePtr robot, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a robot from a resource file. The robot is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. \n            ";
m["ja function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadRobotData \"RobotBasePtr; const std::string; const AttributesList\""] = "\n\nRobotBasePtr  **ReadRobotData**\\(RobotBasePtr robot, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initialize a robot from in-memory data.\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Robot Concepts. The robot should not be added the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadKinBodyURI \"const std::string\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(const std::string & filename)\n    \n    Creates a new kinbody from an XML file with no extra load options specified.\n    \n            ";
m["ja function EnvironmentBase ReadKinBodyURI \"const std::string\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(const std::string & filename)\n    \n    Creates a new kinbody from an XML file with no extra load options specified.\n    \n            ";
m["ja function EnvironmentBase ReadKinBodyURI \"KinBody; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(KinBodyPtr body, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from a resource file. The body is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. \n            ";
m["ja function EnvironmentBase ReadKinBodyURI \"KinBody; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyURI**\\(KinBodyPtr body, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from a resource file. The body is not added to the environment when calling this function.\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. \n            ";
m["ja function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadKinBodyData \"KinBodyPtr; const std::string; const AttributesList\""] = "\n\nKinBodyPtr  **ReadKinBodyData**\\(KinBodyPtr body, const std::string & data, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes a kinematic body from in-memory data.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      The attribute/value pair specifying loading options. Defined in Kinematics Body Concepts. The body should not be added to the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["ja function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["ja function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["ja function EnvironmentBase ReadInterfaceURI \"InterfaceBasePtr; InterfaceType; const std::string; const AttributesList\""] = "\n\nInterfaceBasePtr  **ReadInterfaceURI**\\(InterfaceBasePtr pinterface, InterfaceType type, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    Initializes an interface from a resource file.\n    \n    *Parameters*\n     ``pinterface`` - \n      If a null pointer is passed, a new interface will be created, otherwise an existing interface will be filled \n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. See Resource File Formats. \n     ``atts`` - \n      The attribute/value pair specifying loading options. See the individual interface descriptions at Base Interface Concepts. \n            ";
m["ja function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["ja function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["ja function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["ja function EnvironmentBase ReadTrimeshURI"] = "\n\nboost::shared_ptr<  KinBody::Link::TRIMESH  >  **ReadTrimeshURI**\\(boost::shared_ptr<  KinBody::Link::TRIMESH  > ptrimesh, const std::string & filename, const  AttributesList  & atts = AttributesList () )\n    \n    reads in the rigid geometry of a resource file into a TRIMESH structure\n    \n    *Parameters*\n     ``filename`` - \n      the name of the resource file, its extension determines the format of the file. Complex meshes and articulated meshes are all triangulated appropriately. See Resource File Formats. \n     ``options`` - \n      Options to control the parsing process. \n            ";
m["ja function EnvironmentBase Add"] = "\n\nvoid  **Add**\\(InterfaceBasePtr pinterface, bool bAnonymous = false , const std::string & cmdargs = \"\" )\n    \n    Add an interface to the environment.\n    \n    *Parameters*\n     ``pinterface`` - \n      the pointer to an initialized interface \n     ``bAnonymous`` - \n      if true and there exists a body/robot with the same name, will make body's name unique \n     ``cmdargs`` - \n      The command-line arguments for the module. \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if interface is invalid or already added Depending on the type of interface, the addition behaves differently. For bodies/robots, will add them to visual/geometric environment. For modules, will call their main() method and add them officially. For viewers, will attach a viewer to the environment and start sending it data. For interfaces that don't make sense to add, will throw an exception.\n    \n            ";
m["ja function EnvironmentBase AddKinBody"] = "\n\nvoid  **AddKinBody**\\(KinBodyPtr body, bool bAnonymous = false )\n    \n            ";
m["ja function EnvironmentBase AddKinBody"] = "\n\nvoid  **AddKinBody**\\(KinBodyPtr body, bool bAnonymous = false )\n    \n            ";
m["ja function EnvironmentBase AddRobot"] = "\n\nvoid  **AddRobot**\\(RobotBasePtr robot, bool bAnonymous = false )\n    \n            ";
m["ja function EnvironmentBase AddRobot"] = "\n\nvoid  **AddRobot**\\(RobotBasePtr robot, bool bAnonymous = false )\n    \n            ";
m["ja function EnvironmentBase AddSensor"] = "\n\nvoid  **AddSensor**\\(SensorBasePtr sensor, bool bAnonymous = false )\n    \n            ";
m["ja function EnvironmentBase AddSensor"] = "\n\nvoid  **AddSensor**\\(SensorBasePtr sensor, bool bAnonymous = false )\n    \n            ";
m["ja function EnvironmentBase AddViewer"] = "\n\nvoid  **AddViewer**\\(ViewerBasePtr pviewer)\n    \n            ";
m["ja function EnvironmentBase RemoveKinBody"] = "\n\nbool  **RemoveKinBody**\\(KinBodyPtr pbody)\n    \n    remove body from sensory system. If bDestroy is true, will also deallocate the memory\n    \n            ";
m["ja function EnvironmentBase Remove"] = "\n\nbool  **Remove**\\(InterfaceBasePtr obj)\n    \n    Removes a currently loaded interface from the environment.\n    \n    *Parameters*\n     ``obj`` - \n      interface to remove The function removes currently loaded bodies, robots, sensors, problems from the actively used interfaces of the environment. This does not destroy the interface, but it does remove all references managed. Some interfaces like problems have destroy methods that are called to signal unloading. Note that the active interfaces are different from the owned interfaces.\n    \n    *Return*\n        true if the interface was successfully removed from the environment. \n        ";
m["ja function EnvironmentBase GetKinBody"] = "\n\nKinBodyPtr  **GetKinBody**\\(const std::string & name)\n    \n    Query a body from its name.\n    \n    *Return*\n        first KinBody (including robots) that matches with name \n        ";
m["ja function EnvironmentBase GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\(const std::string & name)\n    \n    Query a robot from its name.\n    \n    *Return*\n        first Robot that matches the name \n        ";
m["ja function EnvironmentBase GetSensor"] = "\n\nSensorBasePtr  **GetSensor**\\(const std::string & name)\n    \n    Query a sensor from its name.\n    \n    *Return*\n        first sensor that matches with name, note that sensors attached to robots have the robot name as a prefix. \n        ";
m["ja function EnvironmentBase GetBodyFromEnvironmentId"] = "\n\nKinBodyPtr  **GetBodyFromEnvironmentId**\\(int id)\n    \n    Get the corresponding body from its unique network id.\n    \n            ";
m["ja function EnvironmentBase AddModule"] = "\n\nint  **AddModule**\\(ModuleBasePtr module, const std::string & cmdargs)\n    \n    Load a new module, need to Lock if calling outside simulation thread.\n    \n            ";
m["ja function EnvironmentBase AddModule"] = "\n\nint  **AddModule**\\(ModuleBasePtr module, const std::string & cmdargs)\n    \n    Load a new module, need to Lock if calling outside simulation thread.\n    \n            ";
m["ja function EnvironmentBase GetModules"] = "\n\nvoid  **GetModules**\\(std::list<  ModuleBasePtr  > & listModules, uint64_t timeout = 0 )\n    \n    Fills a list with the loaded modules in the environment.\n    \n    *Parameters*\n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code A separate  is locked for reading the modules. If the environment is locked, the modules are guaranteed to stay loaded in the environment.\n    \n            ";
m["ja function EnvironmentBase GetModules"] = "\n\nvoid  **GetModules**\\(std::list<  ModuleBasePtr  > & listModules, uint64_t timeout = 0 )\n    \n    Fills a list with the loaded modules in the environment.\n    \n    *Parameters*\n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code A separate  is locked for reading the modules. If the environment is locked, the modules are guaranteed to stay loaded in the environment.\n    \n            ";
m["ja function EnvironmentBase SetPhysicsEngine"] = "\n\nbool  **SetPhysicsEngine**\\(PhysicsEngineBasePtr physics)\n    \n    *Parameters*\n     ``physics`` - \n      the engine to set, if NULL, environment sets an dummy physics engine set the physics engine, disabled by default \n            ";
m["ja function EnvironmentBase GetPhysicsEngine"] = "\n\nPhysicsEngineBasePtr  **GetPhysicsEngine**\\()\n    \n            ";
m["ja function EnvironmentBase RegisterCollisionCallback"] = "\n\nUserDataPtr  **RegisterCollisionCallback**\\(const  CollisionCallbackFn  & callback)\n    \n    Register a collision callback.Whenever a collision is detected between between bodies during a CheckCollision call or physics simulation, the callback is called. The callback should return an action specifying how the collision should be handled:\n    \n    *Return*\n        a handle to the registration, once the handle loses scope, the callback is unregistered \n        ";
m["ja function EnvironmentBase StepSimulation"] = "\n\nvoid  **StepSimulation**\\(dReal timeStep)\n    \n    Makes one simulation time step.\n    \n    Can be called manually by the user inside planners. Keep in mind that the internal simulation thread also calls this function periodically. See Simulation Thread for more about the simulation thread.         ";
m["ja function EnvironmentBase StartSimulation"] = "\n\nvoid  **StartSimulation**\\(dReal fDeltaTime, bool bRealTime = true )\n    \n    Start the internal simulation thread.\n    \n    Resets simulation time to 0. See Simulation Thread for more about the simulation thread.\\ *Parameters*\n     ``fDeltaTime`` - \n      the delta step to take in simulation \n     ``bRealTime`` - \n      if false will call SimulateStep as fast as possible, otherwise will time the simulate step calls so that simulation progresses with real system time. \n            ";
m["ja function EnvironmentBase StopSimulation"] = "\n\nvoid  **StopSimulation**\\()\n    \n    Stops the internal physics loop, stops calling SimulateStep for all modules.\n    \n    See Simulation Thread for more about the simulation thread.         ";
m["ja function EnvironmentBase GetSimulationTime"] = "\n\nuint64_t  **GetSimulationTime**\\()\n    \n    Return simulation time since the start of the environment (in microseconds).\n    \n    See Simulation Thread for more about the simulation thread.         ";
m["ja function EnvironmentBase GetViewer"] = "\n\nViewerBasePtr  **GetViewer**\\(const std::string & name = \"\" )\n    \n    Return a viewer with a particular name.\n    \n    When no name is specified, the first loaded viewer is returned.         ";
m["ja function EnvironmentBase drawlinestrip \"const float; int; int; float; const float\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawlinestrip**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a series of connected lines with individual colors.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawlinelist \"const float; int; int; float; const float\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawlinelist**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a list of individual lines, each specified by a succeeding pair of points.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawarrow"] = "\n\nOpenRAVE::GraphHandlePtr  **drawarrow**\\(const RaveVector< float > & p1, const RaveVector< float > & p2, float fwidth, const RaveVector< float > & color = RaveVector< float >(1, 0.5, 0.5, 1) )\n    \n    Draws an arrow p1 is start, p2 is finish.\n    \n    *Parameters*\n     ``color`` - \n      the rgb color of the point. The last component of the color is used for alpha blending.\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawbox"] = "\n\nOpenRAVE::GraphHandlePtr  **drawbox**\\(const RaveVector< float > & vpos, const RaveVector< float > & vextents)\n    \n    Draws a box.\n    \n    extents are half the width, height, and depth of the box\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawplane"] = "\n\nOpenRAVE::GraphHandlePtr  **drawplane**\\(const  RaveTransform < float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawplane"] = "\n\nOpenRAVE::GraphHandlePtr  **drawplane**\\(const  RaveTransform < float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawtrimesh \"const float; int; const int; int; const boost::multi_array\""] = "\n\nOpenRAVE::GraphHandlePtr  **drawtrimesh**\\(const float * ppoints, int stride, const int * pIndices, int numTriangles, const boost::multi_array< float, 2 > & colors)\n    \n    Draws a triangle mesh, each vertices of each triangle should be counter-clockwise.\n    \n    *Parameters*\n     ``ppoints`` - \n      - array of 3D points \n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride) \n     ``pIndices`` - \n      If not NULL, zero-based indices into the points for every triangle. pIndices should be of size numTriangles. If pIndices is NULL, ppoints is assumed to contain numTriangles*3 points and triangles will be rendered in list order. \n     ``color`` - \n      The color of the triangle. The last component of the color is used for alpha blending\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase GetRobots"] = "\n\nvoid  **GetRobots**\\(std::vector<  RobotBasePtr  > & robots, uint64_t timeout = 0 )\n    \n    Fill an array with all robots loaded in the environment.\n    \n    *Parameters*\n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code A separate  is locked for reading the bodies.\n    \n            ";
m["ja function EnvironmentBase GetBodies"] = "\n\nvoid  **GetBodies**\\(std::vector<  KinBodyPtr  > & bodies, uint64_t timeout = 0 )\n    \n    Get all bodies loaded in the environment (including robots).\n    \n    *Parameters*\n     ``bodies`` - \n      filled with all the bodies \n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code A separate  is locked for reading the bodies.\n    \n            ";
m["ja function EnvironmentBase GetSensors"] = "\n\nvoid  **GetSensors**\\(std::vector<  SensorBasePtr  > & sensors, uint64_t timeout = 0 )\n    \n    Fill an array with all sensors loaded in the environment.\n    \n    *Parameters*\n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code The sensors come from the currently loaded robots and the explicitly added sensors\n    \n            ";
m["ja function EnvironmentBase UpdatePublishedBodies"] = "\n\nvoid  **UpdatePublishedBodies**\\(uint64_t timeout = 0 )\n    \n    Updates the published bodies that viewers and other programs listening in on the environment see.\n    \n    *Parameters*\n     ``timeout`` - \n      microseconds to wait before throwing an exception, if 0, will block indefinitely. \\ *Exceptions*\n     ``openrave_exception`` - \n      with ORE_Timeout error code For example, calling this function inside a planning loop allows the viewer to update the environment reflecting the status of the planner. Assumes that the physics are locked.\n    \n            ";
m["ja function EnvironmentBase Triangulate"] = "\n\nvoid  **Triangulate**\\(KinBody::Link::TRIMESH  & trimesh, KinBodyConstPtr pbody)\n    \n    Triangulation of the body including its current transformation. trimesh will be appended the new data.\n    \n    *Parameters*\n     ``trimesh`` - \n      - The output triangle mesh \n     ``body`` - \n      body the triangulate \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to add anything\n    \n            ";
m["ja function EnvironmentBase TriangulateScene"] = "\n\nvoid  **TriangulateScene**\\(KinBody::Link::TRIMESH  & trimesh, SelectionOptions options, const std::string & selectname)\n    \n    General triangulation of the whole scene.\n    \n    *Parameters*\n     ``trimesh`` - \n      - The output triangle mesh. The new triangles are appended to the existing triangles! \n     ``options`` - \n      - Controlls what to triangulate. \n     ``selectname`` - \n      - name of the body used in options \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if failed to add anything\n    \n            ";
m["ja function EnvironmentBase SetDebugLevel"] = "\n\nvoid  **SetDebugLevel**\\(int level)\n    \n    *Parameters*\n     ``level`` - \n      0 for no debug, 1 - to print all debug messeges. Default value for release builds is 0, for debug builds it is 1 declaring variables with stdcall can be a little complex sets the debug level \n            ";
m["ja function EnvironmentBase GetDebugLevel"] = "\n\nint  **GetDebugLevel**\\()\n    \n            ";
m["ja function EnvironmentBase GetHomeDirectory"] = "\n\nstd::string  **GetHomeDirectory**\\()\n    \n            ";
m["ja function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["ja function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(UserDataPtr data)\n    \n    set user data\n    \n            ";
m["ja function InterfaceBase GetUserData"] = "\n\nUserDataPtr  **GetUserData**\\()\n    \n    return the user custom data\n    \n            ";
m["ja function RaveGetEnvironmentId"] = "\n\nOPENRAVE_API  int  **RaveGetEnvironmentId**\\(EnvironmentBasePtr penv)\n    \n    return the environment's unique id, returns 0 if environment could not be found or not registered\n    \n            ";
m["ja function RaveGetEnvironment"] = "\n\nOPENRAVE_API   EnvironmentBasePtr  **RaveGetEnvironment**\\(int id)\n    \n    get the environment from its unique id\n    \n    *Parameters*\n     ``id`` - \n      the unique environment id returned by RaveGetEnvironmentId \n            ";
m["ja function RaveGetEnvironments"] = "\n\nOPENRAVE_API  void  **RaveGetEnvironments**\\(std::list<  EnvironmentBasePtr  > & listenvironments)\n    \n    Return all the created OpenRAVE environments.\n    \n            ";
m["ja function RaveCreateInterface"] = "\n\nOPENRAVE_API   InterfaceBasePtr  **RaveCreateInterface**\\(EnvironmentBasePtr penv, InterfaceType type, const std::string & interfacename)\n    \n            ";
m["ja function IkSolverBase GetNumFreeParameters"] = "\n\nint  **GetNumFreeParameters**\\()\n    \n    Number of free parameters defining the null solution space.\n    \n    Each parameter is always in the range of [0,1].         ";
m["ja function IkSolverBase GetFreeParameters"] = "\n\nbool  **GetFreeParameters**\\(std::vector<  dReal  > & vFreeParameters)\n    \n    gets the free parameters from the current robot configuration\n    \n    *Parameters*\n     ``vFreeParameters`` - \n      is filled with GetNumFreeParameters() parameters in [0,1] range\n    \n    *Return*\n        true if succeeded \n        ";
m["ja function IkSolverBase Supports"] = "\n\nbool  **Supports**\\(IkParameterizationType iktype)\n    \n    returns true if the solver supports a particular ik parameterization as input.\n    \n            ";
m["ja function IkSolverBase RegisterCustomFilter"] = "\n\nUserDataPtr  **RegisterCustomFilter**\\(int priority, const  IkFilterCallbackFn  & filterfn)\n    \n    Sets an ik solution filter that is called for every ik solution.\n    \n    *Parameters*\n     ``priority`` - \n      - The priority of the filter that controls the order in which filters get called. Higher priority filters get called first. If not certain what to set, use 0. \n     ``filterfn`` - \n      - an optional filter function to be called, see IkFilterCallbackFn. Multiple filters can be set at once, each filter will be called according to its priority; higher values get called first. The default implementation of IkSolverBase manages the filters internally. Users implementing their own IkSolverBase should call _CallFilters to run the internally managed filters.\n    \n    *Return*\n        a managed handle to the filter. If this handle is released, then the fitler will be removed. Release operation is . \n        ";
m["ja function RaveCreateIkSolver"] = "\n\nOPENRAVE_API   IkSolverBasePtr  **RaveCreateIkSolver**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function ControllerBase Init"] = "\n\nbool  **Init**\\(RobotBasePtr robot, const std::vector< int > & dofindices, int nControlTransformation)\n    \n    initializes the controller and specifies the controlled dof\n    \n    *Parameters*\n     ``robot`` - \n      the robot that uses the controller \n     ``dofindices`` - \n      the indices that controller will have exclusive access to \n     ``nControlTransformation`` -\n    \n    *See*\n        IsControlTransformation\n\n    *Return*\n        true on successful initialization \n        ";
m["ja function ControllerBase Init"] = "\n\nbool  **Init**\\(RobotBasePtr robot, const std::vector< int > & dofindices, int nControlTransformation)\n    \n    initializes the controller and specifies the controlled dof\n    \n    *Parameters*\n     ``robot`` - \n      the robot that uses the controller \n     ``dofindices`` - \n      the indices that controller will have exclusive access to \n     ``nControlTransformation`` -\n    \n    *See*\n        IsControlTransformation\n\n    *Return*\n        true on successful initialization \n        ";
m["ja function ControllerBase GetControlDOFIndices"] = "\n\nconst std::vector< int > &  **GetControlDOFIndices**\\()\n    \n    returns the dof indices controlled\n    \n            ";
m["ja function ControllerBase IsControlTransformation"] = "\n\nint  **IsControlTransformation**\\()\n    \n    returns non-zero value if base affine transformation is controlled.\n    \n    Only one controller can modify translation and orientation per robot. For now, the two cannot be divided.         ";
m["ja function ControllerBase GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\()\n    \n            ";
m["ja function ControllerBase Reset"] = "\n\nvoid  **Reset**\\(int options = 0 )\n    \n    Resets the current controller trajectories and any other state associated with the robot.\n    \n    *Parameters*\n     ``options`` - \n      - specific options that can be used to control what to reset \n            ";
m["ja function ControllerBase SetDesired"] = "\n\nbool  **SetDesired**\\(const std::vector<  dReal  > & values, TransformConstPtr trans = TransformConstPtr () )\n    \n    go to a specific position in configuration space.\n    \n    *Parameters*\n     ``values`` - \n      the final configuration in the control dofs \n     ``trans`` - \n      the transformation of the base. If not specified will use the current robot transformation. Ignored if controller does not use it\n    \n    *Return*\n        true if position operation successful. \n        ";
m["ja function ControllerBase SetDesired"] = "\n\nbool  **SetDesired**\\(const std::vector<  dReal  > & values, TransformConstPtr trans = TransformConstPtr () )\n    \n    go to a specific position in configuration space.\n    \n    *Parameters*\n     ``values`` - \n      the final configuration in the control dofs \n     ``trans`` - \n      the transformation of the base. If not specified will use the current robot transformation. Ignored if controller does not use it\n    \n    *Return*\n        true if position operation successful. \n        ";
m["ja function ControllerBase SetPath"] = "\n\nbool  **SetPath**\\(TrajectoryBaseConstPtr ptraj)\n    \n    Follow a path in configuration space, adds to the queue of trajectories already in execution.\n    \n    *Parameters*\n     ``ptraj`` - \n      - the trajectory\n    \n    *Return*\n        true if trajectory operation successful \n        ";
m["ja function ControllerBase SimulationStep \"dReal\""] = "\n\nvoid  **SimulationStep**\\(dReal fTimeElapsed)\n    \n    Simulate one step forward for controllers running in the simulation environment.\n    \n    *Parameters*\n     ``fTimeElapsed`` - \n      - time elapsed in simulation environment since last frame \n            ";
m["ja function ControllerBase IsDone"] = "\n\nbool  **IsDone**\\()\n    \n    Return true when goal reached.\n    \n    If a trajectory was set, return only when trajectory is done. If SetDesired was called, return only when robot is is at the desired location. If SendCommand sent, returns true when the command was completed by the hand.         ";
m["ja function ControllerBase GetTime"] = "\n\ndReal  **GetTime**\\()\n    \n    return the time along the current command\n    \n            ";
m["ja function ControllerBase GetVelocity"] = "\n\nvoid  **GetVelocity**\\(std::vector<  dReal  > & vel)\n    \n    get velocity of the controlled DOFs\n    \n    *Parameters*\n     ``vel`` - \n      [out] - current velocity of robot from the dof \n            ";
m["ja function ControllerBase GetTorque"] = "\n\nvoid  **GetTorque**\\(std::vector<  dReal  > & torque)\n    \n    *Parameters*\n     ``torque`` - \n      [out] - returns the current torque/current/strain exerted by each of the dofs from outside forces. The feedforward and friction terms should be subtracted out already get torque/current/strain values \n            ";
m["ja function RaveCreateController"] = "\n\nOPENRAVE_API   ControllerBasePtr  **RaveCreateController**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function PhysicsEngineBase GetPhysicsOptions"] = "\n\nint  **GetPhysicsOptions**\\()\n    \n            ";
m["ja function PhysicsEngineBase SetPhysicsOptions \"int\""] = "\n\nbool  **SetPhysicsOptions**\\(int physicsoptions)\n    \n    Set basic physics engine using the PhysicsEngineOptions enum.\n    \n            ";
m["ja function PhysicsEngineBase InitEnvironment"] = "\n\nbool  **InitEnvironment**\\()\n    \n    called when environment sets this physics engine, engine assumes responsibility for KinBody::_pPhysicsData\n    \n            ";
m["ja function PhysicsEngineBase DestroyEnvironment"] = "\n\nvoid  **DestroyEnvironment**\\()\n    \n    called when environment switches to a different physics engine has to clear/deallocate any memory associated with KinBody::_pPhysicsData         ";
m["ja function PhysicsEngineBase InitKinBody"] = "\n\nbool  **InitKinBody**\\(KinBodyPtr body)\n    \n    notified when a new body has been initialized in the environment\n    \n            ";
m["ja function PhysicsEngineBase SetLinkVelocity"] = "\n\nbool  **SetLinkVelocity**\\(KinBody::LinkPtr link, const  Vector  & linearvel, const  Vector  & angularvel)\n    \n    Force the body velocity of a link, velocities correspond to the link's coordinate system origin.\n    \n    *Parameters*\n     ``link`` - \n      link to set velocities. \n     ``linearvel`` - \n      linear velocity of base link \n     ``angularvel`` - \n      angular velocity rotation_axis*theta_dot \n            ";
m["ja function PhysicsEngineBase SetLinkVelocities"] = "\n\nbool  **SetLinkVelocities**\\(KinBodyPtr body, const std::vector< std::pair<  Vector ,  Vector  > > & velocities)\n    \n    Sets the velocities for each link, velocities correspond to the link's coordinate system origin.\n    \n    *Parameters*\n     ``body`` - \n      the body to query velocities from. \n     ``velocities`` - \n      sets the linear and angular (axis * angular_speed) velocities for each link \n            ";
m["ja function PhysicsEngineBase GetLinkVelocity"] = "\n\nbool  **GetLinkVelocity**\\(KinBody::LinkConstPtr link, Vector  & linearvel, Vector  & angularvel)\n    \n    Gets the velocity of a link, velocities correspond to the link's coordinate system origin.\n    \n    *Parameters*\n     ``linearvel`` - \n      - linear velocity of base link \n     ``angularvel`` - \n      - angular velocity rotation_axis*theta_dot \n            ";
m["ja function PhysicsEngineBase GetLinkVelocities"] = "\n\nbool  **GetLinkVelocities**\\(KinBodyConstPtr body, std::vector< std::pair<  Vector ,  Vector  > > & velocities)\n    \n    Sets the velocities for each link, velocities correspond to the link's coordinate system origin.\n    \n    *Parameters*\n     ``velocities`` - \n      the linear and angular (axis * angular_speed) velocities for each link. \n            ";
m["ja function PhysicsEngineBase SetBodyForce"] = "\n\nbool  **SetBodyForce**\\(KinBody::LinkPtr link, const  Vector  & force, const  Vector  & position, bool bAdd)\n    \n    *Parameters*\n     ``force`` - \n      the direction and magnitude of the force \n     ``position`` - \n      in the world where the force is getting applied \n     ``bAdd`` - \n      if true, force is added to previous forces, otherwise it is set add a force at a particular position in a link \n            ";
m["ja function PhysicsEngineBase SetBodyTorque"] = "\n\nbool  **SetBodyTorque**\\(KinBody::LinkPtr link, const  Vector  & torque, bool bAdd)\n    \n    *Parameters*\n     ``link`` - \n      the link to add a torque to \n     ``torque`` - \n      torque vector \n     ``bAdd`` - \n      if true, torque is added to previous torques, otherwise it is set adds torque to a body (absolute coords) \n            ";
m["ja function PhysicsEngineBase AddJointTorque"] = "\n\nbool  **AddJointTorque**\\(KinBody::JointPtr pjoint, const std::vector<  dReal  > & pTorques)\n    \n    *Parameters*\n     ``pjoint`` - \n      - the joint the torque is added to \n     ``pTorques`` - \n      - the torques added to the joint. Pointer because the joint dof can be greater than 1. adds torque to a joint \n            ";
m["ja function PhysicsEngineBase GetLinkForceTorque"] = "\n\nbool  **GetLinkForceTorque**\\(KinBody::LinkConstPtr link, Vector  & force, Vector  & torque)\n    \n    *Parameters*\n     ``link`` - \n      a constant pointer to a link \n     ``force`` - \n      current force on the COM of the link \n     ``torque`` - \n      current torque on the COM of the link \n            ";
m["ja function PhysicsEngineBase SetGravity"] = "\n\nvoid  **SetGravity**\\(const  Vector  & gravity)\n    \n    set the gravity direction\n    \n    *Parameters*\n     ``joint`` -\n      \n     ``force`` - \n      current accumulated force on the COM of the link \n     ``torque`` - \n      current accumulated torque on the COM of the link \n            ";
m["ja function PhysicsEngineBase GetGravity"] = "\n\nVector  **GetGravity**\\()\n    \n            ";
m["ja function PhysicsEngineBase SimulateStep"] = "\n\nvoid  **SimulateStep**\\(dReal fTimeElapsed)\n    \n    dynamically simulate system for fTimeElapsed seconds add torques to the joints of the body. Torques disappear after one timestep of simulation         ";
m["ja function RaveCreatePhysicsEngine"] = "\n\nOPENRAVE_API   PhysicsEngineBasePtr  **RaveCreatePhysicsEngine**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function RaveCreateModule"] = "\n\nOPENRAVE_API   ModuleBasePtr  **RaveCreateModule**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function RaveCreateModule"] = "\n\nOPENRAVE_API   ModuleBasePtr  **RaveCreateModule**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function RaveCreateModule"] = "\n\nOPENRAVE_API   ModuleBasePtr  **RaveCreateModule**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function SpaceSamplerBase SetSeed"] = "\n\nvoid  **SetSeed**\\(uint32_t seed)\n    \n    sets a new seed. For sequence samplers, the seed describes the n^th sample to begin at.\n    \n            ";
m["ja function SpaceSamplerBase SetSpaceDOF"] = "\n\nvoid  **SetSpaceDOF**\\(int dof)\n    \n    Sets the degrees of freedom of the space (note this is different from the parameterization dimension)\n    \n            ";
m["ja function SpaceSamplerBase GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    returns the degrees of freedom of the sampling space\n    \n            ";
m["ja function SpaceSamplerBase GetNumberOfValues"] = "\n\nint  **GetNumberOfValues**\\()\n    \n    Dimension of the return samples.\n    \n    Number of values used to represent the parameterization of the space (>= dof). For example, let a quaternion describe a 3D rotation. The DOF of the space is 3, while the dimension of the returned samples is 4.         ";
m["ja function SpaceSamplerBase Supports"] = "\n\nbool  **Supports**\\(SampleDataType type)\n    \n            ";
m["ja function SpaceSamplerBase GetLimits"] = "\n\nvoid  **GetLimits**\\(std::vector<  dReal  > & vLowerLimit, std::vector<  dReal  > & vUpperLimit)\n    \n    returns the minimum and maximum values returned for each dimension (size is GetNumberOfValues())\n    \n    By default the limits should be in [0,1]^N.         ";
m["ja function SpaceSamplerBase SampleSequence \"std::vector; size_t; IntervalType\""] = "\n\nvoid  **SampleSequence**\\(std::vector<  dReal  > & samples, size_t num = 1 , IntervalType interval = IT_Closed )\n    \n    sequentially sampling returning the next 'num' samples\n    \n    *Parameters*\n     ``sample`` - \n      the values of the samples. This is a num*GetNumberOfValues() array. \n     ``num`` - \n      number of samples to return \n     ``interval`` - \n      the sampling intervel for each of the dimensions. The sampler can fail by returning an array of size 0. \n            ";
m["ja function SpaceSamplerBase SampleSequence \"std::vector; size_t\""] = "\n\nvoid  **SampleSequence**\\(std::vector< uint32_t > & sample, size_t num = 1 )\n    \n    sequentially sampling returning the next 'num' samples\n    \n    *Parameters*\n     ``sample`` - \n      the values of the samples. This is a num*GetNumberOfValues() array. \n     ``num`` - \n      number of samples to return The sampler can fail by returning an array of size 0. \n            ";
m["ja function SpaceSamplerBase SampleComplete \"std::vector; size_t; IntervalType\""] = "\n\nvoid  **SampleComplete**\\(std::vector<  dReal  > & samples, size_t num, IntervalType interval = IT_Closed )\n    \n    returns N samples that best approximate the entire sampling space.\n    \n    The sampler can fail by returning an array of size 0.         ";
m["ja function SpaceSamplerBase SampleComplete \"std::vector; size_t\""] = "\n\nvoid  **SampleComplete**\\(std::vector< uint32_t > & samples, size_t num)\n    \n    returns N samples that best approximate the entire sampling space.\n    \n    The sampler can fail by returning an array of size 0.         ";
m["ja function RaveCreateSpaceSampler"] = "\n\nOPENRAVE_API   SpaceSamplerBasePtr  **RaveCreateSpaceSampler**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function PlannerBase InitPlan \"RobotBasePtr; PlannerParametersConstPtr\""] = "\n\nbool  **InitPlan**\\(RobotBasePtr robot, PlannerParametersConstPtr params)\n    \n    Setup scene, robot, and properties of the plan, and reset all internal structures.\n    \n    *Parameters*\n     ``robot`` - \n      main robot to be used for planning \n     ``params`` - \n      The parameters of the planner, any class derived from PlannerParameters can be passed. The planner should copy these parameters for future instead of storing the pointer. \n            ";
m["ja function PlannerBase InitPlan \"RobotBasePtr; std::istream\""] = "\n\nbool  **InitPlan**\\(RobotBasePtr robot, std::istream & isParameters)\n    \n    Setup scene, robot, and properties of the plan, and reset all structures with pparams.\n    \n    *Parameters*\n     ``robot`` - \n      main robot to be used for planning \n     ``isParameters`` - \n      The serialized form of the parameters. By default, this exists to allow third parties to pass information to planners without excplicitly knowning the format/internal structures used\n    \n    *Return*\n        true if plan is initialized successfully and initial conditions are satisfied. \n        ";
m["ja function PlannerBase PlanPath"] = "\n\nPlannerStatus  **PlanPath**\\(TrajectoryBasePtr ptraj)\n    \n    Executes the main planner trying to solve for the goal condition.\n    \n    *Parameters*\n     ``ptraj`` - \n      The output trajectory the robot has to follow in order to successfully complete the plan. If this planner is a path optimizer, the trajectory can be used as an input for generating a smoother path. The trajectory is for the configuration degrees of freedom defined by the planner parameters. Fill ptraj with the trajectory of the planned path that the robot needs to execute\n    \n    *Return*\n        the status that the planner returned in. \n        ";
m["ja function PlannerBase GetParameters"] = "\n\nPlannerParametersConstPtr  **GetParameters**\\()\n    \n    return the internal parameters of the planner\n    \n            ";
m["ja function PlannerBase::PlannerParameters  SetRobotActiveJoints"] = "\n\nvoid  **SetRobotActiveJoints**\\(RobotBasePtr robot)\n    \n    sets up the planner parameters to use the active joints of the robot\n    \n            ";
m["ja function PlannerBase::PlannerParameters  SetConfigurationSpecification"] = "\n\nvoid  **SetConfigurationSpecification**\\(EnvironmentBasePtr env, const  ConfigurationSpecification  & spec)\n    \n    sets up the planner parameters to use the configuration specification space\n    \n    The configuraiton groups should point to controllable target objects. By default, this includes:\n            ";
m["ja function RaveCreatePlanner"] = "\n\nOPENRAVE_API   PlannerBasePtr  **RaveCreatePlanner**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function TrajectoryBase Init"] = "\n\nvoid  **Init**\\(const  ConfigurationSpecification  & spec)\n    \n            ";
m["ja function TrajectoryBase Insert \"size_t; const std::vector; bool\""] = "\n\nvoid  **Insert**\\(size_t index, const std::vector<  dReal  > & data, bool bOverwrite = false )\n    \n    Sets/inserts new waypoints in the same configuration specification as the trajectory.\n    \n    *Parameters*\n     ``index`` - \n      The index where to start modifying the trajectory. \n     ``data`` - \n      The data to insert, can represent multiple consecutive waypoints. data.size()/GetConfigurationSpecification().GetDOF() waypoints are added. \n     ``bOverwrite`` - \n      If true, will overwrite the waypoints starting at index, and will insert new waypoints only if end of trajectory is reached. If false, will insert the points before index: a 0 index inserts the new data in the beginning, a GetNumWaypoints() index inserts the new data at the end. \n            ";
m["ja function TrajectoryBase Insert \"size_t; const std::vector; bool\""] = "\n\nvoid  **Insert**\\(size_t index, const std::vector<  dReal  > & data, bool bOverwrite = false )\n    \n    Sets/inserts new waypoints in the same configuration specification as the trajectory.\n    \n    *Parameters*\n     ``index`` - \n      The index where to start modifying the trajectory. \n     ``data`` - \n      The data to insert, can represent multiple consecutive waypoints. data.size()/GetConfigurationSpecification().GetDOF() waypoints are added. \n     ``bOverwrite`` - \n      If true, will overwrite the waypoints starting at index, and will insert new waypoints only if end of trajectory is reached. If false, will insert the points before index: a 0 index inserts the new data in the beginning, a GetNumWaypoints() index inserts the new data at the end. \n            ";
m["ja function TrajectoryBase Insert \"size_t; const std::vector; const ConfigurationSpecification; bool\""] = "\n\nvoid  **Insert**\\(size_t index, const std::vector<  dReal  > & data, const  ConfigurationSpecification  & spec, bool bOverwrite = false )\n    \n    Sets/inserts new waypoints in a  configuration specification.\n    \n    *Parameters*\n     ``index`` - \n      The index where to start modifying the trajectory. \n     ``data`` - \n      The data to insert, can represent multiple consecutive waypoints. data.size()/GetConfigurationSpecification().GetDOF() waypoints are added. \n     ``spec`` - \n      the specification in which the input data come in. Depending on what data is offered, some values of this trajectory's specification might not be initialized. \n     ``bOverwrite`` - \n      If true, will overwrite the waypoints starting at index, and will insert new waypoints only if end of trajectory is reached; if the input spec does not overwrite all the data of the trjectory spec, then the original trajectory data will not be overwritten. If false, will insert the points before index: a 0 index inserts the new data in the beginning, a GetNumWaypoints() index inserts the new data at the end. \n            ";
m["ja function TrajectoryBase Insert \"size_t; const std::vector; const ConfigurationSpecification; bool\""] = "\n\nvoid  **Insert**\\(size_t index, const std::vector<  dReal  > & data, const  ConfigurationSpecification  & spec, bool bOverwrite = false )\n    \n    Sets/inserts new waypoints in a  configuration specification.\n    \n    *Parameters*\n     ``index`` - \n      The index where to start modifying the trajectory. \n     ``data`` - \n      The data to insert, can represent multiple consecutive waypoints. data.size()/GetConfigurationSpecification().GetDOF() waypoints are added. \n     ``spec`` - \n      the specification in which the input data come in. Depending on what data is offered, some values of this trajectory's specification might not be initialized. \n     ``bOverwrite`` - \n      If true, will overwrite the waypoints starting at index, and will insert new waypoints only if end of trajectory is reached; if the input spec does not overwrite all the data of the trjectory spec, then the original trajectory data will not be overwritten. If false, will insert the points before index: a 0 index inserts the new data in the beginning, a GetNumWaypoints() index inserts the new data at the end. \n            ";
m["ja function TrajectoryBase Remove"] = "\n\nvoid  **Remove**\\(size_t startindex, size_t endindex)\n    \n    removes a number of waypoints starting at the specified index\n    \n            ";
m["ja function TrajectoryBase Sample \"std::vector; dReal\""] = "\n\nvoid  **Sample**\\(std::vector<  dReal  > & data, dReal time)\n    \n    samples a data point on the trajectory at a particular time\n    \n    *Parameters*\n     ``data[out]`` - \n      the sampled point \n     ``time[in]`` - \n      the time to sample \n            ";
m["ja function TrajectoryBase Sample \"std::vector; dReal; const ConfigurationSpecification\""] = "\n\nvoid  **Sample**\\(std::vector<  dReal  > & data, dReal time, const  ConfigurationSpecification  & spec)\n    \n    samples a data point on the trajectory at a particular time and returns data for the group specified.\n    \n    *Parameters*\n     ``data[out]`` - \n      the sampled point \n     ``time[in]`` - \n      the time to sample \n     ``spec[in]`` - \n      the specification format to return the data in The default implementation is slow, so interface developers should override it. \n            ";
m["ja function TrajectoryBase GetConfigurationSpecification"] = "\n\nconst  ConfigurationSpecification  &  **GetConfigurationSpecification**\\()\n    \n            ";
m["ja function TrajectoryBase GetNumWaypoints"] = "\n\nsize_t  **GetNumWaypoints**\\()\n    \n    return the number of waypoints\n    \n            ";
m["ja function TrajectoryBase  GetWaypoints \"size_t; size_t; std::vector\""] = "\n\nvoid  **GetWaypoints**\\(size_t startindex, size_t endindex, std::vector<  dReal  > & data)\n    \n    return a set of waypoints in the range [startindex,endindex)\n    \n    *Parameters*\n     ``startindex[in]`` - \n      the start index of the waypoint (included) \n     ``endindex[in]`` - \n      the end index of the waypoint (not included) \n     ``data[out]`` - \n      the data of the waypoint \n            ";
m["ja function TrajectoryBase  GetWaypoint \"int; std::vector\""] = "\n\nvoid  **GetWaypoint**\\(int index, std::vector<  dReal  > & data)\n    \n    returns one waypoint\n    \n    *Parameters*\n     ``index[in]`` - \n      index of the waypoint. If < 0, then counting starts from the last waypoint. For example GetWaypoints(-1,data) returns the last waypoint. \n     ``data[out]`` - \n      the data of the waypoint \n            ";
m["ja function TrajectoryBase  GetWaypoint \"int; std::vector; const ConfigurationSpecification\""] = "\n\nvoid  **GetWaypoint**\\(int index, std::vector<  dReal  > & data, const  ConfigurationSpecification  & spec)\n    \n    returns one waypoint\n    \n    *Parameters*\n     ``index[in]`` - \n      index of the waypoint. If < 0, then counting starts from the last waypoint. For example GetWaypoints(-1,data) returns the last waypoint. \n     ``data[out]`` - \n      the data of the waypoint \n            ";
m["ja function TrajectoryBase  GetDuration"] = "\n\ndReal  **GetDuration**\\()\n    \n    return the duration of the trajectory in seconds\n    \n            ";
m["ja function TrajectoryBase serialize"] = "\n\nvoid  **serialize**\\(std::ostream & O, int options = 0 )\n    \n    output the trajectory in XML format\n    \n            ";
m["ja function TrajectoryBase deserialize"] = "\n\nInterfaceBasePtr  **deserialize**\\(std::istream & I)\n    \n    initialize the trajectory\n    \n            ";
m["ja function TrajectoryBase Write"] = "\n\nbool  **Write**\\(std::ostream & O, int options)\n    \n            ";
m["ja function TrajectoryBase Read"] = "\n\nbool  **Read**\\(std::istream & I, RobotBaseConstPtr )\n    \n            ";
m["ja function RaveCreateTrajectory"] = "\n\nOPENRAVE_API   TrajectoryBasePtr  **RaveCreateTrajectory**\\(EnvironmentBasePtr penv, const std::string & name = \"\" )\n    \n    Return an empty trajectory instance.\n    \n            ";
m["ja function ViewerBase main"] = "\n\nint  **main**\\(bool bShow = true )\n    \n    goes into the main loop\n    \n    *Parameters*\n     ``bShow`` - \n      if true will show the window \n            ";
m["ja function ViewerBase quitmainloop"] = "\n\nvoid  **quitmainloop**\\()\n    \n    destroys the main loop\n    \n            ";
m["ja function ViewerBase SetSize"] = "\n\nvoid  **SetSize**\\(int w, int h)\n    \n            ";
m["ja function ViewerBase Move"] = "\n\nvoid  **Move**\\(int x, int y)\n    \n            ";
m["ja function ViewerBase SetName"] = "\n\nvoid  **SetName**\\(const std::string & name)\n    \n            ";
m["ja function ViewerBase SetName"] = "\n\nvoid  **SetName**\\(const std::string & name)\n    \n            ";
m["ja function ViewerBase GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["ja function ViewerBase RegisterItemSelectionCallback"] = "\n\nUserDataPtr  **RegisterItemSelectionCallback**\\(const  ItemSelectionCallbackFn  & fncallback)\n    \n    registers a function with the viewer that gets called everytime mouse button is clicked\n    \n    *Return*\n        a handle to the callback. If this handle is deleted, the callback will be unregistered. \n        ";
m["ja function ViewerBase RegisterItemSelectionCallback"] = "\n\nUserDataPtr  **RegisterItemSelectionCallback**\\(const  ItemSelectionCallbackFn  & fncallback)\n    \n    registers a function with the viewer that gets called everytime mouse button is clicked\n    \n    *Return*\n        a handle to the callback. If this handle is deleted, the callback will be unregistered. \n        ";
m["ja function ViewerBase EnvironmentSync"] = "\n\nvoid  **EnvironmentSync**\\()\n    \n    forces synchronization with the environment, returns when the environment is fully synchronized.\n    \n    Note that this method might not work if environment is locked in current thread         ";
m["ja function ViewerBase SetCamera"] = "\n\nvoid  **SetCamera**\\(const  RaveTransform < float > & trans, float focalDistance = 0 )\n    \n    Set the camera transformation.\n    \n    *Parameters*\n     ``trans`` - \n      new camera transformation in the world coordinate system \n     ``focalDistance`` - \n      The new focal distance of the camera (higher values is higher zoom). If 0, then the previous focal distance is preserved. \n            ";
m["ja function ViewerBase SetCamera"] = "\n\nvoid  **SetCamera**\\(const  RaveTransform < float > & trans, float focalDistance = 0 )\n    \n    Set the camera transformation.\n    \n    *Parameters*\n     ``trans`` - \n      new camera transformation in the world coordinate system \n     ``focalDistance`` - \n      The new focal distance of the camera (higher values is higher zoom). If 0, then the previous focal distance is preserved. \n            ";
m["ja function ViewerBase SetBkgndColor"] = "\n\nvoid  **SetBkgndColor**\\(const RaveVector< float > & color)\n    \n            ";
m["ja function ViewerBase GetCameraTransform"] = "\n\nRaveTransform < float >  **GetCameraTransform**\\()\n    \n    Return the current camera transform that the viewer is rendering the environment at.\n    \n            ";
m["ja function ViewerBase GetCameraImage"] = "\n\nbool  **GetCameraImage**\\(std::vector< uint8_t > & memory, int width, int height, const  RaveTransform < float > & t, const  SensorBase::CameraIntrinsics  & intrinsics)\n    \n    Renders a 24bit RGB image of dimensions width and height from the current scene.\n    \n    *Parameters*\n     ``memory`` - \n      the memory where the image will be stored at, has to store 3*width*height \n     ``width`` - \n      width of the image, if 0 the width of the viewer is used \n     ``height`` - \n      height of the image, if 0 the width of the viewer is used \n     ``t`` - \n      the rotation and translation of the camera. Note that +z is treated as the camera direction axis! So all points in front of the camera have a positive dot product with its +z direction. \n     ``intrinsics`` - \n      the intrinsic parameters of the camera defining FOV, distortion, principal point, and focal length. The focal length is used to define the near plane for culling. The camera is meant to show the underlying OpenRAVE world as a robot would see it, so all graphs rendered with the plotX and drawX functions are hidden by default. Some viewers support the SetFiguresInCamera command to allow graphs to be also displayed. \n            ";
m["ja function RaveCreateViewer"] = "\n\nOPENRAVE_API   ViewerBasePtr  **RaveCreateViewer**\\(EnvironmentBasePtr penv, const std::string & name)\n    \n            ";
m["ja function GraphHandle SetTransform"] = "\n\nvoid  **SetTransform**\\(const  RaveTransform < float > & t)\n    \n    Changes the underlying transformation of the plot.\n    \n    *Parameters*\n     ``t`` - \n      new transformation of the plot \n            ";
m["ja function GraphHandle SetShow"] = "\n\nvoid  **SetShow**\\(bool bshow)\n    \n    Shows or hides the plot without destroying its resources.\n    \n            ";
m["ja function SerializableData  Serialize"] = "\n\nvoid  **Serialize**\\(std::ostream & O, int options = 0 )\n    \n    output the data of the object\n    \n            ";
m["ja function SerializableData  Deserialize"] = "\n\nvoid  **Deserialize**\\(std::istream & I)\n    \n    initialize the object\n    \n            ";
m["ja function XMLReadable  GetXMLId"] = "\n\nconst std::string &  **GetXMLId**\\()\n    \n            ";
m["ja function XMLReadable  Serialize"] = "\n\nvoid  **Serialize**\\(BaseXMLWriterPtr writer, int options = 0 )\n    \n    serializes the interface\n    \n            ";
m["ja function ConfigurationSpecification GetGroupFromName"] = "\n\nconst  Group  &  **GetGroupFromName**\\(const std::string & name)\n    \n    return the group whose name begins with a particular string.\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      if a group is not found If multiple groups exist that begin with the same string, then the shortest one is returned. \n            ";
m["ja function ConfigurationSpecification FindCompatibleGroup"] = "\n\nstd::vector<  Group  >::const_iterator  **FindCompatibleGroup**\\(const  Group  & g, bool exactmatch = false )\n    \n    finds the most compatible group to the given group\n    \n    *Parameters*\n     ``g`` - \n      the group to query, only the Group::name and Group::dof values are used \n     ``exactmatch`` - \n      if true, will only return groups whose name exactly matches with g.name\n    \n    *Return*\n        an iterator part of _vgroups that represents the most compatible group. If no group is found, will return _vgroups.end() \n        ";
m["ja function ConfigurationSpecification FindTimeDerivativeGroup"] = "\n\nstd::vector<  Group  >::const_iterator  **FindTimeDerivativeGroup**\\(const  Group  & g, bool exactmatch = false )\n    \n    Return the most compatible group that represents the time-derivative data of the group.\n    \n    *Parameters*\n     ``g`` - \n      the group to query, only the Group::name and Group::dof values are used \n     ``exactmatch`` - \n      if true, will only return groups whose name exactly matches with g.name For example given a 'joint_values' group, this will return the closest 'joint_velocities' group.\n    \n    *Return*\n        an iterator part of _vgroups that represents the most compatible group. If no group is found, will return _vgroups.end() \n        ";
m["ja function ConfigurationSpecification GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    return the dimension of the configuraiton space (degrees of freedom)\n    \n            ";
m["ja function ConfigurationSpecification IsValid"] = "\n\nbool  **IsValid**\\()\n    \n    check if the groups form a continguous space\n    \n    If there are two or more groups with the same semantic names, will fail. Theese groups should be merged into one.\n    \n    *Return*\n        true if valid, otherwise false \n        ";
m["ja function ConfigurationSpecification ResetGroupOffsets"] = "\n\nvoid  **ResetGroupOffsets**\\()\n    \n    set the offsets of each group in order to get a contiguous configuration space\n    \n            ";
m["ja function ConfigurationSpecification AddVelocityGroups"] = "\n\nvoid  **AddVelocityGroups**\\(bool adddeltatime)\n    \n            ";
m["ja function ConfigurationSpecification AddDerivativeGroups"] = "\n\nvoid  **AddDerivativeGroups**\\(int deriv, bool adddeltatime = false )\n    \n    adds velocity, acceleration, etc groups for every position group.\n    \n    *Parameters*\n     ``deriv`` - \n      The position derivative to add, this must be greater than 0. If 2 is specified, only the acceleration groups of the alread present position groups will be added. \n     ``adddeltatime`` - \n      If true will add the 'deltatime' tag, which is necessary for trajectory sampling If the derivative groups already exist, they are checked for and/or modified. Note that the configuration space might be re-ordered as a result of this function call. If a new group is added, its interpolation will be the derivative of the position group as returned by GetInterpolationDerivative. \n            ";
m["ja function ConfigurationSpecification AddDeltaTimeGroup"] = "\n\nint  **AddDeltaTimeGroup**\\()\n    \n    adds the deltatime tag to the end if one doesn't exist and returns the index into the configuration space\n    \n            ";
m["ja function ConfigurationSpecification AddGroup \"const std::string; int; const std::string\""] = "\n\nint  **AddGroup**\\(const std::string & name, int dof, const std::string & interpolation = \"\" )\n    \n    Adds a new group to the specification and returns its new offset.\n    \n    If the new group's semantic name does not exist in the current specification, adds it and returns the new offset. If the new group's semantic name exists in the current specification and it exactly matches, then function returns the old group's index. If the semantic names match, but parameters do not match, then an openrave_exception is thrown. This method is not responsible for merging semantic information         ";
m["ja function ConfigurationSpecification AddGroup \"const\""] = "\n\nint  **AddGroup**\\(const  Group  & g)\n    \n    Adds a new group to the specification and returns its new offset.\n    \n    *Parameters*\n     ``g`` - \n      the group whose name, dof, and interpolation are extracted. If the new group's semantic name does not exist in the current specification, adds it and returns the new offset. If the new group's semantic name exists in the current specification and it exactly matches, then function returns the old group's index. If the semantic names match, but parameters do not match, then an openrave_exception is thrown. This method is not responsible for merging semantic information \n            ";
m["ja function ConfigurationSpecification ConvertToVelocitySpecification"] = "\n\nConfigurationSpecification  **ConvertToVelocitySpecification**\\()\n    \n    converts all the groups to the corresponding velocity groups and returns the specification\n    \n    The velocity configuration space will have a one-to-one correspondence with the original configuration. The interpolation of each of the groups will correspondingly represent the derivative as returned by GetInterpolationDerivative. Only position specifications will be converted, any other groups will be left untouched.         ";
m["ja function ConfigurationSpecification GetTimeDerivativeSpecification"] = "\n\nConfigurationSpecification  **GetTimeDerivativeSpecification**\\(int timederivative)\n    \n    returns a new specification of just particular time-derivative groups.\n    \n    *Parameters*\n     ``timederivative`` - \n      the time derivative to query groups from. 0 is positions/joint values, 1 is velocities, 2 is accelerations, etc \n            ";
m["ja function ConfigurationSpecification ExtractTransform"] = "\n\nbool  **ExtractTransform**\\(Transform  & t, std::vector<  dReal  >::const_iterator itdata, KinBodyConstPtr pbody, int timederivative = 0 )\n    \n    extracts an affine transform given the start of a configuration space point\n    \n    *Parameters*\n     ``inout]`` - \n      t the transform holding the default values, which will be overwritten with the new values. \n     ``itdata`` - \n      data in the format of this configuration specification. \n     ``timederivative`` - \n      the time derivative of the data to extract Looks for 'affine_transform' groups. If pbody is not initialized, will choose the first affine_transform found.\n    \n    *Return*\n        true if at least one group was found for extracting \n        ";
m["ja function ConfigurationSpecification ExtractJointValues"] = "\n\nbool  **ExtractJointValues**\\(std::vector<  dReal  >::iterator itvalues, std::vector<  dReal  >::const_iterator itdata, KinBodyConstPtr pbody, const std::vector< int > & indices, int timederivative = 0 )\n    \n    extracts a body's joint values given the start of a configuration space point\n    \n    *Parameters*\n     ``inout]`` - \n      itvalues iterator to vector that holds the default values and will be overwritten with the new values. must be initialized \n     ``itdata`` - \n      data in the format of this configuration specification. \n     ``indices`` - \n      the set of DOF indices of the body to extract and write into itvalues. \n     ``timederivative`` - \n      the time derivative of the data to extract Looks for 'joint_X' groups. If pbody is not initialized, will choose the first joint_X found.\n    \n    *Return*\n        true if at least one group was found for extracting \n        ";
m["ja function ConfigurationSpecification ExtractDeltaTime"] = "\n\nbool  **ExtractDeltaTime**\\(dReal  & deltatime, std::vector<  dReal  >::const_iterator itdata)\n    \n    extracts the delta time from the configuration if one exists\n    \n    *Return*\n        true if deltatime exists in the current configuration, otherwise false \n        ";
m["ja function ConfigurationSpecification InsertDeltaTime"] = "\n\nbool  **InsertDeltaTime**\\(std::vector<  dReal  >::iterator itdata, dReal deltatime)\n    \n    sets the deltatime field of the data if one exists\n    \n    *Parameters*\n     ``inout]`` - \n      itdata data in the format of this configuration specification. \n     ``deltatime`` - \n      the delta time of the time stamp (from previous point)\n    \n    *Return*\n        true if at least one group was found for inserting \n        ";
m["ja function planningutils::ManipulatorIKGoalSampler  Sample"] = "\n\nIkReturnPtr  **Sample**\\()\n    \n    if can sample, returns IkReturn pointer\n    \n            ";
m["ja function planningutils::ManipulatorIKGoalSampler  SampleAll"] = "\n\nbool  **SampleAll**\\(std::list<  IkReturnPtr  > & samples)\n    \n    samples the rests of the samples until cannot be sampled anymore.\n    \n    *Parameters*\n     ``vsamples`` - \n      vector is rest with samples\n    \n    *Return*\n        true if a sample was inserted into vsamples \n        ";
m["ja function ConvertTrajectorySpecification"] = "\n\nOPENRAVE_API  void  **ConvertTrajectorySpecification**\\(TrajectoryBasePtr traj, const  ConfigurationSpecification  & spec)\n    \n    convert the trajectory and all its points to a new specification\n    \n            ";
m["ja function ComputeTrajectoryDerivatives"] = "\n\nOPENRAVE_API  void  **ComputeTrajectoryDerivatives**\\(TrajectoryBasePtr traj, int maxderiv)\n    \n    computes the trajectory derivatives and modifies the trajetory configuration to store them.\n    \n    *Parameters*\n     ``traj`` - \n      the re-timed trajectory \n     ``maxderiv`` - \n      the maximum derivative to assure. If 1, will assure velocities, if 2 will assure accelerations, etc. If necessary will change the configuration specification of the trajectory. If more derivatives are requested than the trajectory supports, will ignore them. For example, acceleration of a linear trajectory. \n            ";
m["ja function ReverseTrajectory"] = "\n\nOPENRAVE_API   TrajectoryBasePtr  **ReverseTrajectory**\\(TrajectoryBaseConstPtr traj)\n    \n    returns a new trajectory with the order of the waypoints and times reversed.\n    \n    Velocities are just negated and the new trajectory is not guaranteed to be executable or valid         ";
m["ja function VerifyTrajectory"] = "\n\nvoid  **VerifyTrajectory**\\(TrajectoryBaseConstPtr trajectory, dReal samplingstep)\n    \n            ";
m["ja function SmoothActiveDOFTrajectory"] = "\n\nOPENRAVE_API  void  **SmoothActiveDOFTrajectory**\\(TrajectoryBasePtr traj, RobotBasePtr robot, dReal fmaxvelmult = 1 , dReal fmaxaccelmult = 1 , const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Smooth the trajectory points to avoiding collisions by extracting and using the currently set active dofs of the robot.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``robot`` - \n      use the robot's active dofs to initialize the trajectory space \n     ``plannername`` - \n      the name of the planner to use to smooth. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Only initial and goal configurations are preserved. The velocities for the current trajectory are overwritten. The returned trajectory will contain data only for the currenstly set active dofs of the robot. \n            ";
m["ja function SmoothAffineTrajectory"] = "\n\nOPENRAVE_API  void  **SmoothAffineTrajectory**\\(TrajectoryBasePtr traj, const std::vector<  dReal  > & maxvelocities, const std::vector<  dReal  > & maxaccelerations, const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Smooth the trajectory points consisting of affine transformation values while avoiding collisions.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``maxvelocities`` - \n      the max velocities of each dof \n     ``maxaccelerations`` - \n      the max acceleration of each dof \n     ``plannername`` - \n      the name of the planner to use to smooth. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Only initial and goal configurations are preserved. \n            ";
m["ja function SmoothTrajectory"] = "\n\nOPENRAVE_API  void  **SmoothTrajectory**\\(TrajectoryBasePtr traj, dReal fmaxvelmult = 1 , dReal fmaxaccelmult = 1 , const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Smooth the trajectory points to avoiding collisions by extracting and using the positional data from the trajectory.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``plannername`` - \n      the name of the planner to use to smooth. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Only initial and goal configurations are preserved. The velocities for the current trajectory are overwritten. The returned trajectory will contain data only for the currenstly set active dofs of the robot. \n            ";
m["ja function RetimeActiveDOFTrajectory"] = "\n\nOPENRAVE_API  void  **RetimeActiveDOFTrajectory**\\(TrajectoryBasePtr traj, RobotBasePtr robot, bool hastimestamps = false , dReal fmaxvelmult = 1 , dReal fmaxaccelmult = 1 , const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Retime the trajectory points by extracting and using the currently set active dofs of the robot.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``robot`` - \n      use the robot's active dofs to initialize the trajectory space \n     ``plannername`` - \n      the name of the planner to use to retime. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Collision is not checked. Every waypoint in the trajectory is guaranteed to be hit. The velocities for the current trajectory are overwritten. The returned trajectory will contain data only for the currenstly set active dofs of the robot. \n            ";
m["ja function RetimeAffineTrajectory"] = "\n\nOPENRAVE_API  void  **RetimeAffineTrajectory**\\(TrajectoryBasePtr traj, const std::vector<  dReal  > & maxvelocities, const std::vector<  dReal  > & maxaccelerations, bool hastimestamps = false , const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Retime the trajectory points consisting of affine transformation values while avoiding collisions.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``maxvelocities`` - \n      the max velocities of each dof \n     ``maxaccelerations`` - \n      the max acceleration of each dof \n     ``plannername`` - \n      the name of the planner to use to retime. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Collision is not checked. Every waypoint in the trajectory is guaranteed to be hit. The velocities for the current trajectory are overwritten. \n            ";
m["ja function RetimeTrajectory"] = "\n\nOPENRAVE_API  void  **RetimeTrajectory**\\(TrajectoryBasePtr traj, bool hastimestamps = false , dReal fmaxvelmult = 1 , dReal fmaxaccelmult = 1 , const std::string & plannername = \"\" , const std::string & plannerparameters = \"\" )\n    \n    Retime the trajectory points using all the positional data from the trajectory.\n    \n    *Parameters*\n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``plannername`` - \n      the name of the planner to use to retime. If empty, will use the default trajectory re-timer. \n     ``hastimestamps`` - \n      if true, use the already initialized timestamps of the trajectory \n     ``plannerparameters`` - \n      XML string to be appended to PlannerBase::PlannerParameters::_sExtraParameters passed in to the planner. Collision is not checked. Every waypoint in the trajectory is guaranteed to be hit. The velocities for the current trajectory are overwritten. The returned trajectory will contain data only for the currenstly set active dofs of the robot. \n            ";
m["ja function InsertWaypointWithSmoothing"] = "\n\nOPENRAVE_API  void  **InsertWaypointWithSmoothing**\\(int index, const std::vector<  dReal  > & dofvalues, const std::vector<  dReal  > & dofvelocities, TrajectoryBasePtr traj, dReal fmaxvelmult = 1 , dReal fmaxaccelmult = 1 , const std::string & plannername = \"\" )\n    \n    insert a waypoint in a timed trajectory and smooth so that the trajectory always goes through the waypoint at the specified velocity.\n    \n    *Parameters*\n     ``index`` - \n      The index where to insert the new waypoint. A negative value starts from the end. \n     ``dofvalues`` - \n      the configuration to insert into the trajectcory (active dof values of the robot) \n     ``dofvelocities`` - \n      the velocities that the inserted point should start with \n     ``traj`` - \n      the trajectory that initially contains the input points, it is modified to contain the new re-timed data. \n     ``plannername`` - \n      the name of the planner to use to smooth. If empty, will use the default trajectory smoother. The PlannerParameters is automatically determined from the trajectory's configuration space \n            ";
m["ja function MergeTrajectories"] = "\n\nOPENRAVE_API   TrajectoryBasePtr  **MergeTrajectories**\\(const std::list<  TrajectoryBaseConstPtr  > & listtrajectories)\n    \n    merges the contents of multiple trajectories into one so that everything can be played simultaneously.\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      throws an exception if the trajectory data is incompatible and cannot be merged. Each trajectory needs to have a 'deltatime' group for timestamps. The trajectories cannot share common configuration data because only one trajectories's data can be set at a time. \n            ";
m["ja function GetDHParameters"] = "\n\nOPENRAVE_API  void  **GetDHParameters**\\(std::vector<  DHParameter  > & vparameters, KinBodyConstPtr pbody)\n    \n    returns the Denavit-Hartenberg parameters of the kinematics structure of the body.\n    \n    *Parameters*\n     ``vparameters`` - \n      One set of parameters are returned for each joint. \\ *Parameters*\n     ``tstart`` - \n      the initial transform in the body coordinate system to the first joint If the robot has joints that cannot be represented by DH, will throw an exception. Passive joints are ignored. Joints are ordered by hierarchy dependency. By convention N joints give N-1 DH parameters, but GetDHParameters returns N parameters. The reason is because the first parameter is used to define the coordinate system of the first axis relative to the robot origin.\n    \n    *Note*\n        The coordinate systems computed from the DH parameters do not match the OpenRAVE link coordinate systems.\n\n    *See*\n        DHParameter. \n        ";
m["ja function RaveSetDebugLevel"] = "\n\nOPENRAVE_API  void  **RaveSetDebugLevel**\\(int level)\n    \n    Sets the global openrave debug level. A combination of DebugLevel.\n    \n            ";
m["ja function RaveGetDebugLevel"] = "\n\nOPENRAVE_API  int  **RaveGetDebugLevel**\\()\n    \n    Returns the openrave debug level.\n    \n            ";
m["ja function RaveSetDataAccess"] = "\n\nOPENRAVE_API  void  **RaveSetDataAccess**\\(int accessoptions)\n    \n    Sets the default data access options for cad resources/robot files.\n    \n    *Parameters*\n     ``accessoptions`` - \n      - if 1 will only allow resources inside directories specified from OPERNAVE_DATA environment variable. This allows reject of full paths from unsecure/unauthenticated resources. Controls how files are processed in functions like RaveFindLocalFile \n            ";
m["ja function RaveGetDataAccess"] = "\n\nOPENRAVE_API  int  **RaveGetDataAccess**\\()\n    \n    Returns the acess options set.\n    \n    *See*\n        RaveSetDataAccess \n        ";
m["ja function RaveGetHomeDirectory"] = "\n\nOPENRAVE_API  std::string  **RaveGetHomeDirectory**\\()\n    \n    Returns the openrave home directory where settings, cache, and other files are stored.\n    \n    On Linux/Unix systems, this is usually $HOME/.openrave, on Windows this is $HOMEPATH/.openrave         ";
m["ja function RaveFindDatabaseFile"] = "\n\nOPENRAVE_API  std::string  **RaveFindDatabaseFile**\\(const std::string & filename, bool bRead = true )\n    \n    Searches for a filename in the database and returns a full path/URL to it.\n    \n    *Parameters*\n     ``filename`` - \n      the relative filename in the database \n     ``bRead`` - \n      if true will only return a file if it exists. If false, will return the filename of the first valid database directory.\n    \n    *Return*\n        a non-empty string if a file could be found. \n        ";
m["ja function RaveInitialize"] = "\n\nOPENRAVE_API  int  **RaveInitialize**\\(bool bLoadAllPlugins = true , int level = Level_Info )\n    \n    Explicitly initializes the global OpenRAVE state (optional).\n    \n    *Parameters*\n     ``bLoadAllPlugins`` - \n      If true will load all the openrave plugins automatically that can be found in the OPENRAVE_PLUGINS environment path Optional function to initialize openrave plugins, logging, and read OPENRAVE_* environment variables. Although environment creation will automatically make sure this function is called, users might want explicit control of when this happens. Will not do anything if OpenRAVE runtime is already initialized. If OPENRAVE_* environment variables must be re-read, first call RaveDestroy.\n    \n    *Return*\n        0 if successful, otherwise an error code \n        ";
m["ja function RaveDestroy"] = "\n\nOPENRAVE_API  void  **RaveDestroy**\\()\n    \n    Destroys the entire OpenRAVE state and all loaded environments.\n    \n    This functions should be always called before program shutdown in order to assure all resources are relased appropriately.         ";
m["ja function RaveGetPluginInfo"] = "\n\nOPENRAVE_API  void  **RaveGetPluginInfo**\\(std::list< std::pair< std::string,  PLUGININFO  > > & plugins)\n    \n    Get all the loaded plugins and the interfaces they support.\n    \n    *Parameters*\n     ``plugins`` - \n      A list of plugins. Each entry has the plugin name and the interfaces it supports \n            ";
m["ja function RaveGetLoadedInterfaces"] = "\n\nOPENRAVE_API  void  **RaveGetLoadedInterfaces**\\(std::map< InterfaceType, std::vector< std::string > > & interfacenames)\n    \n    Get a list of all the loaded interfaces.\n    \n            ";
m["ja function RaveReloadPlugins"] = "\n\nOPENRAVE_API  void  **RaveReloadPlugins**\\()\n    \n    Reloads all the plugins.\n    \n    The interfaces currently created remain will continue using the old plugins, so this function is safe in that plugins currently loaded remain loaded until the last interface that uses them is released.         ";
m["ja function RaveHasInterface"] = "\n\nOPENRAVE_API  bool  **RaveHasInterface**\\(InterfaceType type, const std::string & interfacename)\n    \n    Returns true if interface can be created, otherwise false.\n    \n            ";
m["ja function RaveGlobalState"] = "\n\nOPENRAVE_API   UserDataPtr  **RaveGlobalState**\\()\n    \n    A pointer to the global openrave state.\n    \n    *Return*\n        a managed pointer to the state. \n        ";
m["ja function RaveClone"] = "\n\nboost::shared_ptr< T >  **RaveClone**\\(boost::shared_ptr< T const  > preference, int cloningoptions)\n    \n    returned a fully cloned interface\n    \n            ";
m["ja function RaveGetIkTypeFromUniqueId"] = "\n\nOPENRAVE_API   IkParameterizationType  **RaveGetIkTypeFromUniqueId**\\(int uniqueid)\n    \n    returns the IkParameterizationType given the unique id detmerined b IKP_UniqueIdMask\n    \n            ";
m["ja function RaveGetIndexFromAffineDOF"] = "\n\nOPENRAVE_API  int  **RaveGetIndexFromAffineDOF**\\(int affinedofs, DOFAffine dof)\n    \n    Given a mask of affine dofs and a dof inside that mask, returns the index where the value could be found.\n    \n    *Parameters*\n     ``affinedofs`` - \n      a mask of DOFAffine values \n     ``dof`` - \n      a set of values inside affinedofs, the index of the first value is returned \\ *Exceptions*\n     ``openrave_exception`` - \n      throws if dof is not present in affinedofs\n    \n            ";
m["ja function RaveGetAffineDOFFromIndex"] = "\n\nOPENRAVE_API   DOFAffine  **RaveGetAffineDOFFromIndex**\\(int affinedofs, int index)\n    \n    Given a mask of affine dofs and an index into the array, returns the affine dof that is being referenced.\n    \n    *Parameters*\n     ``affinedofs`` - \n      a mask of DOFAffine values \n     ``index`` - \n      an index into the affine dof array \\ *Exceptions*\n     ``openrave_exception`` - \n      throws if dof if index is out of bounds\n    \n            ";
m["ja function RaveGetAffineDOF"] = "\n\nOPENRAVE_API  int  **RaveGetAffineDOF**\\(int affinedofs)\n    \n    Returns the degrees of freedom needed to represent all the values in the affine dof mask.\n    \n    *Exceptions*\n     ``openrave_exception`` - \n      throws if \n            ";
m["ja function RaveGetAffineDOFValuesFromTransform"] = "\n\nOPENRAVE_API  void  **RaveGetAffineDOFValuesFromTransform**\\(std::vector<  dReal  >::iterator itvalues, const  Transform  & t, int affinedofs, const  Vector  & vActvAffineRotationAxis = Vector (0, 0, 1) )\n    \n    Converts the transformation matrix into the specified affine values format.\n    \n    *Parameters*\n     ``itvalues`` - \n      an iterator to the vector to write the values to. Will write exactly RaveGetAffineDOF(affinedofs) values. \n     ``the`` - \n      affine transformation to convert \n     ``affinedofs`` - \n      the affine format to output values in \n     ``vActvAffineRotationAxis`` - \n      optional rotation axis if affinedofs specified DOF_RotationAxis \n            ";
m["ja function RaveGetAffineConfigurationSpecification"] = "\n\nOPENRAVE_API   ConfigurationSpecification  **RaveGetAffineConfigurationSpecification**\\(int affinedofs, KinBodyConstPtr pbody = KinBodyConstPtr () , const std::string & interpolation = \"\" )\n    \n            ";
m["ja function RaveSetDebugLevel"] = "\n\nOPENRAVE_API  void  **RaveSetDebugLevel**\\(int level)\n    \n    Sets the global openrave debug level. A combination of DebugLevel.\n    \n            ";
m["ja function RaveGetDebugLevel"] = "\n\nOPENRAVE_API  int  **RaveGetDebugLevel**\\()\n    \n    Returns the openrave debug level.\n    \n            ";
m["ja function quatFromAxisAngle \"const RaveVector\""] = "\n\nRaveVector < T >  **quatFromAxisAngle**\\(const  RaveVector < T > & axisangle)\n    \n    Converts an axis-angle rotation into a quaternion.\n    \n    *Parameters*\n     ``axisangle`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["ja function quatFromAxisAngle \"const RaveVector; T\""] = "\n\nRaveVector < T >  **quatFromAxisAngle**\\(const  RaveVector < T > & axis, T angle)\n    \n    Converts an axis-angle rotation into a quaternion.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis, 3 values \n     ``angle`` - \n      rotation angle (radians) \n            ";
m["ja function quatFromMatrix \"const RaveTransform\""] = "\n\nRaveVector < T >  **quatFromMatrix**\\(const  RaveTransformMatrix < T > & rotation)\n    \n    Converts the rotation of a matrix into a quaternion.\n    \n    *Parameters*\n     ``t`` - \n      transform for extracting the 3x3 rotation. \n            ";
m["ja function quatSlerp \"const RaveVector; const RaveVector; T\""] = "\n\nRaveVector < T >  **quatSlerp**\\(const  RaveVector < T > & quat0, const  RaveVector < T > & quat1, T t)\n    \n    Sphereical linear interpolation between two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n     ``t`` - \n      real value in [0,1]. 0 returns quat1, 1 returns quat2 \n            ";
m["ja function axisAngleFromMatrix \"const RaveTransformMatrix\""] = "\n\nRaveVector < T >  **axisAngleFromMatrix**\\(const  RaveTransformMatrix < T > & rotation)\n    \n    Converts the rotation of a matrix into axis-angle representation.\n    \n    *Parameters*\n     ``rotation`` - \n      3x3 rotation matrix \n            ";
m["ja function axisAngleFromQuat \"const RaveVector\""] = "\n\nRaveVector < T >  **axisAngleFromQuat**\\(const  RaveVector < T > & quat)\n    \n    Converts a quaternion into the axis-angle representation.\n    \n    *Parameters*\n     ``quat`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["ja function matrixFromQuat \"const RaveVector\""] = "\n\nRaveTransformMatrix < T >  **matrixFromQuat**\\(const  RaveVector < T > & quat)\n    \n    Converts a quaternion to a 3x3 matrix.\n    \n    *Parameters*\n     ``quat`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["ja function matrixFromAxisAngle \"const RaveVector\""] = "\n\nRaveTransformMatrix < T >  **matrixFromAxisAngle**\\(const  RaveVector < T > & axisangle)\n    \n    Converts an axis-angle rotation to a 3x3 matrix.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["ja function matrixFromAxisAngle \"const RaveVector\""] = "\n\nRaveTransformMatrix < T >  **matrixFromAxisAngle**\\(const  RaveVector < T > & axisangle)\n    \n    Converts an axis-angle rotation to a 3x3 matrix.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["ja function quatRotateDirection"] = "\n\nRaveVector < T >  **quatRotateDirection**\\(const  RaveVector < T > & sourcedir, const  RaveVector < T > & targetdir)\n    \n    Return the minimal quaternion that orients sourcedir to targetdir.\n    \n    *Parameters*\n     ``sourcedir`` - \n      direction of the original vector, 3 values \n     ``targetdir`` - \n      new direction, 3 values \n            ";
m["ja function quatMultiply"] = "\n\nRaveVector < T >  **quatMultiply**\\(const  RaveVector < T > & quat0, const  RaveVector < T > & quat1)\n    \n    Multiply two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["ja function quatMultiply"] = "\n\nRaveVector < T >  **quatMultiply**\\(const  RaveVector < T > & quat0, const  RaveVector < T > & quat1)\n    \n    Multiply two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["ja function quatInverse"] = "\n\nRaveVector < T >  **quatInverse**\\(const  RaveVector < T > & quat)\n    \n    Inverted a quaternion rotation.\n    \n    *Parameters*\n     ``quat`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["ja function normalizeAxisRotation"] = "\n\nstd::pair< T,  RaveVector < T > >  **normalizeAxisRotation**\\(const  RaveVector < T > & axis, const  RaveVector < T > & quat)\n    \n    Find the rotation theta around axis such that rot(axis,theta) * q is closest to the identity rotation.\n    \n    *Parameters*\n     ``axis`` - \n      axis to minimize rotation about \n     ``quat`` - \n      input\n    \n    *Return*\n        The angle that minimizes the rotation along with the normalized rotation rot(axis,theta)*q \n        ";
m["ja enum DOFAffine"] = "\n\n **DOFAffine**\n    \n    Selects which DOFs of the affine transformation to include in the active configuration.\n    \n            ";
m["ja enum SaveParameters"] = "\n\n **SaveParameters**\n    \n    Parameters passed into the state savers to control what information gets saved.\n    \n            ";
m["ja enum CheckLimitsAction"] = "\n\n **CheckLimitsAction**\n    \n    used for specifying the type of limit checking and the messages associated with it\n    \n            ";
m["ja enum AdjacentOptions"] = "\n\n **AdjacentOptions**\n    \n    specifies the type of adjacent link information to receive\n    \n            ";
m["ja enum GeomType"] = "\n\n **GeomType**\n    \n    The type of geometry primitive.\n    \n            ";
m["ja enum JointType"] = "\n\n **JointType**\n    \n    The type of joint movement.\n    \n    Non-special joints that are combinations of revolution and prismatic joints. The first 4 bits specify the joint DOF, the next bits specify whether the joint is revolute (0) or prismatic (1). There can be also special joint types that are valid if the JointSpecialBit is set.For multi-dof joints, the order is transform(parentlink) * transform(axis0) * transform(axis1) ...         ";
m["ja enum ActuatorState"] = "\n\n **ActuatorState**\n    \n    the state of the actuator\n    \n            ";
m["ja enum SensorType"] = "\n\n **SensorType**\n    \n            ";
m["ja enum ConfigureCommand"] = "\n\n **ConfigureCommand**\n    \n    A set of commands used for run-time sensor configuration.\n    \n            ";
m["ja enum CollisionOptions"] = "\n\n **CollisionOptions**\n    \n    options for collision checker\n    \n            ";
m["ja enum CollisionAction"] = "\n\n **CollisionAction**\n    \n    action to perform whenever a collision is detected between objects\n    \n            ";
m["ja enum IkParameterizationType"] = "\n\n **IkParameterizationType**\n    \n    The types of inverse kinematics parameterizations supported.\n    \n    The minimum degree of freedoms required is set in the upper 4 bits of each type. The number of values used to represent the parameterization ( >= dof ) is the next 4 bits. The lower bits contain a unique id of the type.         ";
m["ja enum SelectionOptions"] = "\n\n **SelectionOptions**\n    \n    A set of options used to select particular parts of the scene.\n    \n            ";
m["ja enum IkFilterOptions"] = "\n\n **IkFilterOptions**\n    \n    Controls what information gets validated when searching for an inverse kinematics solution.\n    \n            ";
m["ja enum IkReturnAction"] = "\n\n **IkReturnAction**\n    \n    Return value for the ik filter that can be optionally set on an ik solver.\n    \n            ";
m["ja enum PlannerStatus"] = "\n\n **PlannerStatus**\n    \n    the status of the PlanPath method. Used when PlanPath can be called multiple times to resume planning.\n    \n            ";
m["ja enum PlannerAction"] = "\n\n **PlannerAction**\n    \n    action to send to the planner while it is planning. This is usually done by the user-specified planner callback function\n    \n            ";
m["ja enum ViewerEvents"] = "\n\n **ViewerEvents**\n    \n            ";
m["ja enum OpenRAVEErrorCode"] = "\n\n **OpenRAVEErrorCode**\n    \n    OpenRAVE error codes\n    \n            ";
m["ja enum DebugLevel"] = "\n\n **DebugLevel**\n    \n            ";
m["ja enum SerializationOptions"] = "\n\n **SerializationOptions**\n    \n    serialization options for interfaces\n    \n            ";
m["ja enum CloningOptions"] = "\n\n **CloningOptions**\n    \n            ";
m["ja enum PhysicsEngineOptions"] = "\n\n **PhysicsEngineOptions**\n    \n    basic options for physics engine\n    \n            ";
m["ja enum IntervalType"] = "\n\n **IntervalType**\n    \n    Specifies the boundary conditions of intervals for sampling.\n    \n            ";
m["ja enum SampleDataType"] = "\n\n **SampleDataType**\n    \n            ";

}
}
