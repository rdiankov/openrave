// -*- coding: utf-8 -*-
// Copyright (C) 2006-2010 Rosen Diankov (rosen.diankov@gmail.com)
//
// This file is part of OpenRAVE.
// OpenRAVE is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
/// Auto-generated using build_openravepy_internal.py from ../python/bindings/openravepy_int.cpp file
#include "docstrings.h"
namespace openravepy {
void InitializeComments(std::map<std::string,std::string>& m)
{m["en function InterfaceBase GetInterfaceType"] = "\n\nInterfaceType  **GetInterfaceType**\\()\n    \n            ";
m["en function InterfaceBase GetXMLId"] = "\n\nconst std::string &  **GetXMLId**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the unique identifier that describes this class type, case is ignored should be the same id used to create the object \n        ";
m["en function InterfaceBase GetPluginName"] = "\n\nconst std::string &  **GetPluginName**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the pluginname this interface was loaded from \n        ";
m["en function InterfaceBase GetDescription"] = "\n\nconst std::string &  **GetDescription**\\()\n    \n    Documentation of the interface in reStructuredText format. See Documenting Interfaces.\n    \n            ";
m["en function InterfaceBase GetEnv"] = "\n\n*EnvironmentBasePtr*  **GetEnv**\\()\n    \n    *Return*\n        the environment that this interface is attached to \n        ";
m["en function InterfaceBase Clone"] = "\n\nbool  **Clone**\\(*InterfaceBaseConstPtr* preference, int cloningoptions)\n    \n    Clone the contents of an interface to the current interface.\n    \n    *Parameters*\n     ``preference`` - \n      the interface whose information to clone \n     ``cloningoptions`` - \n      mask of CloningOptions \n            ";
m["en function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(boost::shared_ptr< void > data)\n    \n    set user data\n    \n            ";
m["en function InterfaceBase GetUserData"] = "\n\nboost::shared_ptr< void >  **GetUserData**\\()\n    \n    *Return*\n        user custom data \n        ";
m["en function InterfaceBase SendCommand"] = "\n\nbool  **SendCommand**\\(std::ostream & os, std::istream & is)\n    \n    Used to send special commands to the interface and receive output.\n    \n    The command must be registered by *RegisterCommand*. A special command ' is always supported and provides a way for the user to query the current commands and the help string. The format of the returned help commands are in reStructuredText. The following commands are possible:\n    *Parameters*\n     ``is`` - \n      the input stream containing the command \n     ``os`` - \n      the output stream containing the output \\ *Exceptions*\n     ``*openrave_exception*`` - \n      Throw if the command is not supported.\n    \n    *Return*\n        true if the command is successfully processed, otherwise false. \n        ";
m["en function KinBody InitFromFile"] = "\n\nbool  **InitFromFile**\\(const std::string & filename, const std::list< std::pair< std::string, std::string > > & atts)\n    \n    Build the robot from an XML filename.\n    \n            ";
m["en function KinBody InitFromData"] = "\n\nbool  **InitFromData**\\(const std::string & data, const std::list< std::pair< std::string, std::string > > & atts)\n    \n    Build the robot from a string representing XML information.\n    \n            ";
m["en function KinBody InitFromBoxes \"const std::vector< AABB; bool\""] = "\n\nbool  **InitFromBoxes**\\(const std::vector<  *AABB*  > & boxes, bool draw)\n    \n    Create a kinbody with one link composed of an array of aligned bounding boxes.\n    \n    *Parameters*\n     ``vaabbs`` - \n      the array of aligned bounding boxes that will comprise of the body \n     ``bDraw`` - \n      if true, the boxes will be rendered in the scene \n            ";
m["en function KinBody InitFromTrimesh"] = "\n\nbool  **InitFromTrimesh**\\(const  *Link::TRIMESH*  & trimesh, bool draw)\n    \n    Create a kinbody with one link composed of a triangle mesh surface.\n    \n    *Parameters*\n     ``trimesh`` - \n      the triangle mesh \n     ``bDraw`` - \n      if true, will be rendered in the scene \n            ";
m["en function KinBody SetName"] = "\n\nvoid  **SetName**\\(const std::string & name)\n    \n    Set the name of the robot, notifies the environment and checks for uniqueness.\n    \n            ";
m["en function KinBody GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n    Unique name of the robot.\n    \n            ";
m["en function KinBody GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    *Return*\n        number of controllable degrees of freedom of the body. Only uses _vecjoints and last joint for computation, so can work before ComputeJointHierarchy is called. \n        ";
m["en function KinBody GetDOFValues"] = "\n\nvoid  **GetDOFValues**\\(std::vector<  *dReal*  > & v)\n    \n    Returns all the joint values as organized by the DOF indices.\n    \n            ";
m["en function KinBody GetDOFValues"] = "\n\nvoid  **GetDOFValues**\\(std::vector<  *dReal*  > & v)\n    \n    Returns all the joint values as organized by the DOF indices.\n    \n            ";
m["en function KinBody GetDOFVelocities"] = "\n\nvoid  **GetDOFVelocities**\\(std::vector<  *dReal*  > & v)\n    \n            ";
m["en function KinBody GetDOFLimits"] = "\n\nvoid  **GetDOFLimits**\\(std::vector<  *dReal*  > & vLowerLimit, std::vector<  *dReal*  > & vUpperLimit)\n    \n            ";
m["en function KinBody GetDOFMaxVel"] = "\n\nvoid  **GetDOFMaxVel**\\(std::vector<  *dReal*  > & v)\n    \n            ";
m["en function KinBody GetDOFWeights"] = "\n\nvoid  **GetDOFWeights**\\(std::vector<  *dReal*  > & v)\n    \n            ";
m["en function KinBody GetJointValues"] = "\n\nvoid  **GetJointValues**\\(std::vector<  *dReal*  > & v)\n    \n            ";
m["en function KinBody GetJointVelocities"] = "\n\nvoid  **GetJointVelocities**\\(std::vector<  *dReal*  > & v)\n    \n            ";
m["en function KinBody GetJointLimits"] = "\n\nvoid  **GetJointLimits**\\(std::vector<  *dReal*  > & vLowerLimit, std::vector<  *dReal*  > & vUpperLimit)\n    \n            ";
m["en function KinBody GetJointMaxVel"] = "\n\nvoid  **GetJointMaxVel**\\(std::vector<  *dReal*  > & v)\n    \n            ";
m["en function KinBody GetJointWeights"] = "\n\nvoid  **GetJointWeights**\\(std::vector<  *dReal*  > & v)\n    \n            ";
m["en function KinBody GetLinks"] = "\n\nconst std::vector<  *LinkPtr*  > &  **GetLinks**\\()\n    \n    *Return*\n        the links of the robot \n        ";
m["en function KinBody GetLinks"] = "\n\nconst std::vector<  *LinkPtr*  > &  **GetLinks**\\()\n    \n    *Return*\n        the links of the robot \n        ";
m["en function KinBody GetLink"] = "\n\n*LinkPtr*  **GetLink**\\(const std::string & name)\n    \n    return a pointer to the link with the given name\n    \n            ";
m["en function KinBody GetJoints"] = "\n\nconst std::vector<  *JointPtr*  > &  **GetJoints**\\()\n    \n    Returns the joints making up the degrees of freedom in the user-defined order.\n    \n            ";
m["en function KinBody GetJoints"] = "\n\nconst std::vector<  *JointPtr*  > &  **GetJoints**\\()\n    \n    Returns the joints making up the degrees of freedom in the user-defined order.\n    \n            ";
m["en function KinBody GetPassiveJoints"] = "\n\nconst std::vector<  *JointPtr*  > &  **GetPassiveJoints**\\()\n    \n    Returns the passive joints, order does not matter.\n    \n            ";
m["en function KinBody GetDependencyOrderedJoints"] = "\n\nconst std::vector<  *JointPtr*  > &  **GetDependencyOrderedJoints**\\()\n    \n    Returns the joints in hierarchical order starting at the base link.\n    \n    In the case of closed loops, the joints are returned in the order they are defined in _vecjoints.\n    \n    *Return*\n        Vector of joints such that the beginning joints affect the later ones. \n        ";
m["en function KinBody GetRigidlyAttachedLinks"] = "\n\nvoid  **GetRigidlyAttachedLinks**\\(int linkindex, std::vector<  *LinkPtr*  > & vattachedlinks)\n    \n    Gets all the rigidly attached links to linkindex, also adds the link to the list.\n    \n    *Parameters*\n     ``linkindex`` - \n      the index to check for attached links. If < 0, then will return all links attached to the environment \n     ``vattachedlinks`` - \n      the array to insert all links attached to linkindex with the link itself. \n            ";
m["en function KinBody GetChain"] = "\n\nbool  **GetChain**\\(int linkbaseindex, int linkendindex, std::vector<  *JointPtr*  > & vjoints)\n    \n    Computes the minimal chain of joints that are between two links in the order of linkbaseindex to linkendindex.\n    \n    *Parameters*\n     ``linkbaseindex`` - \n      the base link index to start the search \n     ``linkendindex`` - \n      the link index where the search ends \n     ``vjoints`` - \n      the joints to fill that describe the chain Passive joints are used to detect rigidly attached links and mimic joints, otherwise they are ignored in the computation of the chain. If a mimic joint is found along the path, the joint returned is the source joint!\n    \n    *Return*\n        true if the two links are connected (vjoints will be filled), false if the links are separate \n        ";
m["en function KinBody GetJoint"] = "\n\n*JointPtr*  **GetJoint**\\(const std::string & name)\n    \n    Return a pointer to the joint with the given name.\n    \n            ";
m["en function KinBody GetTransform"] = "\n\n*Transform*  **GetTransform**\\()\n    \n    queries the transfromation of the first link of the body\n    \n            ";
m["en function KinBody GetBodyTransformations"] = "\n\nvoid  **GetBodyTransformations**\\(std::vector<  *Transform*  > & vtrans)\n    \n            ";
m["en function KinBody SetBodyTransformations"] = "\n\nvoid  **SetBodyTransformations**\\(const std::vector<  *Transform*  > & transforms)\n    \n            ";
m["en function KinBody GetLinkVelocities"] = "\n\nvoid  **GetLinkVelocities**\\(std::vector< std::pair<  *Vector* ,  *Vector*  > > & velocities)\n    \n    Returns the linear and angular velocities for each link.\n    \n            ";
m["en function KinBody ComputeAABB"] = "\n\n*AABB*  **ComputeAABB**\\()\n    \n    Return an axis-aligned bounding box of the entire object.\n    \n            ";
m["en function KinBody Enable"] = "\n\nvoid  **Enable**\\(bool enable)\n    \n    Enables or disables the bodies.\n    \n            ";
m["en function KinBody IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    *Return*\n        true if any link of the *KinBody* is enabled \n        ";
m["en function KinBody SetTransform"] = "\n\nvoid  **SetTransform**\\(const  *Transform*  & transform)\n    \n    set the transform of the first link (the rest of the links are computed based on the joint values).\n    \n    *Parameters*\n     ``transform`` - \n      affine transformation \n            ";
m["en function KinBody SetJointValues \"const std::vector; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  *dReal*  > & values, bool checklimits = false )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices)  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["en function KinBody SetJointValues \"const std::vector; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  *dReal*  > & values, bool checklimits = false )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices)  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["en function KinBody SetJointValues \"const std::vector; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  *dReal*  > & values, bool checklimits = false )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices)  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["en function KinBody SetJointValues \"const std::vector; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  *dReal*  > & values, bool checklimits = false )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices)  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["en function KinBody SetJointTorques"] = "\n\nvoid  **SetJointTorques**\\(const std::vector<  *dReal*  > & torques, bool add)\n    \n    Adds a torque to every joint.\n    \n    *Parameters*\n     ``bAdd`` - \n      if true, adds to previous torques, otherwise resets the torques on all bodies and starts from 0 \n            ";
m["en function KinBody SetJointValues \"const std::vector; const Transform; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  *dReal*  > & values, const  *Transform*  & transform, bool checklimits = false )\n    \n    Sets the joint values and transformation of the body.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``transform`` - \n      represents the transformation of the first body.  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["en function KinBody SetJointValues \"const std::vector; const Transform; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  *dReal*  > & values, const  *Transform*  & transform, bool checklimits = false )\n    \n    Sets the joint values and transformation of the body.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``transform`` - \n      represents the transformation of the first body.  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["en function KinBody CalculateJacobian \"int; const Vector; boost::multi_array\""] = "\n\nvoid  **CalculateJacobian**\\(int linkindex, const  *Vector*  & offset, boost::multi_array<  *dReal* , 2 > & vjacobian)\n    \n    Computes the translation jacobian with respect to a world position.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that the rotation is attached to \n     ``position`` - \n      position in world space where to compute derivatives from. \n     ``vjacobian`` - \n      3xDOF matrix Gets the jacobian with respect to a link by computing the partial differentials for all joints that in the path from the root node to _veclinks[index] (doesn't touch the rest of the values) \n            ";
m["en function KinBody CalculateRotationJacobian \"int; const Vector; boost::multi_array\""] = "\n\nvoid  **CalculateRotationJacobian**\\(int linkindex, const  *Vector*  & quat, boost::multi_array<  *dReal* , 2 > & vjacobian)\n    \n    Computes the rotational jacobian as a quaternion with respect to an initial rotation.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that the rotation is attached to \n     ``qInitialRot`` - \n      the rotation in world space whose derivative to take from. \n     ``vjacobian`` - \n      4xDOF matrix \n            ";
m["en function KinBody CalculateAngularVelocityJacobian \"int; boost::multi_array\""] = "\n\nvoid  **CalculateAngularVelocityJacobian**\\(int linkindex, boost::multi_array<  *dReal* , 2 > & vjacobian)\n    \n    Computes the angular velocity jacobian of a specified link about the axes of world coordinates.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that the rotation is attached to \n     ``vjacobian`` - \n      3xDOF matrix \n            ";
m["en function KinBody CheckSelfCollision"] = "\n\nbool  **CheckSelfCollision**\\(*CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    Check if body is self colliding. Links that are joined together are ignored.\n    \n            ";
m["en function KinBody CheckSelfCollision"] = "\n\nbool  **CheckSelfCollision**\\(*CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    Check if body is self colliding. Links that are joined together are ignored.\n    \n            ";
m["en function KinBody IsAttached"] = "\n\nbool  **IsAttached**\\(*KinBodyConstPtr* body)\n    \n    *Return*\n        true if two bodies should be considered as one during collision (ie one is grabbing the other) \n        ";
m["en function KinBody GetAttached"] = "\n\nvoid  **GetAttached**\\(std::set<  *KinBodyPtr*  > & setAttached)\n    \n    Recursively get all attached bodies of this body, including this body.\n    \n    *Parameters*\n     ``setAttached`` - \n      fills with the attached bodies. If any bodies are already in setAttached, then ignores recursing on their attached bodies. \n            ";
m["en function KinBody IsRobot"] = "\n\nbool  **IsRobot**\\()\n    \n    Return true if this body is derived from *RobotBase*.\n    \n            ";
m["en function KinBody GetEnvironmentId"] = "\n\nint  **GetEnvironmentId**\\()\n    \n    return a unique id of the body used in the environment.\n    \n    If object is not added to the environment, this will return 0. So checking if *GetEnvironmentId()* is 0 is a good way to check if object is present in the environment. This id will not be copied when cloning in order to respect another environment's ids.         ";
m["en function KinBody DoesAffect"] = "\n\nchar  **DoesAffect**\\(int jointindex, int linkindex)\n    \n    *Parameters*\n     ``jointindex`` - \n      index of the joint \n     ``linkindex`` - \n      index of the link returns how the joint effects the link. If zero, link is unaffected. If negative, the partial derivative of the Jacobian should be negated. \n            ";
m["en function KinBody WriteForwardKinematics"] = "\n\nvoid  **WriteForwardKinematics**\\(std::ostream & f)\n    \n    Writes a string for the forward kinematics of the robot (only hinge joints are handled).Format of the string is: where  and  are 3x4 matrices specified in row order (write the first row first) joint_axis is the unit vector for the joint_axis. If link_base is -1, attached to static environment         ";
m["en function KinBody SetGuiData"] = "\n\nvoid  **SetGuiData**\\(boost::shared_ptr< void > data)\n    \n            ";
m["en function KinBody GetGuiData"] = "\n\nboost::shared_ptr< void >  **GetGuiData**\\()\n    \n            ";
m["en function InterfaceBase GetXMLFilename"] = "\n\nconst std::string &  **GetXMLFilename**\\()\n    \n    *Return*\n        the XML filename used to load the interface (sometimes this is not possible if the definition lies inside an environment file). \n        ";
m["en function KinBody GetNonAdjacentLinks"] = "\n\nconst std::set< int > &  **GetNonAdjacentLinks**\\()\n    \n    *Return*\n        all possible link pairs that could get in collision \n        ";
m["en function KinBody GetAdjacentLinks"] = "\n\nconst std::set< int > &  **GetAdjacentLinks**\\()\n    \n    *Return*\n        all possible link pairs whose collisions are ignored. \n        ";
m["en function KinBody GetPhysicsData"] = "\n\nboost::shared_ptr< void >  **GetPhysicsData**\\()\n    \n            ";
m["en function KinBody GetCollisionData"] = "\n\nboost::shared_ptr< void >  **GetCollisionData**\\()\n    \n            ";
m["en function KinBody GetManageData"] = "\n\n*ManageDataPtr*  **GetManageData**\\()\n    \n            ";
m["en function KinBody GetUpdateStamp"] = "\n\nint  **GetUpdateStamp**\\()\n    \n    Return a unique id for every transformation state change of any link. Used to check if robot state has changed.\n    \n    The stamp is used by the collision checkers, physics engines, or any other item that needs to keep track of any changes of the *KinBody* as it moves. Currently stamps monotonically increment for every transformation/joint angle change.         ";
m["en function KinBody serialize"] = "\n\nvoid  **serialize**\\(std::ostream & o, int options)\n    \n            ";
m["en function KinBody GetKinematicsGeometryHash"] = "\n\nconst std::string &  **GetKinematicsGeometryHash**\\()\n    \n    A md5 hash unique to the particular kinematic and geometric structure of a *KinBody*.\n    \n    This 32 byte string can be used to check if two bodies have the same kinematic structure and can be used to index into tables when looking for body-specific models. *OpenRAVE* stores all such models in the OPENRAVE_HOME directory (usually ~/.openrave), indexed by the particular robot/body hashes.\n    \n    *Return*\n        md5 hash string of kinematics/geometry \n        ";
m["en function KinBody::Link GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["en function KinBody::Link GetIndex"] = "\n\nint  **GetIndex**\\()\n    \n            ";
m["en function KinBody::Link IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    returns true if enabled\n    \n    enables a *Link*. An enabled link takes part in collision detection and physics simulations         ";
m["en function KinBody::Link IsStatic"] = "\n\nbool  **IsStatic**\\()\n    \n            ";
m["en function KinBody::Link Enable"] = "\n\nvoid  **Enable**\\(bool enable)\n    \n            ";
m["en function KinBody::Link GetParent"] = "\n\n*KinBodyPtr*  **GetParent**\\()\n    \n            ";
m["en function KinBody::Link GetParentLink"] = "\n\nboost::shared_ptr<  *Link*  >  **GetParentLink**\\()\n    \n    *Return*\n        the parent link in the kinematics hierarchy (ie the link closest to the root that is immediately connected to this link by a joint). If the link has no parents, returns an empty link. Mimic joints do not affect the parent link. \n        ";
m["en function KinBody::Link GetCollisionData"] = "\n\nconst  *TRIMESH*  &  **GetCollisionData**\\()\n    \n            ";
m["en function KinBody::Link ComputeAABB"] = "\n\n*AABB*  **ComputeAABB**\\()\n    \n    *Return*\n        the aabb of all the geometries of the link in the world coordinate system \n        ";
m["en function KinBody::Link GetTransform"] = "\n\n*Transform*  **GetTransform**\\()\n    \n    *Return*\n        current transformation of the link in the world coordinate system \n        ";
m["en function KinBody::Link GetCOMOffset"] = "\n\n*Vector*  **GetCOMOffset**\\()\n    \n    *Return*\n        center of mass offset in the link's local coordinate frame \n        ";
m["en function KinBody::Link GetInertia"] = "\n\nconst  *TransformMatrix*  &  **GetInertia**\\()\n    \n            ";
m["en function KinBody::Link GetMass"] = "\n\n*dReal*  **GetMass**\\()\n    \n            ";
m["en function KinBody::Link SetTransform"] = "\n\nvoid  **SetTransform**\\(const  *Transform*  & transform)\n    \n    *Parameters*\n     ``t`` - \n      the new transformation \n            ";
m["en function KinBody::Link SetForce"] = "\n\nvoid  **SetForce**\\(const  *Vector*  & force, const  *Vector*  & pos, bool add)\n    \n    *Parameters*\n     ``force`` - \n      the direction and magnitude of the force \n     ``pos`` - \n      in the world where the force is getting applied \n     ``add`` - \n      if true, force is added to previous forces, otherwise it is set adds an external force at pos (absolute coords) \n            ";
m["en function KinBody::Link SetTorque"] = "\n\nvoid  **SetTorque**\\(const  *Vector*  & torque, bool add)\n    \n    *Parameters*\n     ``add`` - \n      if true, torque is added to previous torques, otherwise it is set adds torque to a body (absolute coords) \n            ";
m["en function KinBody::Link GetGeometries"] = "\n\nconst std::list<  *GEOMPROPERTIES*  > &  **GetGeometries**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES SetCollisionMesh"] = "\n\nvoid  **SetCollisionMesh**\\(const  *TRIMESH*  & mesh)\n    \n    sets a new collision mesh and notifies every registered callback about it\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES GetCollisionMesh"] = "\n\nconst  *TRIMESH*  &  **GetCollisionMesh**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES SetDraw"] = "\n\nvoid  **SetDraw**\\(bool bDraw)\n    \n    sets a drawing and notifies every registered callback about it\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES SetTransparency"] = "\n\nvoid  **SetTransparency**\\(float f)\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES IsDraw"] = "\n\nbool  **IsDraw**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES IsModifiable"] = "\n\nbool  **IsModifiable**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES GetType"] = "\n\n*GeomType*  **GetType**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES GetTransform"] = "\n\nconst  *Transform*  &  **GetTransform**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES GetSphereRadius"] = "\n\n*dReal*  **GetSphereRadius**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES GetCylinderRadius"] = "\n\n*dReal*  **GetCylinderRadius**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES GetCylinderHeight"] = "\n\n*dReal*  **GetCylinderHeight**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES GetBoxExtents"] = "\n\nconst  *Vector*  &  **GetBoxExtents**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES GetRenderScale"] = "\n\nconst  *Vector*  &  **GetRenderScale**\\()\n    \n            ";
m["en function KinBody::Link::GEOMPROPERTIES GetRenderFilename"] = "\n\nconst std::string &  **GetRenderFilename**\\()\n    \n            ";
m["en function KinBody::Joint GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["en function KinBody::Joint GetMimicJointIndex"] = "\n\nint  **GetMimicJointIndex**\\()\n    \n            ";
m["en function KinBody::Joint GetMimicCoeffs"] = "\n\nconst std::vector<  *dReal*  > &  **GetMimicCoeffs**\\()\n    \n            ";
m["en function KinBody::Joint GetMaxVel"] = "\n\n*dReal*  **GetMaxVel**\\()\n    \n            ";
m["en function KinBody::Joint GetMaxAccel"] = "\n\n*dReal*  **GetMaxAccel**\\()\n    \n            ";
m["en function KinBody::Joint GetMaxTorque"] = "\n\n*dReal*  **GetMaxTorque**\\()\n    \n            ";
m["en function KinBody::Joint GetDOFIndex"] = "\n\nint  **GetDOFIndex**\\()\n    \n    Get the degree of freedom index in the body's DOF array, does not index in *KinBody::_vecjoints*! Ie, *KinBody::GetJointValues()*\\[*GetDOFIndex()*] == *GetValues()*         ";
m["en function KinBody::Joint GetJointIndex"] = "\n\nint  **GetJointIndex**\\()\n    \n    Get the joint index into *KinBody::_vecjoints*.\n    \n            ";
m["en function KinBody::Joint GetParent"] = "\n\n*KinBodyPtr*  **GetParent**\\()\n    \n            ";
m["en function KinBody::Joint GetFirstAttached"] = "\n\n*LinkPtr*  **GetFirstAttached**\\()\n    \n            ";
m["en function KinBody::Joint GetSecondAttached"] = "\n\n*LinkPtr*  **GetSecondAttached**\\()\n    \n            ";
m["en function KinBody::Joint IsStatic"] = "\n\nbool  **IsStatic**\\()\n    \n    return true if joint can be treated as a static binding (ie all limits are 0)\n    \n            ";
m["en function KinBody::Joint IsCircular"] = "\n\nbool  **IsCircular**\\()\n    \n    return true if joint has no limits\n    \n            ";
m["en function KinBody::Joint GetType"] = "\n\n*JointType*  **GetType**\\()\n    \n            ";
m["en function KinBody::Joint GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n            ";
m["en function KinBody::Joint GetValues"] = "\n\nvoid  **GetValues**\\(std::vector<  *dReal*  > & values, bool bAppend = false )\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it Gets the joint values with the correct offsets applied\n    \n    *Return*\n        degrees of freedom of the joint (even if pValues is NULL) \n        ";
m["en function KinBody::Joint GetVelocities"] = "\n\nvoid  **GetVelocities**\\(std::vector<  *dReal*  > & values, bool bAppend = false )\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it Gets the joint velocities\n    \n    *Return*\n        the degrees of freedom of the joint (even if pValues is NULL) \n        ";
m["en function KinBody::Joint GetAnchor"] = "\n\n*Vector*  **GetAnchor**\\()\n    \n    *Return*\n        the anchor of the joint in global coordinates \n        ";
m["en function KinBody::Joint GetAxis"] = "\n\n*Vector*  **GetAxis**\\(int axis = 0 )\n    \n    *Parameters*\n     ``axis`` - \n      the axis to get\n    \n    *Return*\n        the axis of the joint in global coordinates \n        ";
m["en function KinBody::Joint GetInternalHierarchyAnchor"] = "\n\n*Vector*  **GetInternalHierarchyAnchor**\\()\n    \n    *Return*\n        the anchor of the joint in local coordinates \n        ";
m["en function KinBody::Joint GetInternalHierarchyAxis"] = "\n\n*Vector*  **GetInternalHierarchyAxis**\\(int iaxis = 0 )\n    \n    *Return*\n        the axis of the joint in local coordinates \n        ";
m["en function KinBody::Joint GetInternalHierarchyLeftTransform"] = "\n\n*Transform*  **GetInternalHierarchyLeftTransform**\\()\n    \n    left multiply transform given the base body\n    \n            ";
m["en function KinBody::Joint GetInternalHierarchyRightTransform"] = "\n\n*Transform*  **GetInternalHierarchyRightTransform**\\()\n    \n    right multiply transform given the base body\n    \n            ";
m["en function KinBody::Joint GetLimits"] = "\n\nvoid  **GetLimits**\\(std::vector<  *dReal*  > & vLowerLimit, std::vector<  *dReal*  > & vUpperLimit, bool bAppend = false )\n    \n    *Parameters*\n     ``vLowerLimit`` - \n      the lower limits \n     ``vUpperLimit`` - \n      the upper limits \n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it Returns the limits of the joint\n    \n    *Return*\n        degrees of freedom of the joint \n        ";
m["en function KinBody::Joint GetWeight"] = "\n\n*dReal*  **GetWeight**\\(int iaxis = 0 )\n    \n    *Return*\n        the weight associated with a joint's axis for computing a distance in the robot configuration space. \n        ";
m["en function KinBody::Joint SetJointOffset"] = "\n\nvoid  **SetJointOffset**\\(*dReal* offset)\n    \n            ";
m["en function KinBody::Joint SetJointLimits"] = "\n\nvoid  **SetJointLimits**\\(const std::vector<  *dReal*  > & lower, const std::vector<  *dReal*  > & upper)\n    \n            ";
m["en function KinBody::Joint SetResolution"] = "\n\nvoid  **SetResolution**\\(*dReal* resolution)\n    \n            ";
m["en function KinBody::Joint SetWeights"] = "\n\nvoid  **SetWeights**\\(const std::vector<  *dReal*  > & weights)\n    \n            ";
m["en function KinBody::Joint AddTorque"] = "\n\nvoid  **AddTorque**\\(const std::vector<  *dReal*  > & torques)\n    \n    add torque\n    \n            ";
m["en function KinBody::ManageData GetSystem"] = "\n\n*SensorSystemBasePtr*  **GetSystem**\\()\n    \n            ";
m["en function KinBody::ManageData GetData"] = "\n\n*XMLReadableConstPtr*  **GetData**\\()\n    \n    returns a pointer to the data used to initialize the BODY with AddKinBody. if psize is not NULL, will be filled with the size of the data in bytes This function will be used to restore bodies that were removed         ";
m["en function KinBody::ManageData GetOffsetLink"] = "\n\n*KinBody::LinkPtr*  **GetOffsetLink**\\()\n    \n    particular link that sensor system is tracking. All transformations describe this link.         ";
m["en function KinBody::ManageData IsPresent"] = "\n\nbool  **IsPresent**\\()\n    \n    true if the object is being updated by the system due to its presence in the real environment\n    \n            ";
m["en function KinBody::ManageData IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    true if should update openrave body\n    \n            ";
m["en function KinBody::ManageData IsLocked"] = "\n\nbool  **IsLocked**\\()\n    \n    if true, the vision system should not destroy this object once it stops being present\n    \n            ";
m["en function KinBody::ManageData Lock"] = "\n\nbool  **Lock**\\(bool bDoLock)\n    \n    set a lock on a particular body\n    \n            ";
m["en function IkParameterization SetTransform"] = "\n\nvoid  **SetTransform**\\(const  *Transform*  & t)\n    \n            ";
m["en function IkParameterization SetRotation"] = "\n\nvoid  **SetRotation**\\(const  *Vector*  & quaternion)\n    \n            ";
m["en function IkParameterization SetTranslation"] = "\n\nvoid  **SetTranslation**\\(const  *Vector*  & trans)\n    \n            ";
m["en function IkParameterization SetDirection"] = "\n\nvoid  **SetDirection**\\(const  *Vector*  & dir)\n    \n            ";
m["en function IkParameterization SetRay"] = "\n\nvoid  **SetRay**\\(const  *RAY*  & ray)\n    \n            ";
m["en function IkParameterization GetType"] = "\n\n*Type*  **GetType**\\()\n    \n            ";
m["en function IkParameterization GetTransform"] = "\n\nconst  *Transform*  &  **GetTransform**\\()\n    \n            ";
m["en function IkParameterization GetRotation"] = "\n\nconst  *Vector*  &  **GetRotation**\\()\n    \n            ";
m["en function IkParameterization GetTranslation"] = "\n\nconst  *Vector*  &  **GetTranslation**\\()\n    \n            ";
m["en function IkParameterization GetDirection"] = "\n\nconst  *Vector*  &  **GetDirection**\\()\n    \n            ";
m["en function IkParameterization GetRay"] = "\n\nconst  *RAY*  **GetRay**\\()\n    \n            ";
m["en function RobotBase GetManipulators"] = "\n\nstd::vector<  *ManipulatorPtr*  > &  **GetManipulators**\\()\n    \n    Returns the manipulators of the robot.\n    \n            ";
m["en function RobotBase GetManipulators"] = "\n\nstd::vector<  *ManipulatorPtr*  > &  **GetManipulators**\\()\n    \n    Returns the manipulators of the robot.\n    \n            ";
m["en function RobotBase SetActiveManipulator \"int\""] = "\n\nvoid  **SetActiveManipulator**\\(int index)\n    \n    *Parameters*\n     ``index`` - \n      manipulator index sets the active manipulator of the robot \n            ";
m["en function RobotBase SetActiveManipulator \"const std::string\""] = "\n\nvoid  **SetActiveManipulator**\\(const std::string & manipname)\n    \n    *Parameters*\n     ``manipname`` - \n      manipulator name sets the active manipulator of the robot \n            ";
m["en function RobotBase GetActiveManipulator"] = "\n\n*ManipulatorPtr*  **GetActiveManipulator**\\()\n    \n            ";
m["en function RobotBase GetActiveManipulatorIndex"] = "\n\nint  **GetActiveManipulatorIndex**\\()\n    \n    *Return*\n        index of the current active manipulator \n        ";
m["en function RobotBase GetAttachedSensors"] = "\n\nstd::vector<  *AttachedSensorPtr*  > &  **GetAttachedSensors**\\()\n    \n            ";
m["en function RobotBase GetController"] = "\n\n*ControllerBasePtr*  **GetController**\\()\n    \n            ";
m["en function RobotBase SetController"] = "\n\nbool  **SetController**\\(*ControllerBasePtr* controller, const std::string & args)\n    \n    *Parameters*\n     ``pController`` - \n      - if NULL, sets the controller of this robot to NULL. otherwise attemps to set the controller to this robot. \n     ``args`` - \n      - the argument list to pass when initializing the controller set a controller for a robot and destroy the old \n            ";
m["en function RobotBase SetActiveDOFs \"const std::vector; int\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine = DOF_NoTransform )\n    \n    *Parameters*\n     ``dofindices`` - \n      the indices of the original degrees of freedom to use. \n     ``affine`` - \n      A bitmask of *DOFAffine* values Set the joint indices and affine transformation dofs that the planner should use. If *DOF_RotationAxis* is specified, the previously set axis is used. \n            ";
m["en function RobotBase SetActiveDOFs \"const std::vector; int\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine = DOF_NoTransform )\n    \n    *Parameters*\n     ``dofindices`` - \n      the indices of the original degrees of freedom to use. \n     ``affine`` - \n      A bitmask of *DOFAffine* values Set the joint indices and affine transformation dofs that the planner should use. If *DOF_RotationAxis* is specified, the previously set axis is used. \n            ";
m["en function RobotBase SetActiveDOFs \"const std::vector; int; const Vector\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine, const  *Vector*  & rotationaxis)\n    \n    *Parameters*\n     ``vDOFIndices`` - \n      the indices of the original degrees of freedom to use. \n     ``nAffineDOFsBitmask`` - \n      A bitmask of *DOFAffine* values \n     ``pRotationAxis`` - \n      if *DOF_RotationAxis* is specified, pRotationAxis is used as the new axis \n            ";
m["en function RobotBase GetActiveDOF"] = "\n\nint  **GetActiveDOF**\\()\n    \n            ";
m["en function RobotBase GetAffineDOF"] = "\n\nint  **GetAffineDOF**\\()\n    \n            ";
m["en function RobotBase GetAffineDOFIndex"] = "\n\nint  **GetAffineDOFIndex**\\(*DOFAffine* dof)\n    \n    if dof is set in the affine dofs, returns its index in the dof values array, otherwise returns -1\n    \n            ";
m["en function RobotBase GetAffineRotationAxis"] = "\n\n*Vector*  **GetAffineRotationAxis**\\()\n    \n            ";
m["en function RobotBase SetAffineTranslationLimits"] = "\n\nvoid  **SetAffineTranslationLimits**\\(const  *Vector*  & lower, const  *Vector*  & upper)\n    \n            ";
m["en function RobotBase SetAffineRotationAxisLimits"] = "\n\nvoid  **SetAffineRotationAxisLimits**\\(const  *Vector*  & lower, const  *Vector*  & upper)\n    \n            ";
m["en function RobotBase SetAffineRotation3DLimits"] = "\n\nvoid  **SetAffineRotation3DLimits**\\(const  *Vector*  & lower, const  *Vector*  & upper)\n    \n            ";
m["en function RobotBase SetAffineRotationQuatLimits"] = "\n\nvoid  **SetAffineRotationQuatLimits**\\(const  *Vector*  & lower, const  *Vector*  & upper)\n    \n            ";
m["en function RobotBase SetAffineTranslationMaxVels"] = "\n\nvoid  **SetAffineTranslationMaxVels**\\(const  *Vector*  & vels)\n    \n            ";
m["en function RobotBase SetAffineRotationAxisMaxVels"] = "\n\nvoid  **SetAffineRotationAxisMaxVels**\\(const  *Vector*  & vels)\n    \n            ";
m["en function RobotBase SetAffineRotation3DMaxVels"] = "\n\nvoid  **SetAffineRotation3DMaxVels**\\(const  *Vector*  & vels)\n    \n            ";
m["en function RobotBase SetAffineRotationQuatMaxVels"] = "\n\nvoid  **SetAffineRotationQuatMaxVels**\\(const  *Vector*  & vels)\n    \n            ";
m["en function RobotBase SetAffineTranslationResolution"] = "\n\nvoid  **SetAffineTranslationResolution**\\(const  *Vector*  & resolution)\n    \n            ";
m["en function RobotBase SetAffineRotationAxisResolution"] = "\n\nvoid  **SetAffineRotationAxisResolution**\\(const  *Vector*  & resolution)\n    \n            ";
m["en function RobotBase SetAffineRotation3DResolution"] = "\n\nvoid  **SetAffineRotation3DResolution**\\(const  *Vector*  & resolution)\n    \n            ";
m["en function RobotBase SetAffineRotationQuatResolution"] = "\n\nvoid  **SetAffineRotationQuatResolution**\\(const  *Vector*  & resolution)\n    \n            ";
m["en function RobotBase SetAffineTranslationWeights"] = "\n\nvoid  **SetAffineTranslationWeights**\\(const  *Vector*  & weights)\n    \n            ";
m["en function RobotBase SetAffineRotationAxisWeights"] = "\n\nvoid  **SetAffineRotationAxisWeights**\\(const  *Vector*  & weights)\n    \n            ";
m["en function RobotBase SetAffineRotation3DWeights"] = "\n\nvoid  **SetAffineRotation3DWeights**\\(const  *Vector*  & weights)\n    \n            ";
m["en function RobotBase SetAffineRotationQuatWeights"] = "\n\nvoid  **SetAffineRotationQuatWeights**\\(const  *Vector*  & weights)\n    \n            ";
m["en function RobotBase GetAffineTranslationLimits"] = "\n\nvoid  **GetAffineTranslationLimits**\\(*Vector*  & lower, *Vector*  & upper)\n    \n            ";
m["en function RobotBase GetAffineRotationAxisLimits"] = "\n\nvoid  **GetAffineRotationAxisLimits**\\(*Vector*  & lower, *Vector*  & upper)\n    \n            ";
m["en function RobotBase GetAffineRotation3DLimits"] = "\n\nvoid  **GetAffineRotation3DLimits**\\(*Vector*  & lower, *Vector*  & upper)\n    \n            ";
m["en function RobotBase GetAffineRotationQuatLimits"] = "\n\nvoid  **GetAffineRotationQuatLimits**\\(*Vector*  & lower, *Vector*  & upper)\n    \n            ";
m["en function RobotBase GetAffineTranslationMaxVels"] = "\n\n*Vector*  **GetAffineTranslationMaxVels**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationAxisMaxVels"] = "\n\n*Vector*  **GetAffineRotationAxisMaxVels**\\()\n    \n            ";
m["en function RobotBase GetAffineRotation3DMaxVels"] = "\n\n*Vector*  **GetAffineRotation3DMaxVels**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationQuatMaxVels"] = "\n\n*Vector*  **GetAffineRotationQuatMaxVels**\\()\n    \n            ";
m["en function RobotBase GetAffineTranslationResolution"] = "\n\n*Vector*  **GetAffineTranslationResolution**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationAxisResolution"] = "\n\n*Vector*  **GetAffineRotationAxisResolution**\\()\n    \n            ";
m["en function RobotBase GetAffineRotation3DResolution"] = "\n\n*Vector*  **GetAffineRotation3DResolution**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationQuatResolution"] = "\n\n*Vector*  **GetAffineRotationQuatResolution**\\()\n    \n            ";
m["en function RobotBase GetAffineTranslationWeights"] = "\n\n*Vector*  **GetAffineTranslationWeights**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationAxisWeights"] = "\n\n*Vector*  **GetAffineRotationAxisWeights**\\()\n    \n            ";
m["en function RobotBase GetAffineRotation3DWeights"] = "\n\n*Vector*  **GetAffineRotation3DWeights**\\()\n    \n            ";
m["en function RobotBase GetAffineRotationQuatWeights"] = "\n\n*Vector*  **GetAffineRotationQuatWeights**\\()\n    \n            ";
m["en function RobotBase SetActiveDOFValues"] = "\n\nvoid  **SetActiveDOFValues**\\(const std::vector<  *dReal*  > & values, bool bCheckLimits = false )\n    \n            ";
m["en function RobotBase GetActiveDOFValues"] = "\n\nvoid  **GetActiveDOFValues**\\(std::vector<  *dReal*  > & v)\n    \n            ";
m["en function RobotBase SetActiveDOFVelocities"] = "\n\nvoid  **SetActiveDOFVelocities**\\(const std::vector<  *dReal*  > & velocities)\n    \n            ";
m["en function RobotBase GetActiveDOFVelocities"] = "\n\nvoid  **GetActiveDOFVelocities**\\(std::vector<  *dReal*  > & velocities)\n    \n            ";
m["en function RobotBase GetActiveDOFLimits"] = "\n\nvoid  **GetActiveDOFLimits**\\(std::vector<  *dReal*  > & lower, std::vector<  *dReal*  > & upper)\n    \n            ";
m["en function RobotBase GetActiveDOFIndices"] = "\n\nconst std::vector< int > &  **GetActiveDOFIndices**\\()\n    \n    Return the set of active dof indices of the joints.\n    \n            ";
m["en function RobotBase CalculateActiveJacobian \"int; const Vector; boost::multi_array\""] = "\n\nvoid  **CalculateActiveJacobian**\\(int index, const  *Vector*  & offset, boost::multi_array<  *dReal* , 2 > & vjacobian)\n    \n    gets the jacobian with respect to a link, pfArray is a 3 x ActiveDOF matrix (rotations are not taken into account) Calculates the partial differentials for the active degrees of freedom that in the path from the root node to _veclinks[index] (doesn't touch the rest of the values)         ";
m["en function RobotBase CalculateActiveRotationJacobian \"int; const Vector; boost::multi_array\""] = "\n\nvoid  **CalculateActiveRotationJacobian**\\(int index, const  *Vector*  & qInitialRot, boost::multi_array<  *dReal* , 2 > & vjacobian)\n    \n            ";
m["en function RobotBase CalculateActiveAngularVelocityJacobian \"int; boost::multi_array\""] = "\n\nvoid  **CalculateActiveAngularVelocityJacobian**\\(int index, boost::multi_array<  *dReal* , 2 > & vjacobian)\n    \n    *Parameters*\n     ``index`` - \n      of the link that the rotation is attached to \n     ``vjacobian`` - \n      3x(num ACTIVE DOF) matrix calculates the angular velocity jacobian of a specified link about the axes of world coordinates \n            ";
m["en function RobotBase Grab \"KinBodyPtr\""] = "\n\nbool  **Grab**\\(*KinBodyPtr* body)\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed Grabs the body with the active manipulator's end effector.\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["en function RobotBase Grab \"KinBodyPtr; const std::set\""] = "\n\nbool  **Grab**\\(*KinBodyPtr* body, const std::set< int > & setRobotLinksToIgnore)\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``setRobotLinksToIgnore`` - \n      Additional robot link indices that collision checker ignore when checking collisions between the grabbed body and the robot. Grabs the body with the active manipulator's end effector.\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["en function RobotBase Grab \"KinBodyPtr; LinkPtr\""] = "\n\nbool  **Grab**\\(*KinBodyPtr* body, *LinkPtr* pRobotLinkToGrabWith)\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``pRobotLinkToGrabWith`` - \n      the link of this robot that will perform the grab Grab a body with the specified link.\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["en function RobotBase Grab \"KinBodyPtr; LinkPtr; const std::set\""] = "\n\nbool  **Grab**\\(*KinBodyPtr* body, *LinkPtr* pRobotLinkToGrabWith, const std::set< int > & setRobotLinksToIgnore)\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``pRobotLinkToGrabWith`` - \n      the link of this robot that will perform the grab \n     ``setRobotLinksToIgnore`` - \n      Additional robot link indices that collision checker ignore when checking collisions between the grabbed body and the robot. Grab the body with the specified link.\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["en function RobotBase Release"] = "\n\nvoid  **Release**\\(*KinBodyPtr* body)\n    \n    *Parameters*\n     ``body`` - \n      body to release Release the body if grabbed. \n            ";
m["en function RobotBase ReleaseAllGrabbed"] = "\n\nvoid  **ReleaseAllGrabbed**\\()\n    \n    Release all grabbed bodies.\n    \n    release all bodies         ";
m["en function RobotBase RegrabAll"] = "\n\nvoid  **RegrabAll**\\()\n    \n    Releases and grabs all bodies, has the effect of recalculating all the initial collision with the bodies. In other words, the current collisions any grabbed body makes with the robot will be re-inserted into an ignore list         ";
m["en function RobotBase IsGrabbing"] = "\n\n*LinkPtr*  **IsGrabbing**\\(*KinBodyConstPtr* body)\n    \n    *Parameters*\n     ``body`` - \n      the body to check\n    \n    *Return*\n        the robot link that is currently grabbing the body. If the body is not grabbed, will return an empty pointer. \n        ";
m["en function RobotBase GetGrabbed"] = "\n\nvoid  **GetGrabbed**\\(std::vector<  *KinBodyPtr*  > & vbodies)\n    \n    *Parameters*\n     ``vbodies`` - \n      filled with the grabbed bodies gets all grabbed bodies of the robot \n            ";
m["en function RobotBase GetRobotStructureHash"] = "\n\nconst std::string &  **GetRobotStructureHash**\\()\n    \n    A md5 hash unique to the particular robot structure that involves manipulation and sensing components The serialization for the attached sensors will not involve any sensor specific properties (since they can change through calibration)         ";
m["en function RobotBase::Manipulator GetEndEffectorTransform"] = "\n\n*Transform*  **GetEndEffectorTransform**\\()\n    \n    Return the transformation of the end effector (manipulator frame).\n    \n    All inverse kinematics and grasping queries are specifying this frame.         ";
m["en function RobotBase::Manipulator GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["en function RobotBase::Manipulator GetRobot"] = "\n\n*RobotBasePtr*  **GetRobot**\\()\n    \n            ";
m["en function RobotBase::Manipulator SetIkSolver"] = "\n\nbool  **SetIkSolver**\\(*IkSolverBasePtr* iksolver)\n    \n    Sets the ik solver and initializes it with the current manipulator.\n    \n            ";
m["en function RobotBase::Manipulator GetIkSolver"] = "\n\n*IkSolverBasePtr*  **GetIkSolver**\\()\n    \n    Returns the currently set ik solver.\n    \n            ";
m["en function RobotBase::Manipulator SetIkSolver"] = "\n\nbool  **SetIkSolver**\\(*IkSolverBasePtr* iksolver)\n    \n    Sets the ik solver and initializes it with the current manipulator.\n    \n            ";
m["en function RobotBase::Manipulator InitIKSolver"] = "\n\nbool  **InitIKSolver**\\()\n    \n            ";
m["en function RobotBase::Manipulator GetIKSolverName"] = "\n\nconst std::string &  **GetIKSolverName**\\()\n    \n            ";
m["en function RobotBase::Manipulator HasIKSolver"] = "\n\nbool  **HasIKSolver**\\()\n    \n            ";
m["en function RobotBase::Manipulator GetNumFreeParameters"] = "\n\nint  **GetNumFreeParameters**\\()\n    \n    *Return*\n        Number of free parameters defining the null solution space. Each parameter is always in the range of [0,1]. \n        ";
m["en function RobotBase::Manipulator GetFreeParameters"] = "\n\nbool  **GetFreeParameters**\\(std::vector<  *dReal*  > & vFreeParameters)\n    \n    *Parameters*\n     ``vFreeParameters`` - \n      is filled with *GetNumFreeParameters()* parameters in [0,1] range gets the free parameters from the current robot configuration\n    \n    *Return*\n        true if succeeded \n        ";
m["en function RobotBase::Manipulator FindIKSolution \"const IkParameterization; std::vector; int\""] = "\n\nbool  **FindIKSolution**\\(const  *IkParameterization*  & goal, std::vector<  *dReal*  > & solution, int filteroptions)\n    \n    *Parameters*\n     ``goal`` - \n      The transformation of the end-effector in the global coord system \n     ``solution`` - \n      Will be of size *GetArmIndices()*.size() and contain the best solution \n     ``filteroptions`` - \n      A bitmask of *IkFilterOptions* values controlling what is checked for each ik solution. will find a close solution to the current robot's joint values. The function is a wrapper around the IkSolver interface. Note that the solution returned is not guaranteed to be the closest solution. In order to compute that, will have to compute all the ik solutions using FindIKSolutions. \n            ";
m["en function RobotBase::Manipulator FindIKSolution \"const IkParameterization; const std::vector; std::vector; int\""] = "\n\nbool  **FindIKSolution**\\(const  *IkParameterization*  & goal, const std::vector<  *dReal*  > & vFreeParameters, std::vector<  *dReal*  > & solution, int filteroptions)\n    \n            ";
m["en function RobotBase::Manipulator FindIKSolutions \"const IkParameterization; std::vector; int\""] = "\n\nbool  **FindIKSolutions**\\(const  *IkParameterization*  & goal, std::vector< std::vector<  *dReal*  > > & solutions, int filteroptions)\n    \n    *Parameters*\n     ``goal`` - \n      The transformation of the end-effector in the global coord system \n     ``solutions`` - \n      An array of all solutions, each element in solutions is of size *GetArmIndices()*.size() \n     ``filteroptions`` - \n      A bitmask of *IkFilterOptions* values controlling what is checked for each ik solution. will find all the IK solutions for the given end effector transform \n            ";
m["en function RobotBase::Manipulator FindIKSolutions \"const IkParameterization; const std::vector; std::vector; int\""] = "\n\nbool  **FindIKSolutions**\\(const  *IkParameterization*  & goal, const std::vector<  *dReal*  > & vFreeParameters, std::vector< std::vector<  *dReal*  > > & solutions, int filteroptions)\n    \n            ";
m["en function RobotBase::Manipulator GetBase"] = "\n\n*LinkPtr*  **GetBase**\\()\n    \n    the base used for the iksolver\n    \n            ";
m["en function RobotBase::Manipulator GetEndEffector"] = "\n\n*LinkPtr*  **GetEndEffector**\\()\n    \n    the end effector link (used to define workspace distance)\n    \n            ";
m["en function RobotBase::Manipulator GetGraspTransform"] = "\n\n*Transform*  **GetGraspTransform**\\()\n    \n    *Return*\n        transform with respect to end effector defining the grasp coordinate system \n        ";
m["en function RobotBase::Manipulator GetGripperIndices"] = "\n\nconst std::vector< int > &  **GetGripperIndices**\\()\n    \n    Gripper indices of the joints that the manipulator controls.\n    \n            ";
m["en function RobotBase::Manipulator GetGripperIndices"] = "\n\nconst std::vector< int > &  **GetGripperIndices**\\()\n    \n    Gripper indices of the joints that the manipulator controls.\n    \n            ";
m["en function RobotBase::Manipulator GetArmIndices"] = "\n\nconst std::vector< int > &  **GetArmIndices**\\()\n    \n    Return the indices of the DOFs of the arm (used for IK, etc).\n    \n    Usually the DOF indices from pBase to pEndEffector         ";
m["en function RobotBase::Manipulator GetArmIndices"] = "\n\nconst std::vector< int > &  **GetArmIndices**\\()\n    \n    Return the indices of the DOFs of the arm (used for IK, etc).\n    \n    Usually the DOF indices from pBase to pEndEffector         ";
m["en function RobotBase::Manipulator GetClosingDirection"] = "\n\nconst std::vector<  *dReal*  > &  **GetClosingDirection**\\()\n    \n    normal direction to move joints to 'close' the hand\n    \n            ";
m["en function RobotBase::Manipulator GetDirection"] = "\n\n*Vector*  **GetDirection**\\()\n    \n    direction of palm/head/manipulator used for approaching inside the grasp coordinate system\n    \n            ";
m["en function RobotBase::Manipulator GetDirection"] = "\n\n*Vector*  **GetDirection**\\()\n    \n    direction of palm/head/manipulator used for approaching inside the grasp coordinate system\n    \n            ";
m["en function RobotBase::Manipulator IsGrabbing"] = "\n\nbool  **IsGrabbing**\\(*KinBodyConstPtr* body)\n    \n    *Return*\n        true if the body is being grabbed by any link on this manipulator \n        ";
m["en function RobotBase::Manipulator GetChildJoints"] = "\n\nvoid  **GetChildJoints**\\(std::vector<  *JointPtr*  > & vjoints)\n    \n    get all child joints of the manipulator starting at the pEndEffector link\n    \n            ";
m["en function RobotBase::Manipulator GetChildDOFIndices"] = "\n\nvoid  **GetChildDOFIndices**\\(std::vector< int > & vdofndices)\n    \n    get all child DOF indices of the manipulator starting at the pEndEffector link\n    \n            ";
m["en function RobotBase::Manipulator GetChildLinks"] = "\n\nvoid  **GetChildLinks**\\(std::vector<  *LinkPtr*  > & vlinks)\n    \n    get all child links of the manipulator starting at pEndEffector link\n    \n            ";
m["en function RobotBase::Manipulator GetIndependentLinks"] = "\n\nvoid  **GetIndependentLinks**\\(std::vector<  *LinkPtr*  > & vlinks)\n    \n    Get all links that are independent of the arm and gripper joints conditioned that the base and end effector links are static. In other words, returns all links not on the path from the base to the end effector and not children of the end effector.         ";
m["en function RobotBase::Manipulator CheckEndEffectorCollision"] = "\n\nbool  **CheckEndEffectorCollision**\\(const  *Transform*  & tEE, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *Parameters*\n     ``tEE`` - \n      the end effector transform \n     ``report`` - \n      [optional] collision report checks collision with only the gripper given its end-effector transform\n    \n    *Return*\n        true if a collision occurred \n        ";
m["en function RobotBase::Manipulator CheckEndEffectorCollision"] = "\n\nbool  **CheckEndEffectorCollision**\\(const  *Transform*  & tEE, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *Parameters*\n     ``tEE`` - \n      the end effector transform \n     ``report`` - \n      [optional] collision report checks collision with only the gripper given its end-effector transform\n    \n    *Return*\n        true if a collision occurred \n        ";
m["en function RobotBase::Manipulator CheckIndependentCollision"] = "\n\nbool  **CheckIndependentCollision**\\(*CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *Parameters*\n     ``report`` - \n      [optional] collision report checks collision with the environment with all the independent links of the robot\n    \n    *Return*\n        true if a collision occurred \n        ";
m["en function RobotBase::Manipulator CheckIndependentCollision"] = "\n\nbool  **CheckIndependentCollision**\\(*CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *Parameters*\n     ``report`` - \n      [optional] collision report checks collision with the environment with all the independent links of the robot\n    \n    *Return*\n        true if a collision occurred \n        ";
m["en function RobotBase::Manipulator GetStructureHash"] = "\n\nconst std::string &  **GetStructureHash**\\()\n    \n    Return hash of just the manipulator definition.\n    \n            ";
m["en function RobotBase::Manipulator GetKinematicsStructureHash"] = "\n\nconst std::string &  **GetKinematicsStructureHash**\\()\n    \n    Return hash of all kinematics information that involves solving the inverse kinematics equations.\n    \n    This includes joint axes, joint positions, and final grasp transform. Hash is used to cache the solvers.         ";
m["en function RobotBase::AttachedSensor GetSensor"] = "\n\n*SensorBasePtr*  **GetSensor**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetAttachingLink"] = "\n\n*LinkPtr*  **GetAttachingLink**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetRelativeTransform"] = "\n\n*Transform*  **GetRelativeTransform**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetTransform"] = "\n\n*Transform*  **GetTransform**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetRobot"] = "\n\n*RobotBasePtr*  **GetRobot**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["en function RobotBase::AttachedSensor GetData"] = "\n\n*SensorBase::SensorDataPtr*  **GetData**\\()\n    \n    retrieves the current data from the sensor\n    \n            ";
m["en function RobotBase::AttachedSensor SetRelativeTransform"] = "\n\nvoid  **SetRelativeTransform**\\(const  *Transform*  & t)\n    \n            ";
m["en function RobotBase::AttachedSensor GetStructureHash"] = "\n\nconst std::string &  **GetStructureHash**\\()\n    \n    *Return*\n        hash of the sensor definition \n        ";
m["en function PlannerBase InitPlan \"RobotBasePtr; PlannerParametersConstPtr\""] = "\n\nbool  **InitPlan**\\(*RobotBasePtr* probot, *PlannerParametersConstPtr* pparams)\n    \n    Setup scene, robot, and properties of the plan, and reset all internal structures.\n    \n    *Parameters*\n     ``probot`` - \n      The robot will be planning for. \n     ``pparams`` - \n      The parameters of the planner, any class derived from *PlannerParameters* can be passed. The planner should copy these parameters for future instead of storing the pointer. \n            ";
m["en function PlannerBase InitPlan \"RobotBasePtr; std::istream\""] = "\n\nbool  **InitPlan**\\(*RobotBasePtr* pbase, std::istream & isParameters)\n    \n    Setup scene, robot, and properties of the plan, and reset all structures with pparams.\n    \n    *Parameters*\n     ``pbase`` - \n      The robot will be planning for. \n     ``isParameters`` - \n      The serialized form of the parameters. By default, this exists to allow third parties to pass information to planners without excplicitly knowning the format/internal structures used \n            ";
m["en function PlannerBase PlanPath"] = "\n\nbool  **PlanPath**\\(*TrajectoryBasePtr* ptraj, boost::shared_ptr< std::ostream > pOutStream = boost::shared_ptr< std::ostream >() )\n    \n    Executes the main planner trying to solve for the goal condition.\n    \n    *Parameters*\n     ``ptraj`` - \n      The output trajectory the robot has to follow in order to successfully complete the plan. If this planner is a path optimizer, the trajectory can be used as an input for generating a smoother path. The trajectory is for the configuration degrees of freedom defined by the planner parameters. \n     ``pOutStream`` - \n      If specified, planner will output any other special data Fill ptraj with the trajectory of the planned path that the robot needs to execute\n    \n    *Return*\n        true if planner is successful \n        ";
m["en function PlannerBase GetParameters"] = "\n\n*PlannerParametersConstPtr*  **GetParameters**\\()\n    \n    *Return*\n        the internal parameters of the planner \n        ";
m["en function ControllerBase Init"] = "\n\nbool  **Init**\\(*RobotBasePtr* robot, const std::string & args)\n    \n    *Parameters*\n     ``robot`` - \n      the robot that uses the controller \n     ``args`` - \n      extra arguments that the controller takes. Initializes the controller\n    \n    *Return*\n        true on successful initialization \n        ";
m["en function ControllerBase Reset"] = "\n\nvoid  **Reset**\\(int options)\n    \n    *Parameters*\n     ``options`` - \n      - specific options that can be used to control what to reset Resets the current controller trajectories and any other state associated with the robot \n            ";
m["en function ControllerBase SetDesired"] = "\n\nbool  **SetDesired**\\(const std::vector<  *dReal*  > & values)\n    \n    *Parameters*\n     ``values`` - \n      - final configuration go to a specific position in configuration space\n    \n    *Return*\n        true if position operation successful \n        ";
m["en function ControllerBase SetPath"] = "\n\nbool  **SetPath**\\(*TrajectoryBaseConstPtr* ptraj)\n    \n    *Parameters*\n     ``ptraj`` - \n      - the trajectory follow a path in configuration space, adds to the queue of trajectories already in execution\n    \n    *Return*\n        true if trajectory operation successful \n        ";
m["en function ControllerBase SimulationStep \"dReal\""] = "\n\nbool  **SimulationStep**\\(*dReal* fTimeElapsed)\n    \n    *Parameters*\n     ``fTimeElapsed`` - \n      - time elapsed in simulation environment since last frame Simulate one step forward for controllers running in the simulation environment\n    \n    *Return*\n        true if the controller is done with the current commands it is given \n        ";
m["en function ControllerBase IsDone"] = "\n\nbool  **IsDone**\\()\n    \n    *Return*\n        true when goal reached. If a trajectory was set, return only when trajectory is done. If SetDesired was called, return only when robot is is at the desired location. If SendCommand sent, returns true when the command was completed by the hand. \n        ";
m["en function ControllerBase GetTime"] = "\n\n*dReal*  **GetTime**\\()\n    \n    *Return*\n        the time along the current command \n        ";
m["en function ControllerBase GetVelocity"] = "\n\nvoid  **GetVelocity**\\(std::vector<  *dReal*  > & vel)\n    \n    *Parameters*\n     ``vel`` - \n      [out] - current velocity of robot get velocity \n            ";
m["en function ControllerBase GetTorque"] = "\n\nvoid  **GetTorque**\\(std::vector<  *dReal*  > & torque)\n    \n    *Parameters*\n     ``torque`` - \n      [out] - returns the current torque/current/strain exerted by each of the joints from outside forces. The feedforward and friction terms should be subtracted out already get torque/current/strain values \n            ";
m["en function PhysicsEngineBase GetPhysicsOptions"] = "\n\nint  **GetPhysicsOptions**\\()\n    \n            ";
m["en function PhysicsEngineBase SetPhysicsOptions \"int\""] = "\n\nbool  **SetPhysicsOptions**\\(int physicsoptions)\n    \n    Set basic physics engine using the PhysicsEngineOptions enum.\n    \n            ";
m["en function PhysicsEngineBase InitEnvironment"] = "\n\nbool  **InitEnvironment**\\()\n    \n    called when environment sets this physics engine, engine assumes responsibility for *KinBody::_pPhysicsData*\n    \n            ";
m["en function PhysicsEngineBase DestroyEnvironment"] = "\n\nvoid  **DestroyEnvironment**\\()\n    \n    called when environment switches to a different physics engine has to clear/deallocate any memory associated with *KinBody::_pPhysicsData*         ";
m["en function PhysicsEngineBase InitKinBody"] = "\n\nbool  **InitKinBody**\\(*KinBodyPtr* body)\n    \n    notified when a new body has been initialized in the environment\n    \n            ";
m["en function PhysicsEngineBase SetBodyVelocity \"KinBodyPtr; const Vector; const Vector; const std::vector\""] = "\n\nbool  **SetBodyVelocity**\\(*KinBodyPtr* body, const  *Vector*  & linearvel, const  *Vector*  & angularvel, const std::vector<  *dReal*  > & pJointVelocity)\n    \n    *Parameters*\n     ``linearvel`` - \n      linear velocity of base link \n     ``angularvel`` - \n      angular velocity rotation_axis*theta_dot \n     ``pJointVelocity`` - \n      - the joint velocities of the robot Sets the body velocity.. \n            ";
m["en function PhysicsEngineBase SetBodyVelocity \"KinBodyPtr; const std::vector; const std::vector\""] = "\n\nbool  **SetBodyVelocity**\\(*KinBodyPtr* body, const std::vector<  *Vector*  > & pLinearVelocities, const std::vector<  *Vector*  > & pAngularVelocities)\n    \n    Sets the velocities for each link.\n    \n    *Parameters*\n     ``body`` - \n      the body to query velocities from. \n     ``pLinearVelocities`` - \n      the linear velocities for each link \n     ``pAngularVelocities`` - \n      the angular velocities for each link (axis * angular_speed) \n            ";
m["en function PhysicsEngineBase SetLinkVelocity"] = "\n\nbool  **SetLinkVelocity**\\(*KinBody::LinkPtr* link, const  *Vector*  & linearvel, const  *Vector*  & angularvel)\n    \n    Force the body velocity of a link.\n    \n    *Parameters*\n     ``link`` - \n      link to set velocities. \n     ``linearvel`` - \n      linear velocity of base link \n     ``angularvel`` - \n      angular velocity rotation_axis*theta_dot \n            ";
m["en function PhysicsEngineBase GetLinkVelocity"] = "\n\nbool  **GetLinkVelocity**\\(*KinBody::LinkConstPtr* link, *Vector*  & linearvel, *Vector*  & angularvel)\n    \n    *Parameters*\n     ``linearvel`` - \n      - linear velocity of base link \n     ``angularvel`` - \n      - angular velocity rotation_axis*theta_dot gets the velocity of a link \n            ";
m["en function PhysicsEngineBase SetJointVelocity"] = "\n\nbool  **SetJointVelocity**\\(*KinBody::JointPtr* pjoint, const std::vector<  *dReal*  > & vJointVelocity)\n    \n    *Parameters*\n     ``pjoint`` - \n      the joint \n     ``vJointVelocity`` - \n      the new joint velocity sets the joint velocity \n            ";
m["en function PhysicsEngineBase GetJointVelocity"] = "\n\nbool  **GetJointVelocity**\\(*KinBody::JointConstPtr* pjoint, std::vector<  *dReal*  > & vJointVelocity)\n    \n    *Parameters*\n     ``vJointVelocity`` - \n      the new joint velocity gets the joint velocity \n            ";
m["en function PhysicsEngineBase SetBodyForce"] = "\n\nbool  **SetBodyForce**\\(*KinBody::LinkPtr* link, const  *Vector*  & force, const  *Vector*  & position, bool bAdd)\n    \n    *Parameters*\n     ``force`` - \n      the direction and magnitude of the force \n     ``position`` - \n      in the world where the force is getting applied \n     ``bAdd`` - \n      if true, force is added to previous forces, otherwise it is set add a force at a particular position in a link \n            ";
m["en function PhysicsEngineBase SetBodyTorque"] = "\n\nbool  **SetBodyTorque**\\(*KinBody::LinkPtr* link, const  *Vector*  & torque, bool bAdd)\n    \n    *Parameters*\n     ``link`` - \n      the link to add a torque to \n     ``torque`` - \n      torque vector \n     ``bAdd`` - \n      if true, torque is added to previous torques, otherwise it is set adds torque to a body (absolute coords) \n            ";
m["en function PhysicsEngineBase AddJointTorque"] = "\n\nbool  **AddJointTorque**\\(*KinBody::JointPtr* pjoint, const std::vector<  *dReal*  > & pTorques)\n    \n    *Parameters*\n     ``pjoint`` - \n      - the joint the torque is added to \n     ``pTorques`` - \n      - the torques added to the joint. Pointer because the joint dof can be greater than 1. adds torque to a joint \n            ";
m["en function PhysicsEngineBase SetGravity"] = "\n\nvoid  **SetGravity**\\(const  *Vector*  & gravity)\n    \n    set the gravity direction\n    \n            ";
m["en function PhysicsEngineBase GetGravity"] = "\n\n*Vector*  **GetGravity**\\()\n    \n            ";
m["en function PhysicsEngineBase SimulateStep"] = "\n\nvoid  **SimulateStep**\\(*dReal* fTimeElapsed)\n    \n    dynamically simulate system for fTimeElapsed seconds add torques to the joints of the body. Torques disappear after one timestep of simulation         ";
m["en function SensorBase GetSensorData"] = "\n\nbool  **GetSensorData**\\(*SensorDataPtr* psensordata)\n    \n    *Parameters*\n     ``psensordata`` - \n      A pointer to *SensorData* returned from CreateSensorData Copy the most recent published data of the sensor. Once GetSensorData returns, the caller has full access to the data. This method is thread safe. \n            ";
m["en function SensorBase SetTransform"] = "\n\nvoid  **SetTransform**\\(const  *Transform*  & trans)\n    \n    *Parameters*\n     ``trans`` - \n      - The transform defining the frame of the sensor. Set the transform of a sensor. \n            ";
m["en function SensorBase GetTransform"] = "\n\n*Transform*  **GetTransform**\\()\n    \n            ";
m["en function SensorBase GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n    *Return*\n        the name of the sensor \n        ";
m["en function CollisionCheckerBase SetCollisionOptions \"int\""] = "\n\nbool  **SetCollisionOptions**\\(int collisionoptions)\n    \n    Set basic collision options using the CollisionOptions enum.\n    \n            ";
m["en function CollisionCheckerBase GetCollisionOptions"] = "\n\nint  **GetCollisionOptions**\\()\n    \n            ";
m["en function ViewerBase main"] = "\n\nint  **main**\\(bool bShow = true )\n    \n    *Parameters*\n     ``bShow`` - \n      if true will show the window goes into the main loop \n            ";
m["en function ViewerBase quitmainloop"] = "\n\nvoid  **quitmainloop**\\()\n    \n    destroys the main loop\n    \n            ";
m["en function ViewerBase ViewerSetSize"] = "\n\nvoid  **ViewerSetSize**\\(int w, int h)\n    \n            ";
m["en function ViewerBase ViewerMove"] = "\n\nvoid  **ViewerMove**\\(int x, int y)\n    \n            ";
m["en function ViewerBase ViewerSetTitle"] = "\n\nvoid  **ViewerSetTitle**\\(const std::string & ptitle)\n    \n            ";
m["en function ViewerBase LoadModel"] = "\n\nbool  **LoadModel**\\(const std::string & pfilename)\n    \n            ";
m["en function ViewerBase RegisterCallback"] = "\n\nboost::shared_ptr< void >  **RegisterCallback**\\(int properties, const  *ViewerCallbackFn*  & fncallback)\n    \n    registers a function with the viewer that gets called everytime a specified event occurs (part of ViewerEvents enum)\n    \n    *Return*\n        a handle to the callback. If this handle is deleted, the callback will be unregistered \n        ";
m["en function ViewerBase EnvironmentSync"] = "\n\nvoid  **EnvironmentSync**\\()\n    \n    forces synchronization with the environment, returns when the environment is fully synchronized. Note that this method might not work if environment is locked in current thread         ";
m["en function ViewerBase SetCamera"] = "\n\nvoid  **SetCamera**\\(const RaveTransform< float > & trans, float focalDistance = 0 )\n    \n    Set the camera transformation.\n    \n    *Parameters*\n     ``trans`` - \n      new camera transformation in the world coordinate system \n     ``focalDistance`` - \n      The new focal distance of the camera (higher values is higher zoom). If 0, then the previous focal distance is preserved. \n            ";
m["en function ViewerBase SetCamera"] = "\n\nvoid  **SetCamera**\\(const RaveTransform< float > & trans, float focalDistance = 0 )\n    \n    Set the camera transformation.\n    \n    *Parameters*\n     ``trans`` - \n      new camera transformation in the world coordinate system \n     ``focalDistance`` - \n      The new focal distance of the camera (higher values is higher zoom). If 0, then the previous focal distance is preserved. \n            ";
m["en function ViewerBase GetCameraTransform"] = "\n\nRaveTransform< float >  **GetCameraTransform**\\()\n    \n    Return the current camera transform that the viewer is rendering the environment at.\n    \n            ";
m["en function ViewerBase GetCameraImage"] = "\n\nbool  **GetCameraImage**\\(std::vector< uint8_t > & memory, int width, int height, const RaveTransform< float > & t, const  *SensorBase::CameraIntrinsics*  & KK)\n    \n    *Parameters*\n     ``memory`` - \n      the memory where the image will be stored at, has to store 3*width*height \n     ``width`` - \n      width of the image \n     ``height`` - \n      height of the image \n     ``t`` - \n      the rotation and translation of the camera. Note that z is treated as the front of the camera! So all points in front of the camera have a positive dot product with its direction. \n     ``KK`` - \n      4 values such that the intrinsic matrix can be reconstructed [pKK[0] 0 pKK[2]; 0 pKK[1] pKK[3]; 0 0 1]; Renders a 24bit RGB image of dimensions width and height from the current scene. The camera is meant to show the underlying *OpenRAVE* world as a robot would see it, so all graphs rendered with the plotX and drawX functions are hidden. \n            ";
m["en function EnvironmentBase Reset"] = "\n\nvoid  **Reset**\\()\n    \n    Resets all objects of the scene (preserves all problems, planners).\n    \n    Do not call inside a SimulationStep call         ";
m["en function EnvironmentBase Destroy"] = "\n\nvoid  **Destroy**\\()\n    \n    Releases all environment resources, should be always called when environment stops being used.\n    \n    Removing all environment pointer might not be enough to destroy the environment resources.         ";
m["en function EnvironmentBase GetPluginInfo"] = "\n\nvoid  **GetPluginInfo**\\(std::list< std::pair< std::string,  *PLUGININFO*  > > & plugins)\n    \n    Get all the loaded plugins and the interfaces they support.\n    \n    *Parameters*\n     ``plugins`` - \n      A list of plugins. Each entry has the plugin name and the interfaces it supports \n            ";
m["en function EnvironmentBase GetLoadedInterfaces"] = "\n\nvoid  **GetLoadedInterfaces**\\(std::map< InterfaceType, std::vector< std::string > > & interfacenames)\n    \n    Get a list of all the loaded interfaces.\n    \n            ";
m["en function EnvironmentBase LoadPlugin"] = "\n\nbool  **LoadPlugin**\\(const std::string & name)\n    \n    Load a plugin and its interfaces.\n    \n    *Parameters*\n     ``name`` - \n      the filename of the plugin to load If the plugin is already loaded, will reload it. \n            ";
m["en function EnvironmentBase ReloadPlugins"] = "\n\nvoid  **ReloadPlugins**\\()\n    \n    Reloads all currently loaded plugins.\n    \n    The interfaces currently created remain will continue using the old plugins, so this function is safe in that plugins currently loaded remain loaded until the last interface that uses them is released.         ";
m["en function EnvironmentBase ReloadPlugins"] = "\n\nvoid  **ReloadPlugins**\\()\n    \n    Reloads all currently loaded plugins.\n    \n    The interfaces currently created remain will continue using the old plugins, so this function is safe in that plugins currently loaded remain loaded until the last interface that uses them is released.         ";
m["en function EnvironmentBase CreateRobot"] = "\n\n*RobotBasePtr*  **CreateRobot**\\(const std::string & name = \"\" )\n    \n            ";
m["en function EnvironmentBase CreatePlanner"] = "\n\n*PlannerBasePtr*  **CreatePlanner**\\(const std::string & name)\n    \n            ";
m["en function EnvironmentBase CreateSensorSystem"] = "\n\n*SensorSystemBasePtr*  **CreateSensorSystem**\\(const std::string & name)\n    \n            ";
m["en function EnvironmentBase CreateController"] = "\n\n*ControllerBasePtr*  **CreateController**\\(const std::string & name)\n    \n            ";
m["en function EnvironmentBase CreateProblem"] = "\n\n*ProblemInstancePtr*  **CreateProblem**\\(const std::string & name)\n    \n            ";
m["en function EnvironmentBase CreateIkSolver"] = "\n\n*IkSolverBasePtr*  **CreateIkSolver**\\(const std::string & name)\n    \n            ";
m["en function EnvironmentBase CreateIkSolver"] = "\n\n*IkSolverBasePtr*  **CreateIkSolver**\\(const std::string & name)\n    \n            ";
m["en function EnvironmentBase CreateIkSolver"] = "\n\n*IkSolverBasePtr*  **CreateIkSolver**\\(const std::string & name)\n    \n            ";
m["en function EnvironmentBase CreateIkSolver"] = "\n\n*IkSolverBasePtr*  **CreateIkSolver**\\(const std::string & name)\n    \n            ";
m["en function EnvironmentBase CreateViewer"] = "\n\n*ViewerBasePtr*  **CreateViewer**\\(const std::string & name)\n    \n            ";
m["en function EnvironmentBase CloneSelf"] = "\n\n*EnvironmentBasePtr*  **CloneSelf**\\(int options)\n    \n    Create and return a clone of the current environment.\n    \n    *Parameters*\n     ``options`` - \n      A set of CloningOptions describing what is actually cloned. Clones do not share any memory or resource between each other. or their parent making them ideal for performing separte planning experiments while keeping the parent environment unchanged. By default a clone only copies the collision checkers and physics engine. When bodies are cloned, the unique ids are preserved across environments (each body can be referenced with its id in both environments). The attached and grabbed bodies of each body/robot are also copied to the new environment.\n    \n    *Return*\n        An environment of the same type as this environment containing the copied information. \n        ";
m["en function EnvironmentBase SetCollisionChecker"] = "\n\nbool  **SetCollisionChecker**\\(*CollisionCheckerBasePtr* pchecker)\n    \n    set the global environment collision checker\n    \n            ";
m["en function EnvironmentBase GetCollisionChecker"] = "\n\n*CollisionCheckerBasePtr*  **GetCollisionChecker**\\()\n    \n            ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBodyConstPtr* pbody1, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBodyConstPtr* pbody1, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBodyConstPtr* pbody1, *KinBodyConstPtr* pbody2, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBodyConstPtr* pbody1, *KinBodyConstPtr* pbody2, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBody::LinkConstPtr* plink, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBody::LinkConstPtr* plink, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBody::LinkConstPtr* plink1, *KinBody::LinkConstPtr* plink2, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBody::LinkConstPtr* plink1, *KinBody::LinkConstPtr* plink2, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBody::LinkConstPtr* plink, *KinBodyConstPtr* pbody, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBody::LinkConstPtr* plink, *KinBodyConstPtr* pbody, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBody::LinkConstPtr* plink, const std::vector<  *KinBodyConstPtr*  > & vbodyexcluded, const std::vector<  *KinBody::LinkConstPtr*  > & vlinkexcluded, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBody::LinkConstPtr* plink, const std::vector<  *KinBodyConstPtr*  > & vbodyexcluded, const std::vector<  *KinBody::LinkConstPtr*  > & vlinkexcluded, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBodyConstPtr* pbody, const std::vector<  *KinBodyConstPtr*  > & vbodyexcluded, const std::vector<  *KinBody::LinkConstPtr*  > & vlinkexcluded, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(*KinBodyConstPtr* pbody, const std::vector<  *KinBodyConstPtr*  > & vbodyexcluded, const std::vector<  *KinBody::LinkConstPtr*  > & vlinkexcluded, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  *RAY*  & ray, *KinBodyConstPtr* pbody, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  *RAY*  & ray, *KinBodyConstPtr* pbody, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  *RAY*  & ray, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  *RAY*  & ray, *CollisionReportPtr* report = *CollisionReportPtr* () )\n    \n    *See*\n        *CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr)* \n        ";
m["en function EnvironmentBase Load"] = "\n\nbool  **Load**\\(const std::string & filename)\n    \n    Loads a scene from an XML file, environment is locked automatically making this method thread-safe.\n    \n            ";
m["en function EnvironmentBase Save"] = "\n\nbool  **Save**\\(const std::string & filename)\n    \n    Saves a scene depending on the filename extension. Default is in COLLADA format.\n    \n            ";
m["en function EnvironmentBase ReadRobotXMLFile \"const std::string\""] = "\n\n*RobotBasePtr*  **ReadRobotXMLFile**\\(const std::string & filename)\n    \n            ";
m["en function EnvironmentBase ReadRobotXMLData \"RobotBasePtr; const std::string; const std::list\""] = "\n\n*RobotBasePtr*  **ReadRobotXMLData**\\(*RobotBasePtr* robot, const std::string & data, const std::list< std::pair< std::string, std::string > > & atts)\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      the XML attributes/value pairs Initialize a robot from an XML formatted string The robot should not be added the environment when calling this function. \n            ";
m["en function EnvironmentBase ReadKinBodyXMLFile \"const std::string\""] = "\n\n*KinBodyPtr*  **ReadKinBodyXMLFile**\\(const std::string & filename)\n    \n            ";
m["en function EnvironmentBase ReadKinBodyXMLData \"KinBodyPtr; const std::string; const std::list\""] = "\n\n*KinBodyPtr*  **ReadKinBodyXMLData**\\(*KinBodyPtr* body, const std::string & data, const std::list< std::pair< std::string, std::string > > & atts)\n    \n    Initializes a kinematic body from an XML formatted string.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      the XML attributes/value pairs \n            ";
m["en function EnvironmentBase ReadInterfaceXMLFile \"const std::string\""] = "\n\n*InterfaceBasePtr*  **ReadInterfaceXMLFile**\\(const std::string & filename)\n    \n            ";
m["en function EnvironmentBase AddKinBody"] = "\n\nbool  **AddKinBody**\\(*KinBodyPtr* body, bool bAnonymous = false )\n    \n    Add a body to the environment.\n    \n    *Parameters*\n     ``body`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body with the same name, will make body's name unique \n            ";
m["en function EnvironmentBase AddKinBody"] = "\n\nbool  **AddKinBody**\\(*KinBodyPtr* body, bool bAnonymous = false )\n    \n    Add a body to the environment.\n    \n    *Parameters*\n     ``body`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body with the same name, will make body's name unique \n            ";
m["en function EnvironmentBase AddRobot"] = "\n\nbool  **AddRobot**\\(*RobotBasePtr* robot, bool bAnonymous = false )\n    \n    *Parameters*\n     ``robot`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body with the same name, will make body's name unique add a body to the environment \n            ";
m["en function EnvironmentBase AddRobot"] = "\n\nbool  **AddRobot**\\(*RobotBasePtr* robot, bool bAnonymous = false )\n    \n    *Parameters*\n     ``robot`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body with the same name, will make body's name unique add a body to the environment \n            ";
m["en function EnvironmentBase RemoveKinBody"] = "\n\nbool  **RemoveKinBody**\\(*KinBodyPtr* body)\n    \n    Removes a body from the environment\n    \n    *Parameters*\n     ``body`` - \n      the body to remove \n            ";
m["en function EnvironmentBase GetKinBody"] = "\n\n*KinBodyPtr*  **GetKinBody**\\(const std::string & name)\n    \n    Query a body from its name.\n    \n    *Return*\n        first *KinBody* (including robots) that matches with name \n        ";
m["en function EnvironmentBase GetRobot"] = "\n\n*RobotBasePtr*  **GetRobot**\\(const std::string & name)\n    \n    Query a robot from its name.\n    \n    *Return*\n        first Robot that matches the name \n        ";
m["en function EnvironmentBase GetBodyFromEnvironmentId"] = "\n\n*KinBodyPtr*  **GetBodyFromEnvironmentId**\\(int id)\n    \n    Get the corresponding body from its unique network id.\n    \n            ";
m["en function EnvironmentBase CreateKinBody"] = "\n\n*KinBodyPtr*  **CreateKinBody**\\(const std::string & name = \"\" )\n    \n    Return an empty *KinBody* instance.\n    \n            ";
m["en function EnvironmentBase CreateTrajectory"] = "\n\n*TrajectoryBasePtr*  **CreateTrajectory**\\(int nDOF)\n    \n    Return an empty trajectory instance initialized to nDOF degrees of freedom.\n    \n            ";
m["en function EnvironmentBase LoadProblem"] = "\n\nint  **LoadProblem**\\(*ProblemInstancePtr* prob, const std::string & cmdargs)\n    \n    Load a new problem, need to Lock if calling outside simulation thread.\n    \n            ";
m["en function EnvironmentBase RemoveProblem"] = "\n\nbool  **RemoveProblem**\\(*ProblemInstancePtr* prob)\n    \n    Load a new problem, need to Lock if calling outside simulation thread.\n    \n            ";
m["en function EnvironmentBase GetLoadedProblems"] = "\n\nboost::shared_ptr< void >  **GetLoadedProblems**\\(std::list<  *ProblemInstancePtr*  > & listProblems)\n    \n    Returns a list of loaded problems with a lock. As long as the lock is held, the problems are guaranteed to stay loaded in the environment.\n    \n    *Return*\n        returns a pointer to a Lock. Destroying the shared_ptr will release the lock \n        ";
m["en function EnvironmentBase SetPhysicsEngine"] = "\n\nbool  **SetPhysicsEngine**\\(*PhysicsEngineBasePtr* pengine)\n    \n    *Parameters*\n     ``the`` - \n      engine to set, if NULL, environment sets an dummy physics engine set the physics engine, disabled by default \n            ";
m["en function EnvironmentBase GetPhysicsEngine"] = "\n\n*PhysicsEngineBasePtr*  **GetPhysicsEngine**\\()\n    \n            ";
m["en function EnvironmentBase RegisterCollisionCallback"] = "\n\nboost::shared_ptr< void >  **RegisterCollisionCallback**\\(const  *CollisionCallbackFn*  & callback)\n    \n    Register a collision callback.Whenever a collision is detected between between bodies during a CheckCollision call or physics simulation, the callback is called. The callback should return an action specifying how the collision should be handled:\n    \n    *Return*\n        a handle to the registration, once the handle loses scope, the callback is unregistered \n        ";
m["en function EnvironmentBase StepSimulation"] = "\n\nvoid  **StepSimulation**\\(*dReal* timeStep)\n    \n    Makes one simulation step.\n    \n            ";
m["en function EnvironmentBase StartSimulation"] = "\n\nvoid  **StartSimulation**\\(*dReal* fDeltaTime, bool bRealTime = true )\n    \n    *Parameters*\n     ``fDeltaTime`` - \n      the delta step to take in simulation \n     ``bRealTime`` - \n      if false will call SimulateStep as fast as possible, otherwise will time the simulate step calls so that simulation progresses with real system time. Start the internal simulation thread that calls the physics engine loop and SimulateStep for all modules. Resets simulation time to 0. \n            ";
m["en function EnvironmentBase StopSimulation"] = "\n\nvoid  **StopSimulation**\\()\n    \n    Stops the internal physics loop, stops calling SimulateStep for all modules.\n    \n            ";
m["en function EnvironmentBase GetSimulationTime"] = "\n\nuint64_t  **GetSimulationTime**\\()\n    \n    *Return*\n        simulation time since the start of the environment (in microseconds) \n        ";
m["en function EnvironmentBase GetViewer"] = "\n\n*ViewerBasePtr*  **GetViewer**\\()\n    \n            ";
m["en function EnvironmentBase drawlinestrip \"const float; int; int; float; const float\""] = "\n\n*GraphHandlePtr*  **drawlinestrip**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a series of connected lines with individual colors.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawlinelist \"const float; int; int; float; const float\""] = "\n\n*GraphHandlePtr*  **drawlinelist**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a list of individual lines, each specified by a succeeding pair of points.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawarrow"] = "\n\n*GraphHandlePtr*  **drawarrow**\\(const RaveVector< float > & p1, const RaveVector< float > & p2, float fwidth, const RaveVector< float > & color = RaveVector< float >(1, 0.5, 0.5, 1) )\n    \n    Draws an arrow p1 is start, p2 is finish.\n    \n    *Parameters*\n     ``color`` - \n      the rgb color of the point. The last component of the color is used for alpha blending.\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawbox"] = "\n\n*GraphHandlePtr*  **drawbox**\\(const RaveVector< float > & vpos, const RaveVector< float > & vextents)\n    \n    Draws a box.\n    \n    extents are half the width, height, and depth of the box\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawplane"] = "\n\n*GraphHandlePtr*  **drawplane**\\(const RaveTransform< float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawplane"] = "\n\n*GraphHandlePtr*  **drawplane**\\(const RaveTransform< float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase drawtrimesh \"const float; int; const int; int; const boost::multi_array\""] = "\n\n*GraphHandlePtr*  **drawtrimesh**\\(const float * ppoints, int stride, const int * pIndices, int numTriangles, const boost::multi_array< float, 2 > & colors)\n    \n    Draws a triangle mesh, each vertices of each triangle should be counter-clockwise.\n    \n    *Parameters*\n     ``ppoints`` - \n      - array of 3D points \n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride) \n     ``pIndices`` - \n      If not NULL, zero-based indices into the points for every triangle. pIndices should be of size numTriangles. If pIndices is NULL, ppoints is assumed to contain numTriangles*3 points and triangles will be rendered in list order. \n     ``color`` - \n      The color of the triangle. The last component of the color is used for alpha blending\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["en function EnvironmentBase GetRobots"] = "\n\nvoid  **GetRobots**\\(std::vector<  *RobotBasePtr*  > & robots)\n    \n    Fill an array with all robots loaded in the environment.\n    \n            ";
m["en function EnvironmentBase GetBodies"] = "\n\nvoid  **GetBodies**\\(std::vector<  *KinBodyPtr*  > & bodies)\n    \n    Get all bodies loaded in the environment (including robots).\n    \n    *Parameters*\n     ``bodies`` - \n      filled with all the bodies \n            ";
m["en function EnvironmentBase UpdatePublishedBodies"] = "\n\nvoid  **UpdatePublishedBodies**\\()\n    \n    updates the published bodies that viewers and other programs listening in on the environment see. For example, calling this function inside a planning loop allows the viewer to update the environment reflecting the status of the planner. Assumes that the physics are locked.         ";
m["en function EnvironmentBase Triangulate"] = "\n\nbool  **Triangulate**\\(*KinBody::Link::TRIMESH*  & trimesh, *KinBodyConstPtr* pbody)\n    \n    triangulation of the body including its current transformation. trimesh will be appended the new data.\n    \n            ";
m["en function EnvironmentBase TriangulateScene"] = "\n\nbool  **TriangulateScene**\\(*KinBody::Link::TRIMESH*  & trimesh, *TriangulateOptions* opts, const std::string & name)\n    \n    *Parameters*\n     ``opts`` - \n      - Controlls what to triangulate general triangulation of the whole scene. trimesh will be appended the new data. \n            ";
m["en function EnvironmentBase SetDebugLevel"] = "\n\nvoid  **SetDebugLevel**\\(*DebugLevel* level)\n    \n    *Parameters*\n     ``level`` - \n      0 for no debug, 1 - to print all debug messeges. Default value for release builds is 0, for debug builds it is 1 declaring variables with stdcall can be a little complex sets the debug level \n            ";
m["en function EnvironmentBase GetDebugLevel"] = "\n\n*DebugLevel*  **GetDebugLevel**\\()\n    \n            ";
m["en function EnvironmentBase GetHomeDirectory"] = "\n\nconst std::string &  **GetHomeDirectory**\\()\n    \n    Returns the openrave home directory where settings, cache, and other files are stored.\n    \n    On Linux/Unix systems, this is usually $HOME/.openrave, on Windows this is $HOMEPATH/.openrave         ";
m["en function quatFromAxisAngle \"const RaveVector\""] = "\n\n*RaveVector* < T >  **quatFromAxisAngle**\\(const  *RaveVector* < T > & axisangle)\n    \n    Converts an axis-angle rotation into a quaternion.\n    \n    *Parameters*\n     ``axisangle`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["en function quatFromAxisAngle \"const RaveVector; T\""] = "\n\n*RaveVector* < T >  **quatFromAxisAngle**\\(const  *RaveVector* < T > & axis, T angle)\n    \n    Converts an axis-angle rotation into a quaternion.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis, 3 values \n     ``angle`` - \n      rotation angle (radians) \n            ";
m["en function quatFromMatrix \"const RaveTransform\""] = "\n\n*RaveVector* < T >  **quatFromMatrix**\\(const  *RaveTransformMatrix* < T > & rotation)\n    \n    Converts the rotation of a matrix into a quaternion.\n    \n    *Parameters*\n     ``t`` - \n      transform for extracting the 3x3 rotation. \n            ";
m["en function quatSlerp \"const RaveVector; const RaveVector; T\""] = "\n\n*RaveVector* < T >  **quatSlerp**\\(const  *RaveVector* < T > & quat0, const  *RaveVector* < T > & quat1, T t)\n    \n    Sphereical linear interpolation between two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n     ``t`` - \n      real value in [0,1]. 0 returns quat1, 1 returns quat2 \n            ";
m["en function axisAngleFromMatrix \"const RaveTransformMatrix\""] = "\n\n*RaveVector* < T >  **axisAngleFromMatrix**\\(const  *RaveTransformMatrix* < T > & rotation)\n    \n    Converts the rotation of a matrix into axis-angle representation.\n    \n    *Parameters*\n     ``rotation`` - \n      3x3 rotation matrix \n            ";
m["en function axisAngleFromQuat \"const RaveVector\""] = "\n\n*RaveVector* < T >  **axisAngleFromQuat**\\(const  *RaveVector* < T > & quat)\n    \n    Converts a quaternion into the axis-angle representation.\n    \n    *Parameters*\n     ``quat`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["en function matrixFromQuat \"const RaveVector\""] = "\n\n*RaveTransformMatrix* < T >  **matrixFromQuat**\\(const  *RaveVector* < T > & quat)\n    \n    Converts a quaternion to a 3x3 matrix.\n    \n    *Parameters*\n     ``quat`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["en function matrixFromAxisAngle \"const RaveVector\""] = "\n\n*RaveTransformMatrix* < T >  **matrixFromAxisAngle**\\(const  *RaveVector* < T > & axisangle)\n    \n    Converts an axis-angle rotation to a 3x3 matrix.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["en function matrixFromAxisAngle \"const RaveVector\""] = "\n\n*RaveTransformMatrix* < T >  **matrixFromAxisAngle**\\(const  *RaveVector* < T > & axisangle)\n    \n    Converts an axis-angle rotation to a 3x3 matrix.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["en function quatRotateDirection"] = "\n\n*RaveVector* < T >  **quatRotateDirection**\\(const  *RaveVector* < T > & sourcedir, const  *RaveVector* < T > & targetdir)\n    \n    Return the minimal quaternion that orients sourcedir to targetdir.\n    \n    *Parameters*\n     ``sourcedir`` - \n      direction of the original vector, 3 values \n     ``targetdir`` - \n      new direction, 3 values \n            ";
m["en function quatMultiply"] = "\n\n*RaveVector* < T >  **quatMultiply**\\(const  *RaveVector* < T > & quat0, const  *RaveVector* < T > & quat1)\n    \n    Multiply two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["en function quatMultiply"] = "\n\n*RaveVector* < T >  **quatMultiply**\\(const  *RaveVector* < T > & quat0, const  *RaveVector* < T > & quat1)\n    \n    Multiply two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["en enum DebugLevel"] = "\n\n **DebugLevel**\n    \n            ";
m["en enum SerializationOptions"] = "\n\n **SerializationOptions**\n    \n    serialization options for interfaces\n    \n            ";
m["en enum CollisionOptions"] = "\n\n **CollisionOptions**\n    \n    options for collision checker\n    \n            ";
m["en enum CollisionAction"] = "\n\n **CollisionAction**\n    \n    action to perform whenever a collision is detected between objects\n    \n            ";
m["en enum CloningOptions"] = "\n\n **CloningOptions**\n    \n            ";
m["en enum PhysicsEngineOptions"] = "\n\n **PhysicsEngineOptions**\n    \n    basic options for physics engine\n    \n            ";
m["en enum IkFilterOptions"] = "\n\n **IkFilterOptions**\n    \n    Controls what information gets validated when searching for an inverse kinematics solution.\n    \n            ";
m["en enum IkFilterReturn"] = "\n\n **IkFilterReturn**\n    \n    Return value for the ik filter that can be optionally set on an ik solver.\n    \n            ";
m["en enum SaveParameters"] = "\n\n **SaveParameters**\n    \n    Parameters passed into the state savers to control what information gets saved.\n    \n            ";
m["en enum GeomType"] = "\n\n **GeomType**\n    \n    The type of geometry primitive.\n    \n            ";
m["en enum JointType"] = "\n\n **JointType**\n    \n    The type of joint movement.\n    \n            ";
m["en enum DOFAffine"] = "\n\n **DOFAffine**\n    \n    if planner should plan with affine transformations, use this enumeartion to specify the real dofs\n    \n            ";
m["en enum SensorType"] = "\n\n **SensorType**\n    \n            ";
m["en enum ViewerEvents"] = "\n\n **ViewerEvents**\n    \n            ";
m["en enum TriangulateOptions"] = "\n\n **TriangulateOptions**\n    \n    A set of options specifying what to triangulate.\n    \n            ";
m["ja function InterfaceBase GetInterfaceType"] = "\n\nInterfaceType  **GetInterfaceType**\\()\n    \n            ";
m["ja function InterfaceBase GetXMLId"] = "\n\nconst std::string &  **GetXMLId**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the unique identifier that describes this class type, case is ignored should be the same id used to create the object \n        ";
m["ja function InterfaceBase GetPluginName"] = "\n\nconst std::string &  **GetPluginName**\\()\n    \n    set internally by RaveDatabase\n    \n    *Return*\n        the pluginname this interface was loaded from \n        ";
m["ja function InterfaceBase GetDescription"] = "\n\nconst std::string &  **GetDescription**\\()\n    \n    Documentation of the interface in reStructuredText format. See Documenting Interfaces.\n    \n            ";
m["ja function InterfaceBase GetEnv"] = "\n\nEnvironmentBasePtr  **GetEnv**\\()\n    \n    *Return*\n        the environment that this interface is attached to \n        ";
m["ja function InterfaceBase Clone"] = "\n\nbool  **Clone**\\(InterfaceBaseConstPtr preference, int cloningoptions)\n    \n    Clone the contents of an interface to the current interface.\n    \n    *Parameters*\n     ``preference`` - \n      the interface whose information to clone \n     ``cloningoptions`` - \n      mask of CloningOptions \n            ";
m["ja function InterfaceBase SetUserData"] = "\n\nvoid  **SetUserData**\\(boost::shared_ptr< void > data)\n    \n    set user data\n    \n            ";
m["ja function InterfaceBase GetUserData"] = "\n\nboost::shared_ptr< void >  **GetUserData**\\()\n    \n    *Return*\n        user custom data \n        ";
m["ja function InterfaceBase SendCommand"] = "\n\nbool  **SendCommand**\\(std::ostream & os, std::istream & is)\n    \n    Used to send special commands to the interface and receive output.\n    \n    The command must be registered by RegisterCommand. A special command ' is always supported and provides a way for the user to query the current commands and the help string. The format of the returned help commands are in reStructuredText. The following commands are possible:\n    *Parameters*\n     ``is`` - \n      the input stream containing the command \n     ``os`` - \n      the output stream containing the output \\ *Exceptions*\n     ``openrave_exception`` - \n      Throw if the command is not supported.\n    \n    *Return*\n        true if the command is successfully processed, otherwise false. \n        ";
m["ja function KinBody InitFromFile"] = "\n\nbool  **InitFromFile**\\(const std::string & filename, const std::list< std::pair< std::string, std::string > > & atts)\n    \n    Build the robot from an XML filename.\n    \n            ";
m["ja function KinBody InitFromData"] = "\n\nbool  **InitFromData**\\(const std::string & data, const std::list< std::pair< std::string, std::string > > & atts)\n    \n    Build the robot from a string representing XML information.\n    \n            ";
m["ja function KinBody InitFromBoxes \"const std::vector< AABB; bool\""] = "\n\nbool  **InitFromBoxes**\\(const std::vector<  AABB  > & boxes, bool draw)\n    \n    Create a kinbody with one link composed of an array of aligned bounding boxes.\n    \n    *Parameters*\n     ``vaabbs`` - \n      the array of aligned bounding boxes that will comprise of the body \n     ``bDraw`` - \n      if true, the boxes will be rendered in the scene \n            ";
m["ja function KinBody InitFromTrimesh"] = "\n\nbool  **InitFromTrimesh**\\(const  Link::TRIMESH  & trimesh, bool draw)\n    \n    Create a kinbody with one link composed of a triangle mesh surface.\n    \n    *Parameters*\n     ``trimesh`` - \n      the triangle mesh \n     ``bDraw`` - \n      if true, will be rendered in the scene \n            ";
m["ja function KinBody SetName"] = "\n\nvoid  **SetName**\\(const std::string & name)\n    \n    Set the name of the robot, notifies the environment and checks for uniqueness.\n    \n            ";
m["ja function KinBody GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n    Unique name of the robot.\n    \n            ";
m["ja function KinBody GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n    *Return*\n        number of controllable degrees of freedom of the body. Only uses _vecjoints and last joint for computation, so can work before ComputeJointHierarchy is called. \n        ";
m["ja function KinBody GetDOFValues"] = "\n\nvoid  **GetDOFValues**\\(std::vector<  dReal  > & v)\n    \n    Returns all the joint values as organized by the DOF indices.\n    \n            ";
m["ja function KinBody GetDOFValues"] = "\n\nvoid  **GetDOFValues**\\(std::vector<  dReal  > & v)\n    \n    Returns all the joint values as organized by the DOF indices.\n    \n            ";
m["ja function KinBody GetDOFVelocities"] = "\n\nvoid  **GetDOFVelocities**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function KinBody GetDOFLimits"] = "\n\nvoid  **GetDOFLimits**\\(std::vector<  dReal  > & vLowerLimit, std::vector<  dReal  > & vUpperLimit)\n    \n            ";
m["ja function KinBody GetDOFMaxVel"] = "\n\nvoid  **GetDOFMaxVel**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function KinBody GetDOFWeights"] = "\n\nvoid  **GetDOFWeights**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function KinBody GetJointValues"] = "\n\nvoid  **GetJointValues**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function KinBody GetJointVelocities"] = "\n\nvoid  **GetJointVelocities**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function KinBody GetJointLimits"] = "\n\nvoid  **GetJointLimits**\\(std::vector<  dReal  > & vLowerLimit, std::vector<  dReal  > & vUpperLimit)\n    \n            ";
m["ja function KinBody GetJointMaxVel"] = "\n\nvoid  **GetJointMaxVel**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function KinBody GetJointWeights"] = "\n\nvoid  **GetJointWeights**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function KinBody GetLinks"] = "\n\nconst std::vector<  LinkPtr  > &  **GetLinks**\\()\n    \n    *Return*\n        the links of the robot \n        ";
m["ja function KinBody GetLinks"] = "\n\nconst std::vector<  LinkPtr  > &  **GetLinks**\\()\n    \n    *Return*\n        the links of the robot \n        ";
m["ja function KinBody GetLink"] = "\n\nLinkPtr  **GetLink**\\(const std::string & name)\n    \n    return a pointer to the link with the given name\n    \n            ";
m["ja function KinBody GetJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetJoints**\\()\n    \n    Returns the joints making up the degrees of freedom in the user-defined order.\n    \n            ";
m["ja function KinBody GetJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetJoints**\\()\n    \n    Returns the joints making up the degrees of freedom in the user-defined order.\n    \n            ";
m["ja function KinBody GetPassiveJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetPassiveJoints**\\()\n    \n    Returns the passive joints, order does not matter.\n    \n            ";
m["ja function KinBody GetDependencyOrderedJoints"] = "\n\nconst std::vector<  JointPtr  > &  **GetDependencyOrderedJoints**\\()\n    \n    Returns the joints in hierarchical order starting at the base link.\n    \n    In the case of closed loops, the joints are returned in the order they are defined in _vecjoints.\n    \n    *Return*\n        Vector of joints such that the beginning joints affect the later ones. \n        ";
m["ja function KinBody GetRigidlyAttachedLinks"] = "\n\nvoid  **GetRigidlyAttachedLinks**\\(int linkindex, std::vector<  LinkPtr  > & vattachedlinks)\n    \n    Gets all the rigidly attached links to linkindex, also adds the link to the list.\n    \n    *Parameters*\n     ``linkindex`` - \n      the index to check for attached links. If < 0, then will return all links attached to the environment \n     ``vattachedlinks`` - \n      the array to insert all links attached to linkindex with the link itself. \n            ";
m["ja function KinBody GetChain"] = "\n\nbool  **GetChain**\\(int linkbaseindex, int linkendindex, std::vector<  JointPtr  > & vjoints)\n    \n    2\n    \n    *Parameters*\n     ``linkbaseindex`` - \n       \n     ``linkendindex`` - \n       \n     ``vjoints`` - \n      \n    \n    *Return*\n        true \n        ";
m["ja function KinBody GetJoint"] = "\n\nJointPtr  **GetJoint**\\(const std::string & name)\n    \n    Return a pointer to the joint with the given name.\n    \n            ";
m["ja function KinBody GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    queries the transfromation of the first link of the body\n    \n            ";
m["ja function KinBody GetBodyTransformations"] = "\n\nvoid  **GetBodyTransformations**\\(std::vector<  Transform  > & vtrans)\n    \n            ";
m["ja function KinBody SetBodyTransformations"] = "\n\nvoid  **SetBodyTransformations**\\(const std::vector<  Transform  > & transforms)\n    \n            ";
m["ja function KinBody GetLinkVelocities"] = "\n\nvoid  **GetLinkVelocities**\\(std::vector< std::pair<  Vector ,  Vector  > > & velocities)\n    \n    Returns the linear and angular velocities for each link.\n    \n            ";
m["ja function KinBody ComputeAABB"] = "\n\nAABB  **ComputeAABB**\\()\n    \n    Return an axis-aligned bounding box of the entire object.\n    \n            ";
m["ja function KinBody Enable"] = "\n\nvoid  **Enable**\\(bool enable)\n    \n    Enables or disables the bodies.\n    \n            ";
m["ja function KinBody IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    *Return*\n        true if any link of the KinBody is enabled \n        ";
m["ja function KinBody SetTransform"] = "\n\nvoid  **SetTransform**\\(const  Transform  & transform)\n    \n    \n    \n    *Parameters*\n     ``transform`` - \n       \n            ";
m["ja function KinBody SetJointValues \"const std::vector; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  dReal  > & values, bool checklimits = false )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices)  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["ja function KinBody SetJointValues \"const std::vector; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  dReal  > & values, bool checklimits = false )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices)  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["ja function KinBody SetJointValues \"const std::vector; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  dReal  > & values, bool checklimits = false )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices)  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["ja function KinBody SetJointValues \"const std::vector; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  dReal  > & values, bool checklimits = false )\n    \n    Sets the joint values of the robot.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices)  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["ja function KinBody SetJointTorques"] = "\n\nvoid  **SetJointTorques**\\(const std::vector<  dReal  > & torques, bool add)\n    \n    Adds a torque to every joint.\n    \n    *Parameters*\n     ``bAdd`` - \n      if true, adds to previous torques, otherwise resets the torques on all bodies and starts from 0 \n            ";
m["ja function KinBody SetJointValues \"const std::vector; const Transform; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  dReal  > & values, const  Transform  & transform, bool checklimits = false )\n    \n    Sets the joint values and transformation of the body.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``transform`` - \n      represents the transformation of the first body.  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["ja function KinBody SetJointValues \"const std::vector; const Transform; bool\""] = "\n\nvoid  **SetJointValues**\\(const std::vector<  dReal  > & values, const  Transform  & transform, bool checklimits = false )\n    \n    Sets the joint values and transformation of the body.\n    \n    *Parameters*\n     ``values`` - \n      the values to set the joint angles (ordered by the dof indices) \n     ``transform`` - \n      represents the transformation of the first body.  checklimits if true, will excplicitly check the joint limits before setting the values. \n            ";
m["ja function KinBody CalculateJacobian \"int; const Vector; boost::multi_array\""] = "\n\nvoid  **CalculateJacobian**\\(int linkindex, const  Vector  & offset, boost::multi_array<  dReal , 2 > & vjacobian)\n    \n    Computes the translation jacobian with respect to a world position.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that the rotation is attached to \n     ``position`` - \n      position in world space where to compute derivatives from. \n     ``vjacobian`` - \n      3xDOF matrix Gets the jacobian with respect to a link by computing the partial differentials for all joints that in the path from the root node to _veclinks[index] (doesn't touch the rest of the values) \n            ";
m["ja function KinBody CalculateRotationJacobian \"int; const Vector; boost::multi_array\""] = "\n\nvoid  **CalculateRotationJacobian**\\(int linkindex, const  Vector  & quat, boost::multi_array<  dReal , 2 > & vjacobian)\n    \n    Computes the rotational jacobian as a quaternion with respect to an initial rotation.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that the rotation is attached to \n     ``qInitialRot`` - \n      the rotation in world space whose derivative to take from. \n     ``vjacobian`` - \n      4xDOF matrix \n            ";
m["ja function KinBody CalculateAngularVelocityJacobian \"int; boost::multi_array\""] = "\n\nvoid  **CalculateAngularVelocityJacobian**\\(int linkindex, boost::multi_array<  dReal , 2 > & vjacobian)\n    \n    Computes the angular velocity jacobian of a specified link about the axes of world coordinates.\n    \n    *Parameters*\n     ``linkindex`` - \n      of the link that the rotation is attached to \n     ``vjacobian`` - \n      3xDOF matrix \n            ";
m["ja function KinBody CheckSelfCollision"] = "\n\nbool  **CheckSelfCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    Check if body is self colliding. Links that are joined together are ignored.\n    \n            ";
m["ja function KinBody CheckSelfCollision"] = "\n\nbool  **CheckSelfCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    Check if body is self colliding. Links that are joined together are ignored.\n    \n            ";
m["ja function KinBody IsAttached"] = "\n\nbool  **IsAttached**\\(KinBodyConstPtr body)\n    \n    *Return*\n        true if two bodies should be considered as one during collision (ie one is grabbing the other) \n        ";
m["ja function KinBody GetAttached"] = "\n\nvoid  **GetAttached**\\(std::set<  KinBodyPtr  > & setAttached)\n    \n    Recursively get all attached bodies of this body, including this body.\n    \n    *Parameters*\n     ``setAttached`` - \n      fills with the attached bodies. If any bodies are already in setAttached, then ignores recursing on their attached bodies. \n            ";
m["ja function KinBody IsRobot"] = "\n\nbool  **IsRobot**\\()\n    \n    Return true if this body is derived from RobotBase.\n    \n            ";
m["ja function KinBody GetEnvironmentId"] = "\n\nint  **GetEnvironmentId**\\()\n    \n    return a unique id of the body used in the environment.\n    \n    If object is not added to the environment, this will return 0. So checking if GetEnvironmentId() is 0 is a good way to check if object is present in the environment. This id will not be copied when cloning in order to respect another environment's ids.         ";
m["ja function KinBody DoesAffect"] = "\n\nchar  **DoesAffect**\\(int jointindex, int linkindex)\n    \n    *Parameters*\n     ``jointindex`` - \n      index of the joint \n     ``linkindex`` - \n      index of the link returns how the joint effects the link. If zero, link is unaffected. If negative, the partial derivative of the Jacobian should be negated. \n            ";
m["ja function KinBody WriteForwardKinematics"] = "\n\nvoid  **WriteForwardKinematics**\\(std::ostream & f)\n    \n    Writes a string for the forward kinematics of the robot (only hinge joints are handled).Format of the string is: where  and  are 3x4 matrices specified in row order (write the first row first) joint_axis is the unit vector for the joint_axis. If link_base is -1, attached to static environment         ";
m["ja function KinBody SetGuiData"] = "\n\nvoid  **SetGuiData**\\(boost::shared_ptr< void > data)\n    \n            ";
m["ja function KinBody GetGuiData"] = "\n\nboost::shared_ptr< void >  **GetGuiData**\\()\n    \n            ";
m["ja function InterfaceBase GetXMLFilename"] = "\n\nconst std::string &  **GetXMLFilename**\\()\n    \n    *Return*\n        the XML filename used to load the interface (sometimes this is not possible if the definition lies inside an environment file). \n        ";
m["ja function KinBody GetNonAdjacentLinks"] = "\n\nconst std::set< int > &  **GetNonAdjacentLinks**\\()\n    \n    *Return*\n        all possible link pairs that could get in collision \n        ";
m["ja function KinBody GetAdjacentLinks"] = "\n\nconst std::set< int > &  **GetAdjacentLinks**\\()\n    \n    *Return*\n        all possible link pairs whose collisions are ignored. \n        ";
m["ja function KinBody GetPhysicsData"] = "\n\nboost::shared_ptr< void >  **GetPhysicsData**\\()\n    \n            ";
m["ja function KinBody GetCollisionData"] = "\n\nboost::shared_ptr< void >  **GetCollisionData**\\()\n    \n            ";
m["ja function KinBody GetManageData"] = "\n\nManageDataPtr  **GetManageData**\\()\n    \n            ";
m["ja function KinBody GetUpdateStamp"] = "\n\nint  **GetUpdateStamp**\\()\n    \n    Return a unique id for every transformation state change of any link. Used to check if robot state has changed.\n    \n    The stamp is used by the collision checkers, physics engines, or any other item that needs to keep track of any changes of the KinBody as it moves. Currently stamps monotonically increment for every transformation/joint angle change.         ";
m["ja function KinBody serialize"] = "\n\nvoid  **serialize**\\(std::ostream & o, int options)\n    \n            ";
m["ja function KinBody GetKinematicsGeometryHash"] = "\n\nconst std::string &  **GetKinematicsGeometryHash**\\()\n    \n    A md5 hash unique to the particular kinematic and geometric structure of a KinBody.\n    \n    This 32 byte string can be used to check if two bodies have the same kinematic structure and can be used to index into tables when looking for body-specific models. OpenRAVE stores all such models in the OPENRAVE_HOME directory (usually ~/.openrave), indexed by the particular robot/body hashes.\n    \n    *Return*\n        md5 hash string of kinematics/geometry \n        ";
m["ja function KinBody::Link GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["ja function KinBody::Link GetIndex"] = "\n\nint  **GetIndex**\\()\n    \n            ";
m["ja function KinBody::Link IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    returns true if enabled\n    \n    enables a Link. An enabled link takes part in collision detection and physics simulations         ";
m["ja function KinBody::Link IsStatic"] = "\n\nbool  **IsStatic**\\()\n    \n            ";
m["ja function KinBody::Link Enable"] = "\n\nvoid  **Enable**\\(bool enable)\n    \n            ";
m["ja function KinBody::Link GetParent"] = "\n\nKinBodyPtr  **GetParent**\\()\n    \n            ";
m["ja function KinBody::Link GetParentLink"] = "\n\nboost::shared_ptr<  Link  >  **GetParentLink**\\()\n    \n    *Return*\n        the parent link in the kinematics hierarchy (ie the link closest to the root that is immediately connected to this link by a joint). If the link has no parents, returns an empty link. Mimic joints do not affect the parent link. \n        ";
m["ja function KinBody::Link GetCollisionData"] = "\n\nconst  TRIMESH  &  **GetCollisionData**\\()\n    \n            ";
m["ja function KinBody::Link ComputeAABB"] = "\n\nAABB  **ComputeAABB**\\()\n    \n    *Return*\n        the aabb of all the geometries of the link in the world coordinate system \n        ";
m["ja function KinBody::Link GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n    *Return*\n        current transformation of the link in the world coordinate system \n        ";
m["ja function KinBody::Link GetCOMOffset"] = "\n\nVector  **GetCOMOffset**\\()\n    \n    *Return*\n        center of mass offset in the link's local coordinate frame \n        ";
m["ja function KinBody::Link GetInertia"] = "\n\nconst  TransformMatrix  &  **GetInertia**\\()\n    \n            ";
m["ja function KinBody::Link GetMass"] = "\n\ndReal  **GetMass**\\()\n    \n            ";
m["ja function KinBody::Link SetTransform"] = "\n\nvoid  **SetTransform**\\(const  Transform  & transform)\n    \n    *Parameters*\n     ``t`` - \n      the new transformation \n            ";
m["ja function KinBody::Link SetForce"] = "\n\nvoid  **SetForce**\\(const  Vector  & force, const  Vector  & pos, bool add)\n    \n    *Parameters*\n     ``force`` - \n      the direction and magnitude of the force \n     ``pos`` - \n      in the world where the force is getting applied \n     ``add`` - \n      if true, force is added to previous forces, otherwise it is set adds an external force at pos (absolute coords) \n            ";
m["ja function KinBody::Link SetTorque"] = "\n\nvoid  **SetTorque**\\(const  Vector  & torque, bool add)\n    \n    *Parameters*\n     ``add`` - \n      if true, torque is added to previous torques, otherwise it is set adds torque to a body (absolute coords) \n            ";
m["ja function KinBody::Link GetGeometries"] = "\n\nconst std::list<  GEOMPROPERTIES  > &  **GetGeometries**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES SetCollisionMesh"] = "\n\nvoid  **SetCollisionMesh**\\(const  TRIMESH  & mesh)\n    \n    sets a new collision mesh and notifies every registered callback about it\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES GetCollisionMesh"] = "\n\nconst  TRIMESH  &  **GetCollisionMesh**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES SetDraw"] = "\n\nvoid  **SetDraw**\\(bool bDraw)\n    \n    sets a drawing and notifies every registered callback about it\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES SetTransparency"] = "\n\nvoid  **SetTransparency**\\(float f)\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES IsDraw"] = "\n\nbool  **IsDraw**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES IsModifiable"] = "\n\nbool  **IsModifiable**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES GetType"] = "\n\nGeomType  **GetType**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES GetTransform"] = "\n\nconst  Transform  &  **GetTransform**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES GetSphereRadius"] = "\n\ndReal  **GetSphereRadius**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES GetCylinderRadius"] = "\n\ndReal  **GetCylinderRadius**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES GetCylinderHeight"] = "\n\ndReal  **GetCylinderHeight**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES GetBoxExtents"] = "\n\nconst  Vector  &  **GetBoxExtents**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES GetRenderScale"] = "\n\nconst  Vector  &  **GetRenderScale**\\()\n    \n            ";
m["ja function KinBody::Link::GEOMPROPERTIES GetRenderFilename"] = "\n\nconst std::string &  **GetRenderFilename**\\()\n    \n            ";
m["ja function KinBody::Joint GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["ja function KinBody::Joint GetMimicJointIndex"] = "\n\nint  **GetMimicJointIndex**\\()\n    \n            ";
m["ja function KinBody::Joint GetMimicCoeffs"] = "\n\nconst std::vector<  dReal  > &  **GetMimicCoeffs**\\()\n    \n            ";
m["ja function KinBody::Joint GetMaxVel"] = "\n\ndReal  **GetMaxVel**\\()\n    \n            ";
m["ja function KinBody::Joint GetMaxAccel"] = "\n\ndReal  **GetMaxAccel**\\()\n    \n            ";
m["ja function KinBody::Joint GetMaxTorque"] = "\n\ndReal  **GetMaxTorque**\\()\n    \n            ";
m["ja function KinBody::Joint GetDOFIndex"] = "\n\nint  **GetDOFIndex**\\()\n    \n    Get the degree of freedom index in the body's DOF array, does not index in KinBody::_vecjoints! Ie, KinBody::GetJointValues()[GetDOFIndex()] == GetValues()         ";
m["ja function KinBody::Joint GetJointIndex"] = "\n\nint  **GetJointIndex**\\()\n    \n    Get the joint index into KinBody::_vecjoints.\n    \n            ";
m["ja function KinBody::Joint GetParent"] = "\n\nKinBodyPtr  **GetParent**\\()\n    \n            ";
m["ja function KinBody::Joint GetFirstAttached"] = "\n\nLinkPtr  **GetFirstAttached**\\()\n    \n            ";
m["ja function KinBody::Joint GetSecondAttached"] = "\n\nLinkPtr  **GetSecondAttached**\\()\n    \n            ";
m["ja function KinBody::Joint IsStatic"] = "\n\nbool  **IsStatic**\\()\n    \n    return true if joint can be treated as a static binding (ie all limits are 0)\n    \n            ";
m["ja function KinBody::Joint IsCircular"] = "\n\nbool  **IsCircular**\\()\n    \n    return true if joint has no limits\n    \n            ";
m["ja function KinBody::Joint GetType"] = "\n\nJointType  **GetType**\\()\n    \n            ";
m["ja function KinBody::Joint GetDOF"] = "\n\nint  **GetDOF**\\()\n    \n            ";
m["ja function KinBody::Joint GetValues"] = "\n\nvoid  **GetValues**\\(std::vector<  dReal  > & values, bool bAppend = false )\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it Gets the joint values with the correct offsets applied\n    \n    *Return*\n        degrees of freedom of the joint (even if pValues is NULL) \n        ";
m["ja function KinBody::Joint GetVelocities"] = "\n\nvoid  **GetVelocities**\\(std::vector<  dReal  > & values, bool bAppend = false )\n    \n    *Parameters*\n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it Gets the joint velocities\n    \n    *Return*\n        the degrees of freedom of the joint (even if pValues is NULL) \n        ";
m["ja function KinBody::Joint GetAnchor"] = "\n\nVector  **GetAnchor**\\()\n    \n    *Return*\n        the anchor of the joint in global coordinates \n        ";
m["ja function KinBody::Joint GetAxis"] = "\n\nVector  **GetAxis**\\(int axis = 0 )\n    \n    *Parameters*\n     ``axis`` - \n      the axis to get\n    \n    *Return*\n        the axis of the joint in global coordinates \n        ";
m["ja function KinBody::Joint GetInternalHierarchyAnchor"] = "\n\nVector  **GetInternalHierarchyAnchor**\\()\n    \n    *Return*\n        the anchor of the joint in local coordinates \n        ";
m["ja function KinBody::Joint GetInternalHierarchyAxis"] = "\n\nVector  **GetInternalHierarchyAxis**\\(int iaxis = 0 )\n    \n    *Return*\n        the axis of the joint in local coordinates \n        ";
m["ja function KinBody::Joint GetInternalHierarchyLeftTransform"] = "\n\nTransform  **GetInternalHierarchyLeftTransform**\\()\n    \n    left multiply transform given the base body\n    \n            ";
m["ja function KinBody::Joint GetInternalHierarchyRightTransform"] = "\n\nTransform  **GetInternalHierarchyRightTransform**\\()\n    \n    right multiply transform given the base body\n    \n            ";
m["ja function KinBody::Joint GetLimits"] = "\n\nvoid  **GetLimits**\\(std::vector<  dReal  > & vLowerLimit, std::vector<  dReal  > & vUpperLimit, bool bAppend = false )\n    \n    *Parameters*\n     ``vLowerLimit`` - \n      the lower limits \n     ``vUpperLimit`` - \n      the upper limits \n     ``bAppend`` - \n      if true will append to the end of the vector instead of erasing it Returns the limits of the joint\n    \n    *Return*\n        degrees of freedom of the joint \n        ";
m["ja function KinBody::Joint GetWeight"] = "\n\ndReal  **GetWeight**\\(int iaxis = 0 )\n    \n    *Return*\n        the weight associated with a joint's axis for computing a distance in the robot configuration space. \n        ";
m["ja function KinBody::Joint SetJointOffset"] = "\n\nvoid  **SetJointOffset**\\(dReal offset)\n    \n            ";
m["ja function KinBody::Joint SetJointLimits"] = "\n\nvoid  **SetJointLimits**\\(const std::vector<  dReal  > & lower, const std::vector<  dReal  > & upper)\n    \n            ";
m["ja function KinBody::Joint SetResolution"] = "\n\nvoid  **SetResolution**\\(dReal resolution)\n    \n            ";
m["ja function KinBody::Joint SetWeights"] = "\n\nvoid  **SetWeights**\\(const std::vector<  dReal  > & weights)\n    \n            ";
m["ja function KinBody::Joint AddTorque"] = "\n\nvoid  **AddTorque**\\(const std::vector<  dReal  > & torques)\n    \n    add torque\n    \n            ";
m["ja function KinBody::ManageData GetSystem"] = "\n\nSensorSystemBasePtr  **GetSystem**\\()\n    \n            ";
m["ja function KinBody::ManageData GetData"] = "\n\nXMLReadableConstPtr  **GetData**\\()\n    \n    returns a pointer to the data used to initialize the BODY with AddKinBody. if psize is not NULL, will be filled with the size of the data in bytes This function will be used to restore bodies that were removed         ";
m["ja function KinBody::ManageData GetOffsetLink"] = "\n\nKinBody::LinkPtr  **GetOffsetLink**\\()\n    \n    particular link that sensor system is tracking. All transformations describe this link.         ";
m["ja function KinBody::ManageData IsPresent"] = "\n\nbool  **IsPresent**\\()\n    \n    true if the object is being updated by the system due to its presence in the real environment\n    \n            ";
m["ja function KinBody::ManageData IsEnabled"] = "\n\nbool  **IsEnabled**\\()\n    \n    true if should update openrave body\n    \n            ";
m["ja function KinBody::ManageData IsLocked"] = "\n\nbool  **IsLocked**\\()\n    \n    if true, the vision system should not destroy this object once it stops being present\n    \n            ";
m["ja function KinBody::ManageData Lock"] = "\n\nbool  **Lock**\\(bool bDoLock)\n    \n    set a lock on a particular body\n    \n            ";
m["ja function IkParameterization SetTransform"] = "\n\nvoid  **SetTransform**\\(const  Transform  & t)\n    \n            ";
m["ja function IkParameterization SetRotation"] = "\n\nvoid  **SetRotation**\\(const  Vector  & quaternion)\n    \n            ";
m["ja function IkParameterization SetTranslation"] = "\n\nvoid  **SetTranslation**\\(const  Vector  & trans)\n    \n            ";
m["ja function IkParameterization SetDirection"] = "\n\nvoid  **SetDirection**\\(const  Vector  & dir)\n    \n            ";
m["ja function IkParameterization SetRay"] = "\n\nvoid  **SetRay**\\(const  RAY  & ray)\n    \n            ";
m["ja function IkParameterization GetType"] = "\n\nType  **GetType**\\()\n    \n            ";
m["ja function IkParameterization GetTransform"] = "\n\nconst  Transform  &  **GetTransform**\\()\n    \n            ";
m["ja function IkParameterization GetRotation"] = "\n\nconst  Vector  &  **GetRotation**\\()\n    \n            ";
m["ja function IkParameterization GetTranslation"] = "\n\nconst  Vector  &  **GetTranslation**\\()\n    \n            ";
m["ja function IkParameterization GetDirection"] = "\n\nconst  Vector  &  **GetDirection**\\()\n    \n            ";
m["ja function IkParameterization GetRay"] = "\n\nconst  RAY  **GetRay**\\()\n    \n            ";
m["ja function RobotBase GetManipulators"] = "\n\nstd::vector<  ManipulatorPtr  > &  **GetManipulators**\\()\n    \n    Returns the manipulators of the robot.\n    \n            ";
m["ja function RobotBase GetManipulators"] = "\n\nstd::vector<  ManipulatorPtr  > &  **GetManipulators**\\()\n    \n    Returns the manipulators of the robot.\n    \n            ";
m["ja function RobotBase SetActiveManipulator \"int\""] = "\n\nvoid  **SetActiveManipulator**\\(int index)\n    \n    *Parameters*\n     ``index`` - \n      manipulator index sets the active manipulator of the robot \n            ";
m["ja function RobotBase SetActiveManipulator \"const std::string\""] = "\n\nvoid  **SetActiveManipulator**\\(const std::string & manipname)\n    \n    *Parameters*\n     ``manipname`` - \n      manipulator name sets the active manipulator of the robot \n            ";
m["ja function RobotBase GetActiveManipulator"] = "\n\nManipulatorPtr  **GetActiveManipulator**\\()\n    \n            ";
m["ja function RobotBase GetActiveManipulatorIndex"] = "\n\nint  **GetActiveManipulatorIndex**\\()\n    \n    *Return*\n        index of the current active manipulator \n        ";
m["ja function RobotBase GetAttachedSensors"] = "\n\nstd::vector<  AttachedSensorPtr  > &  **GetAttachedSensors**\\()\n    \n            ";
m["ja function RobotBase GetController"] = "\n\nControllerBasePtr  **GetController**\\()\n    \n            ";
m["ja function RobotBase SetController"] = "\n\nbool  **SetController**\\(ControllerBasePtr controller, const std::string & args)\n    \n    *Parameters*\n     ``pController`` - \n      - if NULL, sets the controller of this robot to NULL. otherwise attemps to set the controller to this robot. \n     ``args`` - \n      - the argument list to pass when initializing the controller set a controller for a robot and destroy the old \n            ";
m["ja function RobotBase SetActiveDOFs \"const std::vector; int\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine = DOF_NoTransform )\n    \n    *Parameters*\n     ``dofindices`` - \n      the indices of the original degrees of freedom to use. \n     ``affine`` - \n      A bitmask of DOFAffine values Set the joint indices and affine transformation dofs that the planner should use. If DOF_RotationAxis is specified, the previously set axis is used. \n            ";
m["ja function RobotBase SetActiveDOFs \"const std::vector; int\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine = DOF_NoTransform )\n    \n    *Parameters*\n     ``dofindices`` - \n      the indices of the original degrees of freedom to use. \n     ``affine`` - \n      A bitmask of DOFAffine values Set the joint indices and affine transformation dofs that the planner should use. If DOF_RotationAxis is specified, the previously set axis is used. \n            ";
m["ja function RobotBase SetActiveDOFs \"const std::vector; int; const Vector\""] = "\n\nvoid  **SetActiveDOFs**\\(const std::vector< int > & dofindices, int affine, const  Vector  & rotationaxis)\n    \n    *Parameters*\n     ``vDOFIndices`` - \n      the indices of the original degrees of freedom to use. \n     ``nAffineDOFsBitmask`` - \n      A bitmask of DOFAffine values \n     ``pRotationAxis`` - \n      if DOF_RotationAxis is specified, pRotationAxis is used as the new axis \n            ";
m["ja function RobotBase GetActiveDOF"] = "\n\nint  **GetActiveDOF**\\()\n    \n            ";
m["ja function RobotBase GetAffineDOF"] = "\n\nint  **GetAffineDOF**\\()\n    \n            ";
m["ja function RobotBase GetAffineDOFIndex"] = "\n\nint  **GetAffineDOFIndex**\\(DOFAffine dof)\n    \n    if dof is set in the affine dofs, returns its index in the dof values array, otherwise returns -1\n    \n            ";
m["ja function RobotBase GetAffineRotationAxis"] = "\n\nVector  **GetAffineRotationAxis**\\()\n    \n            ";
m["ja function RobotBase SetAffineTranslationLimits"] = "\n\nvoid  **SetAffineTranslationLimits**\\(const  Vector  & lower, const  Vector  & upper)\n    \n            ";
m["ja function RobotBase SetAffineRotationAxisLimits"] = "\n\nvoid  **SetAffineRotationAxisLimits**\\(const  Vector  & lower, const  Vector  & upper)\n    \n            ";
m["ja function RobotBase SetAffineRotation3DLimits"] = "\n\nvoid  **SetAffineRotation3DLimits**\\(const  Vector  & lower, const  Vector  & upper)\n    \n            ";
m["ja function RobotBase SetAffineRotationQuatLimits"] = "\n\nvoid  **SetAffineRotationQuatLimits**\\(const  Vector  & lower, const  Vector  & upper)\n    \n            ";
m["ja function RobotBase SetAffineTranslationMaxVels"] = "\n\nvoid  **SetAffineTranslationMaxVels**\\(const  Vector  & vels)\n    \n            ";
m["ja function RobotBase SetAffineRotationAxisMaxVels"] = "\n\nvoid  **SetAffineRotationAxisMaxVels**\\(const  Vector  & vels)\n    \n            ";
m["ja function RobotBase SetAffineRotation3DMaxVels"] = "\n\nvoid  **SetAffineRotation3DMaxVels**\\(const  Vector  & vels)\n    \n            ";
m["ja function RobotBase SetAffineRotationQuatMaxVels"] = "\n\nvoid  **SetAffineRotationQuatMaxVels**\\(const  Vector  & vels)\n    \n            ";
m["ja function RobotBase SetAffineTranslationResolution"] = "\n\nvoid  **SetAffineTranslationResolution**\\(const  Vector  & resolution)\n    \n            ";
m["ja function RobotBase SetAffineRotationAxisResolution"] = "\n\nvoid  **SetAffineRotationAxisResolution**\\(const  Vector  & resolution)\n    \n            ";
m["ja function RobotBase SetAffineRotation3DResolution"] = "\n\nvoid  **SetAffineRotation3DResolution**\\(const  Vector  & resolution)\n    \n            ";
m["ja function RobotBase SetAffineRotationQuatResolution"] = "\n\nvoid  **SetAffineRotationQuatResolution**\\(const  Vector  & resolution)\n    \n            ";
m["ja function RobotBase SetAffineTranslationWeights"] = "\n\nvoid  **SetAffineTranslationWeights**\\(const  Vector  & weights)\n    \n            ";
m["ja function RobotBase SetAffineRotationAxisWeights"] = "\n\nvoid  **SetAffineRotationAxisWeights**\\(const  Vector  & weights)\n    \n            ";
m["ja function RobotBase SetAffineRotation3DWeights"] = "\n\nvoid  **SetAffineRotation3DWeights**\\(const  Vector  & weights)\n    \n            ";
m["ja function RobotBase SetAffineRotationQuatWeights"] = "\n\nvoid  **SetAffineRotationQuatWeights**\\(const  Vector  & weights)\n    \n            ";
m["ja function RobotBase GetAffineTranslationLimits"] = "\n\nvoid  **GetAffineTranslationLimits**\\(Vector  & lower, Vector  & upper)\n    \n            ";
m["ja function RobotBase GetAffineRotationAxisLimits"] = "\n\nvoid  **GetAffineRotationAxisLimits**\\(Vector  & lower, Vector  & upper)\n    \n            ";
m["ja function RobotBase GetAffineRotation3DLimits"] = "\n\nvoid  **GetAffineRotation3DLimits**\\(Vector  & lower, Vector  & upper)\n    \n            ";
m["ja function RobotBase GetAffineRotationQuatLimits"] = "\n\nvoid  **GetAffineRotationQuatLimits**\\(Vector  & lower, Vector  & upper)\n    \n            ";
m["ja function RobotBase GetAffineTranslationMaxVels"] = "\n\nVector  **GetAffineTranslationMaxVels**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationAxisMaxVels"] = "\n\nVector  **GetAffineRotationAxisMaxVels**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotation3DMaxVels"] = "\n\nVector  **GetAffineRotation3DMaxVels**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationQuatMaxVels"] = "\n\nVector  **GetAffineRotationQuatMaxVels**\\()\n    \n            ";
m["ja function RobotBase GetAffineTranslationResolution"] = "\n\nVector  **GetAffineTranslationResolution**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationAxisResolution"] = "\n\nVector  **GetAffineRotationAxisResolution**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotation3DResolution"] = "\n\nVector  **GetAffineRotation3DResolution**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationQuatResolution"] = "\n\nVector  **GetAffineRotationQuatResolution**\\()\n    \n            ";
m["ja function RobotBase GetAffineTranslationWeights"] = "\n\nVector  **GetAffineTranslationWeights**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationAxisWeights"] = "\n\nVector  **GetAffineRotationAxisWeights**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotation3DWeights"] = "\n\nVector  **GetAffineRotation3DWeights**\\()\n    \n            ";
m["ja function RobotBase GetAffineRotationQuatWeights"] = "\n\nVector  **GetAffineRotationQuatWeights**\\()\n    \n            ";
m["ja function RobotBase SetActiveDOFValues"] = "\n\nvoid  **SetActiveDOFValues**\\(const std::vector<  dReal  > & values, bool bCheckLimits = false )\n    \n            ";
m["ja function RobotBase GetActiveDOFValues"] = "\n\nvoid  **GetActiveDOFValues**\\(std::vector<  dReal  > & v)\n    \n            ";
m["ja function RobotBase SetActiveDOFVelocities"] = "\n\nvoid  **SetActiveDOFVelocities**\\(const std::vector<  dReal  > & velocities)\n    \n            ";
m["ja function RobotBase GetActiveDOFVelocities"] = "\n\nvoid  **GetActiveDOFVelocities**\\(std::vector<  dReal  > & velocities)\n    \n            ";
m["ja function RobotBase GetActiveDOFLimits"] = "\n\nvoid  **GetActiveDOFLimits**\\(std::vector<  dReal  > & lower, std::vector<  dReal  > & upper)\n    \n            ";
m["ja function RobotBase GetActiveDOFIndices"] = "\n\nconst std::vector< int > &  **GetActiveDOFIndices**\\()\n    \n    Return the set of active dof indices of the joints.\n    \n            ";
m["ja function RobotBase CalculateActiveJacobian \"int; const Vector; boost::multi_array\""] = "\n\nvoid  **CalculateActiveJacobian**\\(int index, const  Vector  & offset, boost::multi_array<  dReal , 2 > & vjacobian)\n    \n    gets the jacobian with respect to a link, pfArray is a 3 x ActiveDOF matrix (rotations are not taken into account) Calculates the partial differentials for the active degrees of freedom that in the path from the root node to _veclinks[index] (doesn't touch the rest of the values)         ";
m["ja function RobotBase CalculateActiveRotationJacobian \"int; const Vector; boost::multi_array\""] = "\n\nvoid  **CalculateActiveRotationJacobian**\\(int index, const  Vector  & qInitialRot, boost::multi_array<  dReal , 2 > & vjacobian)\n    \n            ";
m["ja function RobotBase CalculateActiveAngularVelocityJacobian \"int; boost::multi_array\""] = "\n\nvoid  **CalculateActiveAngularVelocityJacobian**\\(int index, boost::multi_array<  dReal , 2 > & vjacobian)\n    \n    *Parameters*\n     ``index`` - \n      of the link that the rotation is attached to \n     ``vjacobian`` - \n      3x(num ACTIVE DOF) matrix calculates the angular velocity jacobian of a specified link about the axes of world coordinates \n            ";
m["ja function RobotBase Grab \"KinBodyPtr\""] = "\n\nbool  **Grab**\\(KinBodyPtr body)\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed Grabs the body with the active manipulator's end effector.\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["ja function RobotBase Grab \"KinBodyPtr; const std::set\""] = "\n\nbool  **Grab**\\(KinBodyPtr body, const std::set< int > & setRobotLinksToIgnore)\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``setRobotLinksToIgnore`` - \n      Additional robot link indices that collision checker ignore when checking collisions between the grabbed body and the robot. Grabs the body with the active manipulator's end effector.\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["ja function RobotBase Grab \"KinBodyPtr; LinkPtr\""] = "\n\nbool  **Grab**\\(KinBodyPtr body, LinkPtr pRobotLinkToGrabWith)\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``pRobotLinkToGrabWith`` - \n      the link of this robot that will perform the grab Grab a body with the specified link.\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["ja function RobotBase Grab \"KinBodyPtr; LinkPtr; const std::set\""] = "\n\nbool  **Grab**\\(KinBodyPtr body, LinkPtr pRobotLinkToGrabWith, const std::set< int > & setRobotLinksToIgnore)\n    \n    *Parameters*\n     ``body`` - \n      the body to be grabbed \n     ``pRobotLinkToGrabWith`` - \n      the link of this robot that will perform the grab \n     ``setRobotLinksToIgnore`` - \n      Additional robot link indices that collision checker ignore when checking collisions between the grabbed body and the robot. Grab the body with the specified link.\n    \n    *Return*\n        true if successful and body is grabbed \n        ";
m["ja function RobotBase Release"] = "\n\nvoid  **Release**\\(KinBodyPtr body)\n    \n    *Parameters*\n     ``body`` - \n      body to release Release the body if grabbed. \n            ";
m["ja function RobotBase ReleaseAllGrabbed"] = "\n\nvoid  **ReleaseAllGrabbed**\\()\n    \n    Release all grabbed bodies.\n    \n    release all bodies         ";
m["ja function RobotBase RegrabAll"] = "\n\nvoid  **RegrabAll**\\()\n    \n    Releases and grabs all bodies, has the effect of recalculating all the initial collision with the bodies. In other words, the current collisions any grabbed body makes with the robot will be re-inserted into an ignore list         ";
m["ja function RobotBase IsGrabbing"] = "\n\nLinkPtr  **IsGrabbing**\\(KinBodyConstPtr body)\n    \n    *Parameters*\n     ``body`` - \n      the body to check\n    \n    *Return*\n        the robot link that is currently grabbing the body. If the body is not grabbed, will return an empty pointer. \n        ";
m["ja function RobotBase GetGrabbed"] = "\n\nvoid  **GetGrabbed**\\(std::vector<  KinBodyPtr  > & vbodies)\n    \n    *Parameters*\n     ``vbodies`` - \n      filled with the grabbed bodies gets all grabbed bodies of the robot \n            ";
m["ja function RobotBase GetRobotStructureHash"] = "\n\nconst std::string &  **GetRobotStructureHash**\\()\n    \n    A md5 hash unique to the particular robot structure that involves manipulation and sensing components The serialization for the attached sensors will not involve any sensor specific properties (since they can change through calibration)         ";
m["ja function RobotBase::Manipulator GetEndEffectorTransform"] = "\n\nTransform  **GetEndEffectorTransform**\\()\n    \n    Return the transformation of the end effector (manipulator frame).\n    \n    All inverse kinematics and grasping queries are specifying this frame.         ";
m["ja function RobotBase::Manipulator GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["ja function RobotBase::Manipulator GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\()\n    \n            ";
m["ja function RobotBase::Manipulator SetIkSolver"] = "\n\nbool  **SetIkSolver**\\(IkSolverBasePtr iksolver)\n    \n    Sets the ik solver and initializes it with the current manipulator.\n    \n            ";
m["ja function RobotBase::Manipulator GetIkSolver"] = "\n\nIkSolverBasePtr  **GetIkSolver**\\()\n    \n    Returns the currently set ik solver.\n    \n            ";
m["ja function RobotBase::Manipulator SetIkSolver"] = "\n\nbool  **SetIkSolver**\\(IkSolverBasePtr iksolver)\n    \n    Sets the ik solver and initializes it with the current manipulator.\n    \n            ";
m["ja function RobotBase::Manipulator InitIKSolver"] = "\n\nbool  **InitIKSolver**\\()\n    \n            ";
m["ja function RobotBase::Manipulator GetIKSolverName"] = "\n\nconst std::string &  **GetIKSolverName**\\()\n    \n            ";
m["ja function RobotBase::Manipulator HasIKSolver"] = "\n\nbool  **HasIKSolver**\\()\n    \n            ";
m["ja function RobotBase::Manipulator GetNumFreeParameters"] = "\n\nint  **GetNumFreeParameters**\\()\n    \n    *Return*\n        Number of free parameters defining the null solution space. Each parameter is always in the range of [0,1]. \n        ";
m["ja function RobotBase::Manipulator GetFreeParameters"] = "\n\nbool  **GetFreeParameters**\\(std::vector<  dReal  > & vFreeParameters)\n    \n    *Parameters*\n     ``vFreeParameters`` - \n      is filled with GetNumFreeParameters() parameters in [0,1] range gets the free parameters from the current robot configuration\n    \n    *Return*\n        true if succeeded \n        ";
m["ja function RobotBase::Manipulator FindIKSolution \"const IkParameterization; std::vector; int\""] = "\n\nbool  **FindIKSolution**\\(const  IkParameterization  & goal, std::vector<  dReal  > & solution, int filteroptions)\n    \n    *Parameters*\n     ``goal`` - \n      The transformation of the end-effector in the global coord system \n     ``solution`` - \n      Will be of size GetArmIndices().size() and contain the best solution \n     ``filteroptions`` - \n      A bitmask of IkFilterOptions values controlling what is checked for each ik solution. will find a close solution to the current robot's joint values. The function is a wrapper around the IkSolver interface. Note that the solution returned is not guaranteed to be the closest solution. In order to compute that, will have to compute all the ik solutions using FindIKSolutions. \n            ";
m["ja function RobotBase::Manipulator FindIKSolution \"const IkParameterization; const std::vector; std::vector; int\""] = "\n\nbool  **FindIKSolution**\\(const  IkParameterization  & goal, const std::vector<  dReal  > & vFreeParameters, std::vector<  dReal  > & solution, int filteroptions)\n    \n            ";
m["ja function RobotBase::Manipulator FindIKSolutions \"const IkParameterization; std::vector; int\""] = "\n\nbool  **FindIKSolutions**\\(const  IkParameterization  & goal, std::vector< std::vector<  dReal  > > & solutions, int filteroptions)\n    \n    *Parameters*\n     ``goal`` - \n      The transformation of the end-effector in the global coord system \n     ``solutions`` - \n      An array of all solutions, each element in solutions is of size GetArmIndices().size() \n     ``filteroptions`` - \n      A bitmask of IkFilterOptions values controlling what is checked for each ik solution. will find all the IK solutions for the given end effector transform \n            ";
m["ja function RobotBase::Manipulator FindIKSolutions \"const IkParameterization; const std::vector; std::vector; int\""] = "\n\nbool  **FindIKSolutions**\\(const  IkParameterization  & goal, const std::vector<  dReal  > & vFreeParameters, std::vector< std::vector<  dReal  > > & solutions, int filteroptions)\n    \n            ";
m["ja function RobotBase::Manipulator GetBase"] = "\n\nLinkPtr  **GetBase**\\()\n    \n    the base used for the iksolver\n    \n            ";
m["ja function RobotBase::Manipulator GetEndEffector"] = "\n\nLinkPtr  **GetEndEffector**\\()\n    \n    the end effector link (used to define workspace distance)\n    \n            ";
m["ja function RobotBase::Manipulator GetGraspTransform"] = "\n\nTransform  **GetGraspTransform**\\()\n    \n    *Return*\n        transform with respect to end effector defining the grasp coordinate system \n        ";
m["ja function RobotBase::Manipulator GetGripperIndices"] = "\n\nconst std::vector< int > &  **GetGripperIndices**\\()\n    \n    Gripper indices of the joints that the manipulator controls.\n    \n            ";
m["ja function RobotBase::Manipulator GetGripperIndices"] = "\n\nconst std::vector< int > &  **GetGripperIndices**\\()\n    \n    Gripper indices of the joints that the manipulator controls.\n    \n            ";
m["ja function RobotBase::Manipulator GetArmIndices"] = "\n\nconst std::vector< int > &  **GetArmIndices**\\()\n    \n    Return the indices of the DOFs of the arm (used for IK, etc).\n    \n    Usually the DOF indices from pBase to pEndEffector         ";
m["ja function RobotBase::Manipulator GetArmIndices"] = "\n\nconst std::vector< int > &  **GetArmIndices**\\()\n    \n    Return the indices of the DOFs of the arm (used for IK, etc).\n    \n    Usually the DOF indices from pBase to pEndEffector         ";
m["ja function RobotBase::Manipulator GetClosingDirection"] = "\n\nconst std::vector<  dReal  > &  **GetClosingDirection**\\()\n    \n    normal direction to move joints to 'close' the hand\n    \n            ";
m["ja function RobotBase::Manipulator GetDirection"] = "\n\nVector  **GetDirection**\\()\n    \n    direction of palm/head/manipulator used for approaching inside the grasp coordinate system\n    \n            ";
m["ja function RobotBase::Manipulator GetDirection"] = "\n\nVector  **GetDirection**\\()\n    \n    direction of palm/head/manipulator used for approaching inside the grasp coordinate system\n    \n            ";
m["ja function RobotBase::Manipulator IsGrabbing"] = "\n\nbool  **IsGrabbing**\\(KinBodyConstPtr body)\n    \n    *Return*\n        true if the body is being grabbed by any link on this manipulator \n        ";
m["ja function RobotBase::Manipulator GetChildJoints"] = "\n\nvoid  **GetChildJoints**\\(std::vector<  JointPtr  > & vjoints)\n    \n    get all child joints of the manipulator starting at the pEndEffector link\n    \n            ";
m["ja function RobotBase::Manipulator GetChildDOFIndices"] = "\n\nvoid  **GetChildDOFIndices**\\(std::vector< int > & vdofndices)\n    \n    get all child DOF indices of the manipulator starting at the pEndEffector link\n    \n            ";
m["ja function RobotBase::Manipulator GetChildLinks"] = "\n\nvoid  **GetChildLinks**\\(std::vector<  LinkPtr  > & vlinks)\n    \n    get all child links of the manipulator starting at pEndEffector link\n    \n            ";
m["ja function RobotBase::Manipulator GetIndependentLinks"] = "\n\nvoid  **GetIndependentLinks**\\(std::vector<  LinkPtr  > & vlinks)\n    \n    Get all links that are independent of the arm and gripper joints conditioned that the base and end effector links are static. In other words, returns all links not on the path from the base to the end effector and not children of the end effector.         ";
m["ja function RobotBase::Manipulator CheckEndEffectorCollision"] = "\n\nbool  **CheckEndEffectorCollision**\\(const  Transform  & tEE, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *Parameters*\n     ``tEE`` - \n      the end effector transform \n     ``report`` - \n      [optional] collision report checks collision with only the gripper given its end-effector transform\n    \n    *Return*\n        true if a collision occurred \n        ";
m["ja function RobotBase::Manipulator CheckEndEffectorCollision"] = "\n\nbool  **CheckEndEffectorCollision**\\(const  Transform  & tEE, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *Parameters*\n     ``tEE`` - \n      the end effector transform \n     ``report`` - \n      [optional] collision report checks collision with only the gripper given its end-effector transform\n    \n    *Return*\n        true if a collision occurred \n        ";
m["ja function RobotBase::Manipulator CheckIndependentCollision"] = "\n\nbool  **CheckIndependentCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    *Parameters*\n     ``report`` - \n      [optional] collision report checks collision with the environment with all the independent links of the robot\n    \n    *Return*\n        true if a collision occurred \n        ";
m["ja function RobotBase::Manipulator CheckIndependentCollision"] = "\n\nbool  **CheckIndependentCollision**\\(CollisionReportPtr report = CollisionReportPtr () )\n    \n    *Parameters*\n     ``report`` - \n      [optional] collision report checks collision with the environment with all the independent links of the robot\n    \n    *Return*\n        true if a collision occurred \n        ";
m["ja function RobotBase::Manipulator GetStructureHash"] = "\n\nconst std::string &  **GetStructureHash**\\()\n    \n    Return hash of just the manipulator definition.\n    \n            ";
m["ja function RobotBase::Manipulator GetKinematicsStructureHash"] = "\n\nconst std::string &  **GetKinematicsStructureHash**\\()\n    \n    Return hash of all kinematics information that involves solving the inverse kinematics equations.\n    \n    This includes joint axes, joint positions, and final grasp transform. Hash is used to cache the solvers.         ";
m["ja function RobotBase::AttachedSensor GetSensor"] = "\n\nSensorBasePtr  **GetSensor**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetAttachingLink"] = "\n\nLinkPtr  **GetAttachingLink**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetRelativeTransform"] = "\n\nTransform  **GetRelativeTransform**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n            ";
m["ja function RobotBase::AttachedSensor GetData"] = "\n\nSensorBase::SensorDataPtr  **GetData**\\()\n    \n    retrieves the current data from the sensor\n    \n            ";
m["ja function RobotBase::AttachedSensor SetRelativeTransform"] = "\n\nvoid  **SetRelativeTransform**\\(const  Transform  & t)\n    \n            ";
m["ja function RobotBase::AttachedSensor GetStructureHash"] = "\n\nconst std::string &  **GetStructureHash**\\()\n    \n    *Return*\n        hash of the sensor definition \n        ";
m["ja function PlannerBase InitPlan \"RobotBasePtr; PlannerParametersConstPtr\""] = "\n\nbool  **InitPlan**\\(RobotBasePtr probot, PlannerParametersConstPtr pparams)\n    \n    Setup scene, robot, and properties of the plan, and reset all internal structures.\n    \n    *Parameters*\n     ``probot`` - \n      The robot will be planning for. \n     ``pparams`` - \n      The parameters of the planner, any class derived from PlannerParameters can be passed. The planner should copy these parameters for future instead of storing the pointer. \n            ";
m["ja function PlannerBase InitPlan \"RobotBasePtr; std::istream\""] = "\n\nbool  **InitPlan**\\(RobotBasePtr pbase, std::istream & isParameters)\n    \n    Setup scene, robot, and properties of the plan, and reset all structures with pparams.\n    \n    *Parameters*\n     ``pbase`` - \n      The robot will be planning for. \n     ``isParameters`` - \n      The serialized form of the parameters. By default, this exists to allow third parties to pass information to planners without excplicitly knowning the format/internal structures used \n            ";
m["ja function PlannerBase PlanPath"] = "\n\nbool  **PlanPath**\\(TrajectoryBasePtr ptraj, boost::shared_ptr< std::ostream > pOutStream = boost::shared_ptr< std::ostream >() )\n    \n    Executes the main planner trying to solve for the goal condition.\n    \n    *Parameters*\n     ``ptraj`` - \n      The output trajectory the robot has to follow in order to successfully complete the plan. If this planner is a path optimizer, the trajectory can be used as an input for generating a smoother path. The trajectory is for the configuration degrees of freedom defined by the planner parameters. \n     ``pOutStream`` - \n      If specified, planner will output any other special data Fill ptraj with the trajectory of the planned path that the robot needs to execute\n    \n    *Return*\n        true if planner is successful \n        ";
m["ja function PlannerBase GetParameters"] = "\n\nPlannerParametersConstPtr  **GetParameters**\\()\n    \n    *Return*\n        the internal parameters of the planner \n        ";
m["ja function ControllerBase Init"] = "\n\nbool  **Init**\\(RobotBasePtr robot, const std::string & args)\n    \n    *Parameters*\n     ``robot`` - \n      the robot that uses the controller \n     ``args`` - \n      extra arguments that the controller takes. Initializes the controller\n    \n    *Return*\n        true on successful initialization \n        ";
m["ja function ControllerBase Reset"] = "\n\nvoid  **Reset**\\(int options)\n    \n    *Parameters*\n     ``options`` - \n      - specific options that can be used to control what to reset Resets the current controller trajectories and any other state associated with the robot \n            ";
m["ja function ControllerBase SetDesired"] = "\n\nbool  **SetDesired**\\(const std::vector<  dReal  > & values)\n    \n    *Parameters*\n     ``values`` - \n      - final configuration go to a specific position in configuration space\n    \n    *Return*\n        true if position operation successful \n        ";
m["ja function ControllerBase SetPath"] = "\n\nbool  **SetPath**\\(TrajectoryBaseConstPtr ptraj)\n    \n    *Parameters*\n     ``ptraj`` - \n      - the trajectory follow a path in configuration space, adds to the queue of trajectories already in execution\n    \n    *Return*\n        true if trajectory operation successful \n        ";
m["ja function ControllerBase SimulationStep \"dReal\""] = "\n\nbool  **SimulationStep**\\(dReal fTimeElapsed)\n    \n    *Parameters*\n     ``fTimeElapsed`` - \n      - time elapsed in simulation environment since last frame Simulate one step forward for controllers running in the simulation environment\n    \n    *Return*\n        true if the controller is done with the current commands it is given \n        ";
m["ja function ControllerBase IsDone"] = "\n\nbool  **IsDone**\\()\n    \n    *Return*\n        true when goal reached. If a trajectory was set, return only when trajectory is done. If SetDesired was called, return only when robot is is at the desired location. If SendCommand sent, returns true when the command was completed by the hand. \n        ";
m["ja function ControllerBase GetTime"] = "\n\ndReal  **GetTime**\\()\n    \n    *Return*\n        the time along the current command \n        ";
m["ja function ControllerBase GetVelocity"] = "\n\nvoid  **GetVelocity**\\(std::vector<  dReal  > & vel)\n    \n    *Parameters*\n     ``vel`` - \n      [out] - current velocity of robot get velocity \n            ";
m["ja function ControllerBase GetTorque"] = "\n\nvoid  **GetTorque**\\(std::vector<  dReal  > & torque)\n    \n    *Parameters*\n     ``torque`` - \n      [out] - returns the current torque/current/strain exerted by each of the joints from outside forces. The feedforward and friction terms should be subtracted out already get torque/current/strain values \n            ";
m["ja function PhysicsEngineBase GetPhysicsOptions"] = "\n\nint  **GetPhysicsOptions**\\()\n    \n            ";
m["ja function PhysicsEngineBase SetPhysicsOptions \"int\""] = "\n\nbool  **SetPhysicsOptions**\\(int physicsoptions)\n    \n    Set basic physics engine using the PhysicsEngineOptions enum.\n    \n            ";
m["ja function PhysicsEngineBase InitEnvironment"] = "\n\nbool  **InitEnvironment**\\()\n    \n    called when environment sets this physics engine, engine assumes responsibility for KinBody::_pPhysicsData\n    \n            ";
m["ja function PhysicsEngineBase DestroyEnvironment"] = "\n\nvoid  **DestroyEnvironment**\\()\n    \n    called when environment switches to a different physics engine has to clear/deallocate any memory associated with KinBody::_pPhysicsData         ";
m["ja function PhysicsEngineBase InitKinBody"] = "\n\nbool  **InitKinBody**\\(KinBodyPtr body)\n    \n    notified when a new body has been initialized in the environment\n    \n            ";
m["ja function PhysicsEngineBase SetBodyVelocity \"KinBodyPtr; const Vector; const Vector; const std::vector\""] = "\n\nbool  **SetBodyVelocity**\\(KinBodyPtr body, const  Vector  & linearvel, const  Vector  & angularvel, const std::vector<  dReal  > & pJointVelocity)\n    \n    *Parameters*\n     ``linearvel`` - \n      linear velocity of base link \n     ``angularvel`` - \n      angular velocity rotation_axis*theta_dot \n     ``pJointVelocity`` - \n      - the joint velocities of the robot Sets the body velocity.. \n            ";
m["ja function PhysicsEngineBase SetBodyVelocity \"KinBodyPtr; const std::vector; const std::vector\""] = "\n\nbool  **SetBodyVelocity**\\(KinBodyPtr body, const std::vector<  Vector  > & pLinearVelocities, const std::vector<  Vector  > & pAngularVelocities)\n    \n    Sets the velocities for each link.\n    \n    *Parameters*\n     ``body`` - \n      the body to query velocities from. \n     ``pLinearVelocities`` - \n      the linear velocities for each link \n     ``pAngularVelocities`` - \n      the angular velocities for each link (axis * angular_speed) \n            ";
m["ja function PhysicsEngineBase SetLinkVelocity"] = "\n\nbool  **SetLinkVelocity**\\(KinBody::LinkPtr link, const  Vector  & linearvel, const  Vector  & angularvel)\n    \n    Force the body velocity of a link.\n    \n    *Parameters*\n     ``link`` - \n      link to set velocities. \n     ``linearvel`` - \n      linear velocity of base link \n     ``angularvel`` - \n      angular velocity rotation_axis*theta_dot \n            ";
m["ja function PhysicsEngineBase GetLinkVelocity"] = "\n\nbool  **GetLinkVelocity**\\(KinBody::LinkConstPtr link, Vector  & linearvel, Vector  & angularvel)\n    \n    *Parameters*\n     ``linearvel`` - \n      - linear velocity of base link \n     ``angularvel`` - \n      - angular velocity rotation_axis*theta_dot gets the velocity of a link \n            ";
m["ja function PhysicsEngineBase SetJointVelocity"] = "\n\nbool  **SetJointVelocity**\\(KinBody::JointPtr pjoint, const std::vector<  dReal  > & vJointVelocity)\n    \n    *Parameters*\n     ``pjoint`` - \n      the joint \n     ``vJointVelocity`` - \n      the new joint velocity sets the joint velocity \n            ";
m["ja function PhysicsEngineBase GetJointVelocity"] = "\n\nbool  **GetJointVelocity**\\(KinBody::JointConstPtr pjoint, std::vector<  dReal  > & vJointVelocity)\n    \n    *Parameters*\n     ``vJointVelocity`` - \n      the new joint velocity gets the joint velocity \n            ";
m["ja function PhysicsEngineBase SetBodyForce"] = "\n\nbool  **SetBodyForce**\\(KinBody::LinkPtr link, const  Vector  & force, const  Vector  & position, bool bAdd)\n    \n    *Parameters*\n     ``force`` - \n      the direction and magnitude of the force \n     ``position`` - \n      in the world where the force is getting applied \n     ``bAdd`` - \n      if true, force is added to previous forces, otherwise it is set add a force at a particular position in a link \n            ";
m["ja function PhysicsEngineBase SetBodyTorque"] = "\n\nbool  **SetBodyTorque**\\(KinBody::LinkPtr link, const  Vector  & torque, bool bAdd)\n    \n    *Parameters*\n     ``link`` - \n      the link to add a torque to \n     ``torque`` - \n      torque vector \n     ``bAdd`` - \n      if true, torque is added to previous torques, otherwise it is set adds torque to a body (absolute coords) \n            ";
m["ja function PhysicsEngineBase AddJointTorque"] = "\n\nbool  **AddJointTorque**\\(KinBody::JointPtr pjoint, const std::vector<  dReal  > & pTorques)\n    \n    *Parameters*\n     ``pjoint`` - \n      - the joint the torque is added to \n     ``pTorques`` - \n      - the torques added to the joint. Pointer because the joint dof can be greater than 1. adds torque to a joint \n            ";
m["ja function PhysicsEngineBase SetGravity"] = "\n\nvoid  **SetGravity**\\(const  Vector  & gravity)\n    \n    set the gravity direction\n    \n            ";
m["ja function PhysicsEngineBase GetGravity"] = "\n\nVector  **GetGravity**\\()\n    \n            ";
m["ja function PhysicsEngineBase SimulateStep"] = "\n\nvoid  **SimulateStep**\\(dReal fTimeElapsed)\n    \n    dynamically simulate system for fTimeElapsed seconds add torques to the joints of the body. Torques disappear after one timestep of simulation         ";
m["ja function SensorBase GetSensorData"] = "\n\nbool  **GetSensorData**\\(SensorDataPtr psensordata)\n    \n    *Parameters*\n     ``psensordata`` - \n      A pointer to SensorData returned from CreateSensorData Copy the most recent published data of the sensor. Once GetSensorData returns, the caller has full access to the data. This method is thread safe. \n            ";
m["ja function SensorBase SetTransform"] = "\n\nvoid  **SetTransform**\\(const  Transform  & trans)\n    \n    *Parameters*\n     ``trans`` - \n      - The transform defining the frame of the sensor. Set the transform of a sensor. \n            ";
m["ja function SensorBase GetTransform"] = "\n\nTransform  **GetTransform**\\()\n    \n            ";
m["ja function SensorBase GetName"] = "\n\nconst std::string &  **GetName**\\()\n    \n    *Return*\n        the name of the sensor \n        ";
m["ja function CollisionCheckerBase SetCollisionOptions \"int\""] = "\n\nbool  **SetCollisionOptions**\\(int collisionoptions)\n    \n    Set basic collision options using the CollisionOptions enum.\n    \n            ";
m["ja function CollisionCheckerBase GetCollisionOptions"] = "\n\nint  **GetCollisionOptions**\\()\n    \n            ";
m["ja function ViewerBase main"] = "\n\nint  **main**\\(bool bShow = true )\n    \n    *Parameters*\n     ``bShow`` - \n      if true will show the window goes into the main loop \n            ";
m["ja function ViewerBase quitmainloop"] = "\n\nvoid  **quitmainloop**\\()\n    \n    destroys the main loop\n    \n            ";
m["ja function ViewerBase ViewerSetSize"] = "\n\nvoid  **ViewerSetSize**\\(int w, int h)\n    \n            ";
m["ja function ViewerBase ViewerMove"] = "\n\nvoid  **ViewerMove**\\(int x, int y)\n    \n            ";
m["ja function ViewerBase ViewerSetTitle"] = "\n\nvoid  **ViewerSetTitle**\\(const std::string & ptitle)\n    \n            ";
m["ja function ViewerBase LoadModel"] = "\n\nbool  **LoadModel**\\(const std::string & pfilename)\n    \n            ";
m["ja function ViewerBase RegisterCallback"] = "\n\nboost::shared_ptr< void >  **RegisterCallback**\\(int properties, const  ViewerCallbackFn  & fncallback)\n    \n    registers a function with the viewer that gets called everytime a specified event occurs (part of ViewerEvents enum)\n    \n    *Return*\n        a handle to the callback. If this handle is deleted, the callback will be unregistered \n        ";
m["ja function ViewerBase EnvironmentSync"] = "\n\nvoid  **EnvironmentSync**\\()\n    \n    forces synchronization with the environment, returns when the environment is fully synchronized. Note that this method might not work if environment is locked in current thread         ";
m["ja function ViewerBase SetCamera"] = "\n\nvoid  **SetCamera**\\(const RaveTransform< float > & trans, float focalDistance = 0 )\n    \n    Set the camera transformation.\n    \n    *Parameters*\n     ``trans`` - \n      new camera transformation in the world coordinate system \n     ``focalDistance`` - \n      The new focal distance of the camera (higher values is higher zoom). If 0, then the previous focal distance is preserved. \n            ";
m["ja function ViewerBase SetCamera"] = "\n\nvoid  **SetCamera**\\(const RaveTransform< float > & trans, float focalDistance = 0 )\n    \n    Set the camera transformation.\n    \n    *Parameters*\n     ``trans`` - \n      new camera transformation in the world coordinate system \n     ``focalDistance`` - \n      The new focal distance of the camera (higher values is higher zoom). If 0, then the previous focal distance is preserved. \n            ";
m["ja function ViewerBase GetCameraTransform"] = "\n\nRaveTransform< float >  **GetCameraTransform**\\()\n    \n    Return the current camera transform that the viewer is rendering the environment at.\n    \n            ";
m["ja function ViewerBase GetCameraImage"] = "\n\nbool  **GetCameraImage**\\(std::vector< uint8_t > & memory, int width, int height, const RaveTransform< float > & t, const  SensorBase::CameraIntrinsics  & KK)\n    \n    *Parameters*\n     ``memory`` - \n      the memory where the image will be stored at, has to store 3*width*height \n     ``width`` - \n      width of the image \n     ``height`` - \n      height of the image \n     ``t`` - \n      the rotation and translation of the camera. Note that z is treated as the front of the camera! So all points in front of the camera have a positive dot product with its direction. \n     ``KK`` - \n      4 values such that the intrinsic matrix can be reconstructed [pKK[0] 0 pKK[2]; 0 pKK[1] pKK[3]; 0 0 1]; Renders a 24bit RGB image of dimensions width and height from the current scene. The camera is meant to show the underlying OpenRAVE world as a robot would see it, so all graphs rendered with the plotX and drawX functions are hidden. \n            ";
m["ja function EnvironmentBase Reset"] = "\n\nvoid  **Reset**\\()\n    \n    Resets all objects of the scene (preserves all problems, planners).\n    \n    Do not call inside a SimulationStep call         ";
m["ja function EnvironmentBase Destroy"] = "\n\nvoid  **Destroy**\\()\n    \n    Releases all environment resources, should be always called when environment stops being used.\n    \n    Removing all environment pointer might not be enough to destroy the environment resources.         ";
m["ja function EnvironmentBase GetPluginInfo"] = "\n\nvoid  **GetPluginInfo**\\(std::list< std::pair< std::string,  PLUGININFO  > > & plugins)\n    \n    Get all the loaded plugins and the interfaces they support.\n    \n    *Parameters*\n     ``plugins`` - \n      A list of plugins. Each entry has the plugin name and the interfaces it supports \n            ";
m["ja function EnvironmentBase GetLoadedInterfaces"] = "\n\nvoid  **GetLoadedInterfaces**\\(std::map< InterfaceType, std::vector< std::string > > & interfacenames)\n    \n    Get a list of all the loaded interfaces.\n    \n            ";
m["ja function EnvironmentBase LoadPlugin"] = "\n\nbool  **LoadPlugin**\\(const std::string & name)\n    \n    Load a plugin and its interfaces.\n    \n    *Parameters*\n     ``name`` - \n      the filename of the plugin to load If the plugin is already loaded, will reload it. \n            ";
m["ja function EnvironmentBase ReloadPlugins"] = "\n\nvoid  **ReloadPlugins**\\()\n    \n    Reloads all currently loaded plugins.\n    \n    The interfaces currently created remain will continue using the old plugins, so this function is safe in that plugins currently loaded remain loaded until the last interface that uses them is released.         ";
m["ja function EnvironmentBase ReloadPlugins"] = "\n\nvoid  **ReloadPlugins**\\()\n    \n    Reloads all currently loaded plugins.\n    \n    The interfaces currently created remain will continue using the old plugins, so this function is safe in that plugins currently loaded remain loaded until the last interface that uses them is released.         ";
m["ja function EnvironmentBase CreateRobot"] = "\n\nRobotBasePtr  **CreateRobot**\\(const std::string & name = \"\" )\n    \n            ";
m["ja function EnvironmentBase CreatePlanner"] = "\n\nPlannerBasePtr  **CreatePlanner**\\(const std::string & name)\n    \n            ";
m["ja function EnvironmentBase CreateSensorSystem"] = "\n\nSensorSystemBasePtr  **CreateSensorSystem**\\(const std::string & name)\n    \n            ";
m["ja function EnvironmentBase CreateController"] = "\n\nControllerBasePtr  **CreateController**\\(const std::string & name)\n    \n            ";
m["ja function EnvironmentBase CreateProblem"] = "\n\nProblemInstancePtr  **CreateProblem**\\(const std::string & name)\n    \n            ";
m["ja function EnvironmentBase CreateIkSolver"] = "\n\nIkSolverBasePtr  **CreateIkSolver**\\(const std::string & name)\n    \n            ";
m["ja function EnvironmentBase CreateIkSolver"] = "\n\nIkSolverBasePtr  **CreateIkSolver**\\(const std::string & name)\n    \n            ";
m["ja function EnvironmentBase CreateIkSolver"] = "\n\nIkSolverBasePtr  **CreateIkSolver**\\(const std::string & name)\n    \n            ";
m["ja function EnvironmentBase CreateIkSolver"] = "\n\nIkSolverBasePtr  **CreateIkSolver**\\(const std::string & name)\n    \n            ";
m["ja function EnvironmentBase CreateViewer"] = "\n\nViewerBasePtr  **CreateViewer**\\(const std::string & name)\n    \n            ";
m["ja function EnvironmentBase CloneSelf"] = "\n\nEnvironmentBasePtr  **CloneSelf**\\(int options)\n    \n    Create and return a clone of the current environment.\n    \n    *Parameters*\n     ``options`` - \n      A set of CloningOptions describing what is actually cloned. Clones do not share any memory or resource between each other. or their parent making them ideal for performing separte planning experiments while keeping the parent environment unchanged. By default a clone only copies the collision checkers and physics engine. When bodies are cloned, the unique ids are preserved across environments (each body can be referenced with its id in both environments). The attached and grabbed bodies of each body/robot are also copied to the new environment.\n    \n    *Return*\n        An environment of the same type as this environment containing the copied information. \n        ";
m["ja function EnvironmentBase SetCollisionChecker"] = "\n\nbool  **SetCollisionChecker**\\(CollisionCheckerBasePtr pchecker)\n    \n    set the global environment collision checker\n    \n            ";
m["ja function EnvironmentBase GetCollisionChecker"] = "\n\nCollisionCheckerBasePtr  **GetCollisionChecker**\\()\n    \n            ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, KinBodyConstPtr pbody2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody1, KinBodyConstPtr pbody2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink1, KinBody::LinkConstPtr plink2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBody::LinkConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink1, KinBody::LinkConstPtr plink2, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBody::LinkConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBody::LinkConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBody::LinkConstPtr plink, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBody::LinkConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"KinBodyConstPtr; const std::vector; const std::vector; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(KinBodyConstPtr pbody, const std::vector<  KinBodyConstPtr  > & vbodyexcluded, const std::vector<  KinBody::LinkConstPtr  > & vlinkexcluded, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(KinBodyConstPtr,const std::vector<KinBodyConstPtr>&,const std::vector<KinBody::LinkConstPtr>&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; KinBodyConstPtr; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, KinBodyConstPtr pbody, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,KinBodyConstPtr,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase CheckCollision \"const RAY; CollisionReportPtr\""] = "\n\nbool  **CheckCollision**\\(const  RAY  & ray, CollisionReportPtr report = CollisionReportPtr () )\n    \n    *See*\n        CollisionCheckerBase::CheckCollision(const RAY&,CollisionReportPtr) \n        ";
m["ja function EnvironmentBase Load"] = "\n\nbool  **Load**\\(const std::string & filename)\n    \n    Loads a scene from an XML file, environment is locked automatically making this method thread-safe.\n    \n            ";
m["ja function EnvironmentBase Save"] = "\n\nbool  **Save**\\(const std::string & filename)\n    \n    Saves a scene depending on the filename extension. Default is in COLLADA format.\n    \n            ";
m["ja function EnvironmentBase ReadRobotXMLFile \"const std::string\""] = "\n\nRobotBasePtr  **ReadRobotXMLFile**\\(const std::string & filename)\n    \n            ";
m["ja function EnvironmentBase ReadRobotXMLData \"RobotBasePtr; const std::string; const std::list\""] = "\n\nRobotBasePtr  **ReadRobotXMLData**\\(RobotBasePtr robot, const std::string & data, const std::list< std::pair< std::string, std::string > > & atts)\n    \n    *Parameters*\n     ``robot`` - \n      If a null pointer is passed, a new robot will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      the XML attributes/value pairs Initialize a robot from an XML formatted string The robot should not be added the environment when calling this function. \n            ";
m["ja function EnvironmentBase ReadKinBodyXMLFile \"const std::string\""] = "\n\nKinBodyPtr  **ReadKinBodyXMLFile**\\(const std::string & filename)\n    \n            ";
m["ja function EnvironmentBase ReadKinBodyXMLData \"KinBodyPtr; const std::string; const std::list\""] = "\n\nKinBodyPtr  **ReadKinBodyXMLData**\\(KinBodyPtr body, const std::string & data, const std::list< std::pair< std::string, std::string > > & atts)\n    \n    Initializes a kinematic body from an XML formatted string.\n    \n    *Parameters*\n     ``body`` - \n      If a null pointer is passed, a new body will be created, otherwise an existing robot will be filled \n     ``atts`` - \n      the XML attributes/value pairs \n            ";
m["ja function EnvironmentBase ReadInterfaceXMLFile \"const std::string\""] = "\n\nInterfaceBasePtr  **ReadInterfaceXMLFile**\\(const std::string & filename)\n    \n            ";
m["ja function EnvironmentBase AddKinBody"] = "\n\nbool  **AddKinBody**\\(KinBodyPtr body, bool bAnonymous = false )\n    \n    Add a body to the environment.\n    \n    *Parameters*\n     ``body`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body with the same name, will make body's name unique \n            ";
m["ja function EnvironmentBase AddKinBody"] = "\n\nbool  **AddKinBody**\\(KinBodyPtr body, bool bAnonymous = false )\n    \n    Add a body to the environment.\n    \n    *Parameters*\n     ``body`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body with the same name, will make body's name unique \n            ";
m["ja function EnvironmentBase AddRobot"] = "\n\nbool  **AddRobot**\\(RobotBasePtr robot, bool bAnonymous = false )\n    \n    *Parameters*\n     ``robot`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body with the same name, will make body's name unique add a body to the environment \n            ";
m["ja function EnvironmentBase AddRobot"] = "\n\nbool  **AddRobot**\\(RobotBasePtr robot, bool bAnonymous = false )\n    \n    *Parameters*\n     ``robot`` - \n      the pointer to an initialized body \n     ``bAnonymous`` - \n      if true and there exists a body with the same name, will make body's name unique add a body to the environment \n            ";
m["ja function EnvironmentBase RemoveKinBody"] = "\n\nbool  **RemoveKinBody**\\(KinBodyPtr body)\n    \n    Removes a body from the environment\n    \n    *Parameters*\n     ``body`` - \n      the body to remove \n            ";
m["ja function EnvironmentBase GetKinBody"] = "\n\nKinBodyPtr  **GetKinBody**\\(const std::string & name)\n    \n    Query a body from its name.\n    \n    *Return*\n        first KinBody (including robots) that matches with name \n        ";
m["ja function EnvironmentBase GetRobot"] = "\n\nRobotBasePtr  **GetRobot**\\(const std::string & name)\n    \n    Query a robot from its name.\n    \n    *Return*\n        first Robot that matches the name \n        ";
m["ja function EnvironmentBase GetBodyFromEnvironmentId"] = "\n\nKinBodyPtr  **GetBodyFromEnvironmentId**\\(int id)\n    \n    Get the corresponding body from its unique network id.\n    \n            ";
m["ja function EnvironmentBase CreateKinBody"] = "\n\nKinBodyPtr  **CreateKinBody**\\(const std::string & name = \"\" )\n    \n    Return an empty KinBody instance.\n    \n            ";
m["ja function EnvironmentBase CreateTrajectory"] = "\n\nTrajectoryBasePtr  **CreateTrajectory**\\(int nDOF)\n    \n    Return an empty trajectory instance initialized to nDOF degrees of freedom.\n    \n            ";
m["ja function EnvironmentBase LoadProblem"] = "\n\nint  **LoadProblem**\\(ProblemInstancePtr prob, const std::string & cmdargs)\n    \n    Load a new problem, need to Lock if calling outside simulation thread.\n    \n            ";
m["ja function EnvironmentBase RemoveProblem"] = "\n\nbool  **RemoveProblem**\\(ProblemInstancePtr prob)\n    \n    Load a new problem, need to Lock if calling outside simulation thread.\n    \n            ";
m["ja function EnvironmentBase GetLoadedProblems"] = "\n\nboost::shared_ptr< void >  **GetLoadedProblems**\\(std::list<  ProblemInstancePtr  > & listProblems)\n    \n    Returns a list of loaded problems with a lock. As long as the lock is held, the problems are guaranteed to stay loaded in the environment.\n    \n    *Return*\n        returns a pointer to a Lock. Destroying the shared_ptr will release the lock \n        ";
m["ja function EnvironmentBase SetPhysicsEngine"] = "\n\nbool  **SetPhysicsEngine**\\(PhysicsEngineBasePtr pengine)\n    \n    *Parameters*\n     ``the`` - \n      engine to set, if NULL, environment sets an dummy physics engine set the physics engine, disabled by default \n            ";
m["ja function EnvironmentBase GetPhysicsEngine"] = "\n\nPhysicsEngineBasePtr  **GetPhysicsEngine**\\()\n    \n            ";
m["ja function EnvironmentBase RegisterCollisionCallback"] = "\n\nboost::shared_ptr< void >  **RegisterCollisionCallback**\\(const  CollisionCallbackFn  & callback)\n    \n    Register a collision callback.Whenever a collision is detected between between bodies during a CheckCollision call or physics simulation, the callback is called. The callback should return an action specifying how the collision should be handled:\n    \n    *Return*\n        a handle to the registration, once the handle loses scope, the callback is unregistered \n        ";
m["ja function EnvironmentBase StepSimulation"] = "\n\nvoid  **StepSimulation**\\(dReal timeStep)\n    \n    Makes one simulation step.\n    \n            ";
m["ja function EnvironmentBase StartSimulation"] = "\n\nvoid  **StartSimulation**\\(dReal fDeltaTime, bool bRealTime = true )\n    \n    *Parameters*\n     ``fDeltaTime`` - \n      the delta step to take in simulation \n     ``bRealTime`` - \n      if false will call SimulateStep as fast as possible, otherwise will time the simulate step calls so that simulation progresses with real system time. Start the internal simulation thread that calls the physics engine loop and SimulateStep for all modules. Resets simulation time to 0. \n            ";
m["ja function EnvironmentBase StopSimulation"] = "\n\nvoid  **StopSimulation**\\()\n    \n    Stops the internal physics loop, stops calling SimulateStep for all modules.\n    \n            ";
m["ja function EnvironmentBase GetSimulationTime"] = "\n\nuint64_t  **GetSimulationTime**\\()\n    \n    *Return*\n        simulation time since the start of the environment (in microseconds) \n        ";
m["ja function EnvironmentBase GetViewer"] = "\n\nViewerBasePtr  **GetViewer**\\()\n    \n            ";
m["ja function EnvironmentBase drawlinestrip \"const float; int; int; float; const float\""] = "\n\nGraphHandlePtr  **drawlinestrip**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a series of connected lines with individual colors.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawlinelist \"const float; int; int; float; const float\""] = "\n\nGraphHandlePtr  **drawlinelist**\\(const float * ppoints, int numPoints, int stride, float fwidth, const float * colors)\n    \n    Draws a list of individual lines, each specified by a succeeding pair of points.\n    \n    *Parameters*\n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride)\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawarrow"] = "\n\nGraphHandlePtr  **drawarrow**\\(const RaveVector< float > & p1, const RaveVector< float > & p2, float fwidth, const RaveVector< float > & color = RaveVector< float >(1, 0.5, 0.5, 1) )\n    \n    Draws an arrow p1 is start, p2 is finish.\n    \n    *Parameters*\n     ``color`` - \n      the rgb color of the point. The last component of the color is used for alpha blending.\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawbox"] = "\n\nGraphHandlePtr  **drawbox**\\(const RaveVector< float > & vpos, const RaveVector< float > & vextents)\n    \n    Draws a box.\n    \n    extents are half the width, height, and depth of the box\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawplane"] = "\n\nGraphHandlePtr  **drawplane**\\(const RaveTransform< float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawplane"] = "\n\nGraphHandlePtr  **drawplane**\\(const RaveTransform< float > & tplane, const RaveVector< float > & vextents, const boost::multi_array< float, 3 > & vtexture)\n    \n    Draws a textured plane.\n    \n    *Parameters*\n     ``tplane`` - \n      describes the center of the plane. the zaxis of this coordinate is the normal of the plane \n     ``vextents`` - \n      the extents of the plane along the x and y directions (z is ignored) \n     ``vtexture`` - \n      a 3D array specifying height x width x color (the color dimension can be 1, 3, or 4 (for alpha blending))\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase drawtrimesh \"const float; int; const int; int; const boost::multi_array\""] = "\n\nGraphHandlePtr  **drawtrimesh**\\(const float * ppoints, int stride, const int * pIndices, int numTriangles, const boost::multi_array< float, 2 > & colors)\n    \n    Draws a triangle mesh, each vertices of each triangle should be counter-clockwise.\n    \n    *Parameters*\n     ``ppoints`` - \n      - array of 3D points \n     ``stride`` - \n      stride in bytes to next point, ie: nextpoint = (float*)((char*)ppoints+stride) \n     ``pIndices`` - \n      If not NULL, zero-based indices into the points for every triangle. pIndices should be of size numTriangles. If pIndices is NULL, ppoints is assumed to contain numTriangles*3 points and triangles will be rendered in list order. \n     ``color`` - \n      The color of the triangle. The last component of the color is used for alpha blending\n    \n    *Return*\n        handle to plotted points, graph is removed when handle is destroyed (goes out of scope). This requires the user to always store the handle in a persistent variable if the plotted graphics are to remain on the viewer. \n        ";
m["ja function EnvironmentBase GetRobots"] = "\n\nvoid  **GetRobots**\\(std::vector<  RobotBasePtr  > & robots)\n    \n    Fill an array with all robots loaded in the environment.\n    \n            ";
m["ja function EnvironmentBase GetBodies"] = "\n\nvoid  **GetBodies**\\(std::vector<  KinBodyPtr  > & bodies)\n    \n    Get all bodies loaded in the environment (including robots).\n    \n    *Parameters*\n     ``bodies`` - \n      filled with all the bodies \n            ";
m["ja function EnvironmentBase UpdatePublishedBodies"] = "\n\nvoid  **UpdatePublishedBodies**\\()\n    \n    updates the published bodies that viewers and other programs listening in on the environment see. For example, calling this function inside a planning loop allows the viewer to update the environment reflecting the status of the planner. Assumes that the physics are locked.         ";
m["ja function EnvironmentBase Triangulate"] = "\n\nbool  **Triangulate**\\(KinBody::Link::TRIMESH  & trimesh, KinBodyConstPtr pbody)\n    \n    triangulation of the body including its current transformation. trimesh will be appended the new data.\n    \n            ";
m["ja function EnvironmentBase TriangulateScene"] = "\n\nbool  **TriangulateScene**\\(KinBody::Link::TRIMESH  & trimesh, TriangulateOptions opts, const std::string & name)\n    \n    *Parameters*\n     ``opts`` - \n      - Controlls what to triangulate general triangulation of the whole scene. trimesh will be appended the new data. \n            ";
m["ja function EnvironmentBase SetDebugLevel"] = "\n\nvoid  **SetDebugLevel**\\(DebugLevel level)\n    \n    *Parameters*\n     ``level`` - \n      0 for no debug, 1 - to print all debug messeges. Default value for release builds is 0, for debug builds it is 1 declaring variables with stdcall can be a little complex sets the debug level \n            ";
m["ja function EnvironmentBase GetDebugLevel"] = "\n\nDebugLevel  **GetDebugLevel**\\()\n    \n            ";
m["ja function EnvironmentBase GetHomeDirectory"] = "\n\nconst std::string &  **GetHomeDirectory**\\()\n    \n    Returns the openrave home directory where settings, cache, and other files are stored.\n    \n    On Linux/Unix systems, this is usually $HOME/.openrave, on Windows this is $HOMEPATH/.openrave         ";
m["ja function quatFromAxisAngle \"const RaveVector\""] = "\n\nRaveVector < T >  **quatFromAxisAngle**\\(const  RaveVector < T > & axisangle)\n    \n    Converts an axis-angle rotation into a quaternion.\n    \n    *Parameters*\n     ``axisangle`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["ja function quatFromAxisAngle \"const RaveVector; T\""] = "\n\nRaveVector < T >  **quatFromAxisAngle**\\(const  RaveVector < T > & axis, T angle)\n    \n    Converts an axis-angle rotation into a quaternion.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis, 3 values \n     ``angle`` - \n      rotation angle (radians) \n            ";
m["ja function quatFromMatrix \"const RaveTransform\""] = "\n\nRaveVector < T >  **quatFromMatrix**\\(const  RaveTransformMatrix < T > & rotation)\n    \n    Converts the rotation of a matrix into a quaternion.\n    \n    *Parameters*\n     ``t`` - \n      transform for extracting the 3x3 rotation. \n            ";
m["ja function quatSlerp \"const RaveVector; const RaveVector; T\""] = "\n\nRaveVector < T >  **quatSlerp**\\(const  RaveVector < T > & quat0, const  RaveVector < T > & quat1, T t)\n    \n    Sphereical linear interpolation between two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n     ``t`` - \n      real value in [0,1]. 0 returns quat1, 1 returns quat2 \n            ";
m["ja function axisAngleFromMatrix \"const RaveTransformMatrix\""] = "\n\nRaveVector < T >  **axisAngleFromMatrix**\\(const  RaveTransformMatrix < T > & rotation)\n    \n    Converts the rotation of a matrix into axis-angle representation.\n    \n    *Parameters*\n     ``rotation`` - \n      3x3 rotation matrix \n            ";
m["ja function axisAngleFromQuat \"const RaveVector\""] = "\n\nRaveVector < T >  **axisAngleFromQuat**\\(const  RaveVector < T > & quat)\n    \n    Converts a quaternion into the axis-angle representation.\n    \n    *Parameters*\n     ``quat`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["ja function matrixFromQuat \"const RaveVector\""] = "\n\nRaveTransformMatrix < T >  **matrixFromQuat**\\(const  RaveVector < T > & quat)\n    \n    Converts a quaternion to a 3x3 matrix.\n    \n    *Parameters*\n     ``quat`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["ja function matrixFromAxisAngle \"const RaveVector\""] = "\n\nRaveTransformMatrix < T >  **matrixFromAxisAngle**\\(const  RaveVector < T > & axisangle)\n    \n    Converts an axis-angle rotation to a 3x3 matrix.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["ja function matrixFromAxisAngle \"const RaveVector\""] = "\n\nRaveTransformMatrix < T >  **matrixFromAxisAngle**\\(const  RaveVector < T > & axisangle)\n    \n    Converts an axis-angle rotation to a 3x3 matrix.\n    \n    *Parameters*\n     ``axis`` - \n      unit axis * rotation angle (radians), 3 values \n            ";
m["ja function quatRotateDirection"] = "\n\nRaveVector < T >  **quatRotateDirection**\\(const  RaveVector < T > & sourcedir, const  RaveVector < T > & targetdir)\n    \n    Return the minimal quaternion that orients sourcedir to targetdir.\n    \n    *Parameters*\n     ``sourcedir`` - \n      direction of the original vector, 3 values \n     ``targetdir`` - \n      new direction, 3 values \n            ";
m["ja function quatMultiply"] = "\n\nRaveVector < T >  **quatMultiply**\\(const  RaveVector < T > & quat0, const  RaveVector < T > & quat1)\n    \n    Multiply two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["ja function quatMultiply"] = "\n\nRaveVector < T >  **quatMultiply**\\(const  RaveVector < T > & quat0, const  RaveVector < T > & quat1)\n    \n    Multiply two quaternions.\n    \n    *Parameters*\n     ``quat0`` - \n      quaternion, (s,vx,vy,vz) \n     ``quat1`` - \n      quaternion, (s,vx,vy,vz) \n            ";
m["ja enum DebugLevel"] = "\n\n **DebugLevel**\n    \n            ";
m["ja enum SerializationOptions"] = "\n\n **SerializationOptions**\n    \n    serialization options for interfaces\n    \n            ";
m["ja enum CollisionOptions"] = "\n\n **CollisionOptions**\n    \n    options for collision checker\n    \n            ";
m["ja enum CollisionAction"] = "\n\n **CollisionAction**\n    \n    action to perform whenever a collision is detected between objects\n    \n            ";
m["ja enum CloningOptions"] = "\n\n **CloningOptions**\n    \n            ";
m["ja enum PhysicsEngineOptions"] = "\n\n **PhysicsEngineOptions**\n    \n    basic options for physics engine\n    \n            ";
m["ja enum IkFilterOptions"] = "\n\n **IkFilterOptions**\n    \n    Controls what information gets validated when searching for an inverse kinematics solution.\n    \n            ";
m["ja enum IkFilterReturn"] = "\n\n **IkFilterReturn**\n    \n    Return value for the ik filter that can be optionally set on an ik solver.\n    \n            ";
m["ja enum SaveParameters"] = "\n\n **SaveParameters**\n    \n    Parameters passed into the state savers to control what information gets saved.\n    \n            ";
m["ja enum GeomType"] = "\n\n **GeomType**\n    \n    The type of geometry primitive.\n    \n            ";
m["ja enum JointType"] = "\n\n **JointType**\n    \n    The type of joint movement.\n    \n            ";
m["ja enum DOFAffine"] = "\n\n **DOFAffine**\n    \n    if planner should plan with affine transformations, use this enumeartion to specify the real dofs\n    \n            ";
m["ja enum SensorType"] = "\n\n **SensorType**\n    \n            ";
m["ja enum ViewerEvents"] = "\n\n **ViewerEvents**\n    \n            ";
m["ja enum TriangulateOptions"] = "\n\n **TriangulateOptions**\n    \n    A set of options specifying what to triangulate.\n    \n            ";

}
}
